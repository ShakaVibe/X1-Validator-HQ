<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>X1 Validator Headquarters</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect fill='%2300d4ff' width='32' height='32' rx='6'/><text x='50%' y='55%' font-family='Arial' font-size='18' font-weight='bold' fill='%23001029' text-anchor='middle' dominant-baseline='middle'>X1</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a1020;
      --bg-secondary: #0d1528;
      --bg-card: #111d32;
      --bg-card-hover: #162440;
      --accent-blue: #4da6ff;
      --accent-cyan: #00d4ff;
      --accent-gold: #f0b90b;
      --accent-gradient: linear-gradient(135deg, #4da6ff 0%, #00d4ff 100%);
      --text-primary: #ffffff;
      --text-secondary: #8a8f98;
      --text-dim: #5a5f68;
      --success: #00e676;
      --warning: #ffab00;
      --danger: #ff5252;
      --border: #1e3050;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Space Grotesk', sans-serif;
      background: radial-gradient(ellipse at center, #0d1a30 0%, #0a1020 50%, #060810 100%);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Global scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--accent-blue);
    }

    .bg-pattern {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }

    .bg-line {
      position: absolute;
      background: var(--accent-gradient);
      opacity: 0.06;
    }

    .bg-line-1 {
      width: 3px;
      height: 150%;
      top: -25%;
      right: 15%;
      transform: rotate(35deg);
    }

    .bg-line-2 {
      width: 3px;
      height: 150%;
      top: -25%;
      right: 12%;
      transform: rotate(35deg);
    }

    .bg-line-3 {
      width: 3px;
      height: 100%;
      bottom: 0;
      right: 20%;
      transform: rotate(-55deg);
      transform-origin: bottom right;
    }

    header {
      position: relative;
      z-index: 10;
      padding: 1.5rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
    }

    .logo {
      display: flex;
      align-items: center;
      font-size: 1.75rem;
      font-weight: 700;
      text-decoration: none;
      cursor: pointer;
    }

    .logo:hover {
      opacity: 0.9;
    }

    .logo-x1 {
      display: flex;
      font-size: 2.25rem;
      letter-spacing: -1px;
    }

    .logo-x {
      color: var(--text-primary);
    }

    .logo-1 {
      color: var(--accent-blue);
    }

    .logo-subtitle {
      font-size: 1.1rem;
      color: var(--text-secondary);
      font-weight: 500;
      margin-left: 0.875rem;
      padding-left: 0.875rem;
      border-left: 1px solid var(--border);
    }

    .logo-subtitle-validator {
      color: var(--text-primary);
    }

    .logo-subtitle-hq {
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header-links {
      display: flex;
      gap: 1.5rem;
    }

    .header-links a {
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 0.9rem;
      transition: color 0.2s;
    }

    .header-links a:hover {
      color: var(--accent-blue);
    }

    /* Network Toggle Switch */
    .network-toggle-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 1.5rem;
      padding-left: 1.5rem;
      border-left: 1px solid var(--border);
    }

    .network-toggle-label {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      transition: all 0.3s;
    }

    .network-toggle-label.x1 {
      color: var(--accent-cyan);
    }

    .network-toggle-label.solana {
      color: #9945FF;
    }

    .network-toggle-label.inactive {
      color: var(--text-dim);
    }

    .network-toggle {
      position: relative;
      width: 44px;
      height: 22px;
      background: linear-gradient(135deg, #00e5ff 0%, #4da6ff 100%);
      border-radius: 11px;
      cursor: pointer;
      transition: all 0.3s;
      border: none;
      padding: 0;
    }

    .network-toggle.solana-active {
      background: linear-gradient(135deg, #9945FF 0%, #14F195 100%);
    }

    .network-toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .network-toggle.solana-active .network-toggle-slider {
      left: 24px;
    }

    .solana-logo-small {
      width: 22px;
      height: 22px;
    }

    .solana-logo-small .sol-top,
    .solana-logo-small .sol-middle,
    .solana-logo-small .sol-bottom {
      fill: var(--text-dim);
    }

    .network-toggle-label.solana .solana-logo-small .sol-top {
      fill: #00FFA3;
    }

    .network-toggle-label.solana .solana-logo-small .sol-middle {
      fill: #03E1FF;
    }

    .network-toggle-label.solana .solana-logo-small .sol-bottom {
      fill: #DC1FFF;
    }

    .x1-logo-small {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #000000;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 1.25rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      border: 1px solid var(--border);
    }

    .x1-logo-small .x-char {
      color: #ffffff;
    }

    .x1-logo-small .one-char {
      color: var(--accent-blue);
    }

    /* Disclaimer/Terms Modal */
    .disclaimer-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 100000;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }

    .disclaimer-modal-overlay.show {
      display: flex;
    }

    .disclaimer-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      max-width: 650px;
      width: 100%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      animation: modalIn 0.3s ease-out;
    }

    .disclaimer-modal-header {
      padding: 1.5rem 1.5rem 1rem;
      border-bottom: 1px solid var(--border);
      text-align: center;
    }

    .disclaimer-modal-header h2 {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .disclaimer-modal-header p {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .disclaimer-modal-body {
      padding: 1.5rem;
      overflow-y: auto;
      flex: 1;
    }

    .disclaimer-section {
      margin-bottom: 1.25rem;
    }

    .disclaimer-section:last-child {
      margin-bottom: 0;
    }

    .disclaimer-section h3 {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .disclaimer-section p {
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 0.5rem;
    }

    .disclaimer-section p:last-child {
      margin-bottom: 0;
    }

    .disclaimer-section ul {
      margin: 0;
      padding-left: 1.25rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    .disclaimer-section ul li {
      margin-bottom: 0.35rem;
    }

    .disclaimer-warning-box {
      background: rgba(255, 152, 0, 0.1);
      border: 1px solid rgba(255, 152, 0, 0.3);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.25rem;
    }

    .disclaimer-warning-box p {
      color: #ffb74d;
      font-size: 0.85rem;
      margin: 0;
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
    }

    .disclaimer-warning-box .warning-icon {
      font-size: 1.1rem;
      flex-shrink: 0;
    }

    .disclaimer-modal-footer {
      padding: 1rem 1.5rem 1.5rem;
      border-top: 1px solid var(--border);
    }

    .disclaimer-checkbox-container {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      margin-bottom: 1rem;
      cursor: pointer;
    }

    .disclaimer-checkbox-container input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin-top: 2px;
      cursor: pointer;
      accent-color: var(--accent-blue);
    }

    .disclaimer-checkbox-container label {
      font-size: 0.9rem;
      color: var(--text-primary);
      cursor: pointer;
      line-height: 1.4;
    }

    .disclaimer-accept-btn {
      width: 100%;
      padding: 1rem;
      background: var(--accent-gradient);
      border: none;
      border-radius: 8px;
      color: #000;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .disclaimer-accept-btn:hover:not(:disabled) {
      transform: scale(1.02);
      box-shadow: 0 4px 15px rgba(77, 166, 255, 0.3);
    }

    .disclaimer-accept-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .disclaimer-version {
      text-align: center;
      margin-top: 1rem;
      font-size: 0.7rem;
      color: var(--text-dim);
    }

    /* Solana Coming Soon Modal */
    .solana-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10000;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(4px);
    }

    .solana-modal-overlay.show {
      display: flex;
    }

    .solana-modal {
      background: linear-gradient(135deg, rgba(153, 69, 255, 0.1) 0%, rgba(20, 241, 149, 0.1) 100%);
      border: 1px solid rgba(153, 69, 255, 0.3);
      border-radius: 16px;
      padding: 2.5rem;
      max-width: 420px;
      text-align: center;
      position: relative;
      animation: solanaModalIn 0.3s ease-out;
    }

    @keyframes solanaModalIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .solana-modal-logo {
      width: 80px;
      height: 80px;
      margin: 0 auto 1.5rem;
      background: linear-gradient(135deg, #9945FF 0%, #14F195 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 30px rgba(153, 69, 255, 0.4);
    }

    .solana-modal-logo svg {
      width: 45px;
      height: 45px;
    }

    .solana-modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #9945FF 0%, #14F195 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.75rem;
    }

    .solana-modal-subtitle {
      color: var(--text-secondary);
      font-size: 1rem;
      margin-bottom: 1.5rem;
      line-height: 1.5;
    }

    .solana-modal-features {
      text-align: left;
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }

    .solana-modal-feature {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--text-secondary);
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }

    .solana-modal-feature:last-child {
      margin-bottom: 0;
    }

    .solana-modal-feature-icon {
      color: #14F195;
    }

    .solana-modal-close {
      background: linear-gradient(135deg, #9945FF 0%, #14F195 100%);
      border: none;
      color: #000;
      font-weight: 600;
      padding: 0.75rem 2rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .solana-modal-close:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(153, 69, 255, 0.4);
    }

    main {
      position: relative;
      z-index: 10;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* Network Stats Bar */
    .network-stats {
      display: flex;
      justify-content: center;
      gap: 0;
      margin-bottom: 2rem;
      padding: 1rem 1.25rem;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .network-stat {
      text-align: center;
      padding: 0.25rem 1.5rem;
      border-right: 1px solid var(--border);
    }

    .network-stat:last-child {
      border-right: none;
    }

    .network-stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-cyan);
    }

    .network-stat-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 0.25rem;
    }

    /* Epoch Progress Bar - Compact */
    .epoch-progress {
      margin-bottom: 1.5rem;
      padding: 0.75rem 1.25rem;
      background: var(--bg-secondary);
      border-radius: 10px;
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .epoch-progress-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }

    .epoch-progress-bar {
      flex: 1;
      height: 6px;
      background: var(--bg-primary);
      border-radius: 3px;
      overflow: hidden;
      min-width: 100px;
    }

    .epoch-progress-fill {
      height: 100%;
      background: var(--accent-gradient);
      border-radius: 3px;
      transition: width 0.5s ease;
    }

    .epoch-progress-percent {
      font-size: 0.85rem;
      color: var(--accent-blue);
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      white-space: nowrap;
    }

    .epoch-progress-time {
      font-size: 0.8rem;
      color: var(--accent-cyan);
      font-family: 'JetBrains Mono', monospace;
      white-space: nowrap;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: none;
      padding: 0;
      gap: 0.75rem;
    }

    .tab {
      padding: 0.75rem 1.75rem;
      background: transparent;
      border: 2px solid var(--accent-blue);
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Space Grotesk', sans-serif;
      border-radius: 8px;
    }

    .tab:hover {
      color: var(--text-primary);
      background: rgba(77, 166, 255, 0.1);
    }

    .tab.active {
      color: #000000;
      background: var(--accent-gradient);
      border: 2px solid transparent;
      box-shadow: 0 4px 15px rgba(77, 166, 255, 0.3);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .x1-logo-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #000000;
      border-radius: 50%;
      width: 38px;
      height: 38px;
      font-size: 1.3rem;
      font-weight: 700;
      margin-right: 6px;
      vertical-align: middle;
      letter-spacing: -1px;
    }
    
    .tab.active .x1-logo-btn {
      box-shadow: 0 0 8px rgba(77, 166, 255, 0.5);
    }

    /* Search section */
    .search-section {
      text-align: center;
      margin-bottom: 2rem;
    }

    .search-section h1 {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .search-section h1 span {
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .text-gradient {
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .search-section p {
      color: var(--text-secondary);
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    .search-container {
      display: flex;
      gap: 1rem;
      max-width: 800px;
      margin: 0 auto;
      flex-wrap: wrap;
      justify-content: center;
    }

    .search-input-wrapper {
      flex: 1;
      min-width: 280px;
    }

    .search-input {
      width: 100%;
      padding: 1rem 1.25rem;
      font-size: 0.9rem;
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .search-input:focus {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 3px rgba(77, 166, 255, 0.15);
    }

    .search-input::placeholder {
      color: var(--text-dim);
    }

    .search-btn {
      padding: 1rem 2rem;
      font-size: 1rem;
      font-weight: 600;
      background: var(--accent-gradient);
      border: none;
      border-radius: 12px;
      color: var(--bg-primary);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .search-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(77, 166, 255, 0.3);
    }

    .search-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .search-help {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: var(--text-dim);
    }

    .search-help a {
      color: var(--accent-blue);
      cursor: pointer;
      text-decoration: none;
    }

    .search-help a:hover {
      text-decoration: underline;
    }

    /* Loading spinner */
    .loading {
      display: none;
      justify-content: center;
      align-items: center;
      padding: 3rem;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 3px solid var(--border);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Results section */
    .results-section {
      display: none;
    }

    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .results-header h2 {
      font-size: 1.1rem;
      color: var(--text-secondary);
    }

    .results-header h2 span {
      color: var(--text-primary);
    }

    .last-updated {
      font-size: 0.8rem;
      color: var(--text-dim);
    }

    /* Portfolio Summary */
    .portfolio-summary-wrapper {
      background: var(--bg-card);
      border-radius: 16px;
      border: 1px solid var(--border);
      margin-bottom: 2rem;
      overflow: hidden;
    }

    .portfolio-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 1rem;
      padding: 1.5rem;
    }

    .portfolio-summary-wrapper .combined-chart-section {
      border-top: 1px solid var(--border);
    }

    .portfolio-action-buttons {
      display: flex;
      gap: 0;
    }

    .portfolio-action-buttons .validator-expand-btn {
      flex: 1;
      border-radius: 0;
      border: none;
      border-right: 1px solid var(--border);
      margin-top: 0;
    }

    .portfolio-action-buttons .validator-expand-btn:last-child {
      border-right: none;
    }

    .portfolio-summary-wrapper .validator-expand-btn {
      border-radius: 0;
      border: none;
      margin-top: 0;
    }

    .portfolio-summary-wrapper .validator-stake-section {
      border-radius: 0;
      margin-top: 0;
      border-top: 1px solid var(--border);
    }
    
    .portfolio-summary-wrapper .validator-chart-section {
      border-radius: 0;
      margin-top: 0;
    }

    .portfolio-stat {
      text-align: center;
      padding: 0.75rem;
    }

    .portfolio-stat-value {
      font-size: 1.4rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
    }

    .portfolio-stat-value.highlight {
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .portfolio-stat-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 0.4rem;
    }

    /* Validator card */
    .validator-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      transition: border-color 0.2s, background 0.2s;
      position: relative;
    }

    .validator-card:hover {
      border-color: var(--accent-blue);
      background: var(--bg-card-hover);
    }

    .validator-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.25rem;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .validator-name {
      font-size: 1.25rem;
      font-weight: 600;
    }

    .validator-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .validator-logo {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      object-fit: cover;
      flex-shrink: 0;
    }

    .validator-logo-placeholder {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--accent-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--bg-primary);
      flex-shrink: 0;
    }

    .validator-meta {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
    }

    .version-badge {
      font-size: 0.65rem;
      padding: 0.2rem 0.5rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }

    .version-badge.outdated {
      border-color: rgba(255, 193, 7, 0.5);
      color: #ffc107;
    }

    .version-update-warning {
      font-size: 0.6rem;
      color: #ffc107;
      margin-left: 0.4rem;
      cursor: help;
    }

    /* Performance Score Tooltip */
    .perf-score-wrapper {
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 8px;
      padding: 0.5rem !important;
      margin: -0.5rem;
    }
    
    .perf-score-wrapper:hover {
      background: var(--bg-secondary);
    }
    
    .perf-click-hint {
      font-size: 0.65rem;
      color: var(--text-dim);
      margin-top: 0.3rem;
      opacity: 0.7;
    }
    
    .perf-score-wrapper:hover .perf-click-hint {
      opacity: 1;
      color: var(--accent);
    }

    .perf-info-icon {
      cursor: pointer;
      font-size: 0.7rem;
      opacity: 0.8;
      transition: all 0.2s;
      margin-left: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: var(--accent);
      color: var(--bg-primary);
      border-radius: 50%;
      font-weight: bold;
      font-style: normal;
    }
    
    .perf-info-icon:hover {
      opacity: 1;
      transform: scale(1.1);
    }

    .perf-tooltip {
      position: absolute;
      bottom: calc(100% + 10px);
      right: 0;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      min-width: 280px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      pointer-events: none;
    }

    .perf-score-wrapper:hover .perf-tooltip {
      opacity: 1;
      visibility: visible;
    }

    .perf-tooltip-title {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-primary);
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .perf-tooltip-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.5rem;
    }

    .perf-tooltip-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .perf-tooltip-value {
      font-size: 0.8rem;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
    }

    .perf-tooltip-detail {
      font-size: 0.65rem;
      color: var(--text-muted);
      margin-left: 0.5rem;
      margin-bottom: 0.25rem;
    }

    .perf-tooltip-total {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.75rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--border);
      font-weight: 600;
      font-size: 0.9rem;
    }

    .score-good { color: var(--success); }
    .score-warning { color: var(--warning); }
    .score-orange { color: #ff9800; }
    .score-bad { color: var(--danger); }

    /* Expandable Chart Section */
    .validator-expand-btn {
      width: 100%;
      padding: 0.75rem;
      margin-top: 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 0.85rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .validator-action-buttons {
      display: flex;
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .validator-action-buttons .validator-expand-btn {
      margin-top: 0;
      flex: 1;
    }

    .validator-expand-btn:hover {
      background: var(--bg-card-hover);
      color: var(--text-primary);
      border-color: var(--accent-blue);
    }

    .validator-expand-btn .arrow {
      transition: transform 0.3s;
    }

    .validator-expand-btn.expanded {
      background: rgba(0, 212, 255, 0.1);
      border-color: rgba(0, 212, 255, 0.3);
      color: var(--accent-cyan);
    }

    .validator-expand-btn.expanded .arrow {
      transform: rotate(180deg);
    }

    .validator-chart-section {
      display: none;
      margin-top: 1rem;
      padding: 1.25rem;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .validator-chart-section.expanded {
      display: block;
    }

    .validator-stake-section {
      display: none;
      margin-top: 1rem;
      padding: 1.25rem;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .validator-stake-section.expanded {
      display: block;
    }

    .stake-section-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      gap: 0.75rem;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .stake-inline-content {
      width: 100%;
    }

    .stake-inline-pie-row {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 1rem;
    }

    .stake-inline-pie {
      flex-shrink: 0;
    }

    .stake-inline-stats {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .stake-inline-stat {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.75rem;
      background: var(--bg-card);
      border-radius: 8px;
    }

    .stake-inline-stat-label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .stake-inline-stat-value {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .stake-inline-earnings {
      background: rgba(0, 255, 163, 0.1);
      border: 1px solid rgba(0, 255, 163, 0.2);
      border-radius: 10px;
      padding: 1rem;
      margin-top: 1rem;
    }

    .stake-inline-apy-display {
      text-align: center;
      padding: 1rem;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 215, 0, 0.1));
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 8px;
    }

    .stake-inline-apy-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stake-inline-apy-value {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-gold));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1.2;
    }

    .stake-inline-apy-note {
      font-size: 0.7rem;
      color: var(--text-dim);
      margin-top: 0.25rem;
    }

    .stake-inline-apy-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.25rem;
    }

    .stake-apy-period-select {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 0.7rem;
      padding: 0.25rem 0.5rem;
      cursor: pointer;
      outline: none;
    }

    .stake-apy-period-select:hover {
      border-color: var(--accent-cyan);
    }

    .stake-apy-period-select:focus {
      border-color: var(--accent-cyan);
      box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
    }

    .stake-inline-earnings-title {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--success);
      margin-bottom: 0.75rem;
    }

    .stake-inline-earnings-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .stake-inline-earning {
      text-align: center;
      padding: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
    }

    .stake-inline-earning-value {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .stake-inline-earning-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .stake-inline-total {
      text-align: center;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(0, 255, 163, 0.2);
    }

    .stake-inline-delegators {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .stake-inline-delegators-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .stake-inline-delegators-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .stake-inline-delegators-count {
      font-size: 0.75rem;
      color: var(--text-secondary);
      background: var(--bg-card);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }

    .stake-inline-delegator {
      display: flex;
      justify-content: space-between;
      padding: 0.4rem 0.5rem;
      background: var(--bg-card);
      border-radius: 6px;
      margin-bottom: 0.35rem;
      font-size: 0.8rem;
    }

    .stake-inline-delegator-address {
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
    }

    .stake-inline-delegator-amount {
      font-weight: 500;
      color: var(--text-primary);
    }

    .stake-inline-note {
      font-size: 0.7rem;
      color: var(--text-dim);
      font-style: italic;
    }

    .stake-inline-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border);
    }

    .stake-manage-btn {
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.3);
      color: var(--accent-cyan);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .stake-manage-btn:hover {
      background: rgba(0, 212, 255, 0.2);
      border-color: rgba(0, 212, 255, 0.5);
      transform: translateY(-1px);
    }

    .stake-inline-warning {
      display: flex;
      gap: 0.5rem;
      align-items: flex-start;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 1rem;
      font-size: 0.75rem;
    }

    .stake-inline-warning-text {
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .stake-inline-warning-text strong {
      color: var(--accent-gold);
    }

    .stake-accounts-toggle {
      cursor: pointer;
      transition: background 0.2s;
    }

    .stake-accounts-toggle:hover {
      background: var(--bg-secondary);
    }

    .stake-accounts-toggle .accounts-arrow {
      font-size: 0.65rem;
      transition: transform 0.2s;
      display: inline-block;
      margin-left: 0.25rem;
    }

    .stake-accounts-toggle.expanded .accounts-arrow {
      transform: rotate(180deg);
    }

    .stake-accounts-list {
      display: none;
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      background: var(--bg-card);
      border-radius: 8px;
      border: 1px solid var(--border);
      overflow: hidden;
    }

    .stake-accounts-list.expanded {
      display: block;
    }

    .stake-accounts-list-inner {
      max-height: 200px;
      overflow-y: auto;
      padding: 0.5rem;
    }

    .stake-account-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.4rem 0.5rem;
      border-radius: 6px;
      margin-bottom: 0.35rem;
      font-size: 0.75rem;
      background: var(--bg-secondary);
    }

    .stake-account-item:last-child {
      margin-bottom: 0;
    }

    .stake-account-item.self {
      border-left: 3px solid var(--accent-cyan);
    }

    .stake-account-item.delegated {
      border-left: 3px solid var(--accent-gold);
    }

    .stake-account-left {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .stake-account-type-badge {
      font-size: 0.6rem;
      font-weight: 600;
      padding: 0.15rem 0.35rem;
      border-radius: 3px;
      text-transform: uppercase;
    }

    .stake-account-type-badge.self {
      background: rgba(0, 212, 255, 0.2);
      color: var(--accent-cyan);
    }

    .stake-account-type-badge.delegated {
      background: rgba(240, 185, 11, 0.2);
      color: var(--accent-gold);
    }

    .stake-account-address {
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
    }

    .stake-account-amount {
      font-weight: 500;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    @media (max-width: 600px) {
      .stake-inline-pie-row {
        flex-direction: column;
      }
    }

    .chart-toggle-container {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .chart-toggle-btn {
      flex: 1;
      padding: 0.5rem 1rem;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .chart-toggle-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--text-primary);
    }

    .chart-toggle-btn.active {
      background: var(--accent-gradient);
      border-color: transparent;
      color: white;
    }

    .chart-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 1rem;
      color: var(--text-secondary);
      font-size: 0.8rem;
    }

    .loading-spinner-small {
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--accent-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .chart-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .chart-subtitle {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .chart-container {
      height: 200px;
      position: relative;
    }

    .chart-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .chart-stat {
      text-align: center;
    }

    .chart-stat-value {
      font-size: 1.1rem;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-cyan);
    }

    .chart-stat-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      margin-top: 0.25rem;
    }

    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
      justify-content: center;
    }

    .chart-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .chart-legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    .combined-chart-section {
      /* No margin when inside wrapper */
    }

    /* X1 Network Styles */
    .map-section {
      margin-bottom: 2rem;
    }

    .map-container {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 0;
      background: var(--bg-card);
      border-radius: 16px;
      border: 2px solid var(--border);
      overflow: hidden;
    }

    .map-wrapper {
      position: relative;
      height: 450px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
    }

    #validatorMap {
      height: 100%;
      width: 100%;
      background: #0a1525;
    }

    .leaflet-container {
      background: #0a1525;
    }

    /* Convert grey map tiles to blue */
    .leaflet-tile-pane {
      filter: sepia(100%) hue-rotate(180deg) saturate(300%) brightness(60%);
    }

    .map-hint {
      position: absolute;
      bottom: 0.75rem;
      left: 0.75rem;
      z-index: 1000;
      font-size: 0.7rem;
      color: var(--text-dim);
      background: rgba(10, 11, 15, 0.7);
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      pointer-events: none;
    }

    .map-sidebar {
      padding: 1.25rem;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      overflow-y: auto;
      max-height: 450px;
    }

    /* Custom scrollbar for sidebar */
    .map-sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .map-sidebar::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 3px;
    }

    .map-sidebar::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    .map-sidebar::-webkit-scrollbar-thumb:hover {
      background: var(--accent-blue);
    }

    .map-sidebar-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .sidebar-x1-logo {
      font-size: 1rem;
      font-weight: 700;
    }

    .country-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .country-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.6rem 0.75rem;
      background: var(--bg-card);
      border-radius: 8px;
      border: 1px solid var(--border);
      transition: all 0.2s;
    }

    .country-item:hover {
      border-color: var(--accent-blue);
      background: var(--bg-card-hover);
    }

    .country-info {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .country-flag {
      font-size: 1.25rem;
    }

    .country-name {
      font-size: 0.8rem;
      color: var(--text-primary);
    }

    .country-count {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-blue);
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg-primary);
      padding: 0.25rem 0.6rem;
      border-radius: 6px;
    }

    /* Leader Schedule Section */
    .leader-schedule-section {
      display: flex;
      gap: 1.5rem;
      margin-top: 1.5rem;
      padding: 1.25rem 1.5rem;
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border);
      align-items: center;
    }

    .leader-current {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .leader-current-header {
      font-size: 0.7rem;
      color: var(--text-secondary);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }

    .leader-logo {
      width: 52px;
      height: 52px;
      min-width: 52px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1.25rem;
      color: var(--bg-primary);
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
    }

    .leader-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .leader-info {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .leader-name {
      font-weight: 600;
      font-size: 1.1rem;
      color: var(--text-primary);
    }

    .leader-vote {
      font-size: 0.7rem;
      color: var(--text-dim);
      font-family: 'JetBrains Mono', monospace;
      cursor: pointer;
    }

    .leader-vote:hover {
      color: var(--accent-cyan);
    }

    .leader-slot-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
    }

    .leader-slot {
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }

    .leader-slot span {
      color: var(--accent-cyan);
      font-weight: 600;
    }

    .leader-block {
      font-size: 0.7rem;
      color: var(--bg-primary);
      background: var(--accent-cyan);
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-weight: 600;
    }

    .slot-dots {
      display: flex;
      gap: 3px;
      align-items: center;
    }

    .slot-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent-cyan);
      opacity: 0.3;
      animation: slotPulse 1.6s ease-in-out infinite;
    }

    .slot-dot:nth-child(1) { animation-delay: 0s; }
    .slot-dot:nth-child(2) { animation-delay: 0.4s; }
    .slot-dot:nth-child(3) { animation-delay: 0.8s; }
    .slot-dot:nth-child(4) { animation-delay: 1.2s; }

    @keyframes slotPulse {
      0%, 100% { opacity: 0.2; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1.1); }
    }

    .leader-divider {
      width: 1px;
      height: 50px;
      background: var(--border);
    }

    .leader-next {
      flex: 1;
      min-width: 0;
    }

    .leader-next-header {
      font-size: 0.7rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .leader-next-list {
      display: flex;
      gap: 0.4rem;
      overflow-x: auto;
      padding-bottom: 0.25rem;
    }

    .leader-next-list::-webkit-scrollbar {
      height: 4px;
    }

    .leader-next-list::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 2px;
    }

    .leader-next-list::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .leader-next-item {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      background: var(--bg-secondary);
      padding: 0.35rem 0.5rem;
      border-radius: 6px;
      border: 1px solid var(--border);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .leader-next-logo {
      width: 22px;
      height: 22px;
      min-width: 22px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 0.65rem;
      color: var(--bg-primary);
      overflow: hidden;
    }

    .leader-next-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .leader-next-name {
      font-size: 0.75rem;
      color: var(--text-primary);
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .map-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1000;
    }

    .map-loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }

    .map-loading-text {
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    /* Custom Leaflet styles for dark theme */
    .leaflet-container {
      background: var(--bg-secondary);
      font-family: 'Space Grotesk', sans-serif;
    }

    .leaflet-popup-content-wrapper {
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    .leaflet-popup-tip {
      background: var(--bg-card);
    }

    .leaflet-popup-content {
      margin: 0.75rem 1rem;
    }

    .popup-validator-name {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
    }

    .popup-validator-location {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    /* Hide Leaflet zoom controls */
    .leaflet-control-zoom {
      display: none !important;
    }

    /* Hide Leaflet attribution or make it subtle */
    .leaflet-control-attribution {
      background: transparent !important;
      color: var(--text-dim) !important;
      font-size: 9px !important;
    }

    .leaflet-control-attribution a {
      color: var(--text-dim) !important;
    }

    /* Clean dot marker */
    .glow-dot {
      width: 7px;
      height: 7px;
      background: #00d4ff;
      border-radius: 50%;
    }

    /* Mobile responsive for map */
    @media (max-width: 900px) {
      .map-container {
        grid-template-columns: 1fr;
      }

      .map-wrapper {
        height: 350px;
      }

      .map-sidebar {
        border-left: none;
        border-top: 1px solid var(--border);
        max-height: 250px;
      }

      .leader-schedule-section {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
        padding: 1rem;
      }

      .leader-divider {
        width: 100%;
        height: 1px;
      }

      .leader-next {
        width: 100%;
      }

      .leader-logo {
        width: 44px;
        height: 44px;
        min-width: 44px;
        font-size: 1rem;
      }

      .leader-name {
        font-size: 1rem;
      }
    }

    .validator-rank {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-left: 0.5rem;
    }

    .tier-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: 600;
      margin-left: 0.5rem;
      vertical-align: middle;
    }

    .tier-badge.elite {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
      border: 1px solid rgba(255, 215, 0, 0.5);
      color: #ffd700;
    }

    .tier-badge.excellent {
      background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(169, 169, 169, 0.2));
      border: 1px solid rgba(192, 192, 192, 0.5);
      color: #c0c0c0;
    }

    .tier-badge.great {
      background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(184, 115, 51, 0.2));
      border: 1px solid rgba(205, 127, 50, 0.5);
      color: #cd7f32;
    }

    .validator-address {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-dim);
      margin-top: 0.25rem;
      word-break: break-all;
    }

    .copy-address-btn {
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.3);
      color: var(--accent-cyan);
      cursor: pointer;
      padding: 0.2rem 0.35rem;
      margin-left: 0.5rem;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      vertical-align: middle;
    }

    .copy-address-btn:hover {
      color: var(--text-primary);
      background: rgba(0, 212, 255, 0.2);
      border-color: var(--accent-cyan);
    }

    .copy-address-btn.copied {
      color: var(--success);
      background: rgba(0, 255, 163, 0.1);
      border-color: var(--success);
    }

    .validator-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .manage-validator-btn-wrapper {
      margin-left: auto;
      margin-right: 1rem;
    }

    .manage-validator-btn {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 500;
      border: 1px solid var(--accent-blue);
      background: rgba(77, 166, 255, 0.1);
      color: var(--accent-blue);
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .manage-validator-btn:hover {
      background: var(--accent-gradient);
      color: #000;
      border-color: transparent;
      box-shadow: 0 4px 15px rgba(77, 166, 255, 0.3);
    }

    .status-badge {
      padding: 0.4rem 0.8rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .status-active {
      background: rgba(0, 230, 118, 0.15);
      color: var(--success);
    }

    .status-delinquent {
      background: rgba(255, 82, 82, 0.15);
      color: var(--danger);
    }

    .add-btn, .remove-btn, .compare-btn {
      padding: 0.4rem 0.8rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .add-btn {
      background: rgba(77, 166, 255, 0.15);
      color: var(--accent-blue);
    }

    .add-btn:hover {
      background: rgba(77, 166, 255, 0.3);
    }

    .remove-btn {
      background: rgba(255, 82, 82, 0.15);
      color: var(--danger);
    }

    .remove-btn:hover {
      background: rgba(255, 82, 82, 0.3);
    }

    .compare-btn {
      background: rgba(77, 166, 255, 0.15);
      color: var(--accent-blue);
    }

    .compare-btn:hover {
      background: rgba(77, 166, 255, 0.3);
    }

    /* Stats grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
    }

    .stat-item {
      background: var(--bg-secondary);
      padding: 1rem;
      border-radius: 10px;
    }

    .stat-item.clickable-stat {
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
    }

    .stat-item.clickable-stat:hover {
      background: var(--bg-card);
      transform: translateY(-2px);
    }

    .stat-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.4rem;
      min-height: 2.2em;
      line-height: 1.1;
    }

    .stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
    }

    .stat-value.accent {
      color: var(--accent-cyan);
    }

    .stat-value.success {
      color: var(--success);
    }

    .stat-value.warning {
      color: var(--warning);
    }

    .stat-value.orange {
      color: #ff9800;
    }

    .stat-value.danger {
      color: var(--danger);
    }

    .stat-subtext {
      font-size: 0.65rem;
      color: var(--text-dim);
      margin-top: 0.2rem;
    }

    .stat-change {
      font-size: 0.7rem;
      margin-top: 0.25rem;
      font-weight: 500;
    }

    /* Performance score bar */
    .perf-bar-container {
      margin-top: 0.5rem;
    }

    .perf-bar {
      height: 4px;
      background: var(--bg-primary);
      border-radius: 2px;
      overflow: hidden;
    }

    .perf-bar-fill {
      height: 100%;
      background: var(--accent-gradient);
      border-radius: 2px;
      transition: width 0.5s ease;
    }

    /* Error state */
    .error-message {
      display: none;
      background: rgba(255, 82, 82, 0.1);
      border: 1px solid var(--danger);
      border-radius: 12px;
      padding: 1.5rem;
      text-align: center;
      color: var(--danger);
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
    }

    .empty-state-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }

    .empty-state h3 {
      margin-bottom: 0.5rem;
      color: var(--text-primary);
    }

    .empty-state p {
      font-size: 0.9rem;
      margin-bottom: 1.5rem;
    }

    .empty-state-btn {
      padding: 0.75rem 1.5rem;
      background: var(--accent-gradient);
      border: none;
      border-radius: 10px;
      color: var(--bg-primary);
      font-weight: 600;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
    }

    /* Validators list modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 100;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }

    .modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 600px;
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      padding: 1.25rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      font-size: 1.1rem;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.5rem;
      line-height: 1;
    }

    .modal-close:hover {
      color: var(--text-primary);
    }

    .modal-search {
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border);
    }

    .modal-search input {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 0.9rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      outline: none;
      font-family: 'Space Grotesk', sans-serif;
    }

    .modal-search input:focus {
      border-color: var(--accent-blue);
    }

    .modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 0.75rem;
    }

    .validator-list-count {
      padding: 0.5rem 1rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border);
    }

    .validator-load-more {
      padding: 0.75rem;
      text-align: center;
      border-top: 1px solid var(--border);
    }

    .load-more-btn {
      padding: 0.6rem 2rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--accent-cyan);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .load-more-btn:hover {
      background: rgba(0, 229, 255, 0.1);
      border-color: var(--accent-cyan);
    }

    /* Ask Claude Button */
    .ask-claude-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      width: 100%;
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      background: linear-gradient(135deg, #d97706 0%, #f59e0b 100%);
      border: none;
      border-radius: 8px;
      color: #000;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .ask-claude-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
    }
    
    .ask-claude-btn svg {
      width: 18px;
      height: 18px;
    }
    
    .ask-claude-divider {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 1.25rem 0 0.75rem 0;
    }
    
    .ask-claude-divider::before,
    .ask-claude-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
    }
    
    .ask-claude-divider span {
      color: var(--text-dim);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Performance Explainer Modal */
    .perf-explainer-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }
    
    .perf-explainer-content {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 650px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .perf-explainer-header {
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      background: var(--bg-card);
      z-index: 1;
    }
    
    .perf-explainer-header h3 {
      font-size: 1.2rem;
      color: var(--text-primary);
      margin: 0;
    }
    
    .perf-explainer-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      line-height: 1;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .perf-explainer-close:hover {
      color: var(--text-primary);
      background: var(--bg-secondary);
    }
    
    .perf-explainer-body {
      padding: 1.5rem;
    }
    
    .perf-metric-item {
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--border);
    }
    
    .perf-metric-item:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }
    
    .perf-metric-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .perf-metric-name {
      font-weight: 600;
      font-size: 1rem;
      color: var(--text-primary);
    }
    
    .perf-metric-weight {
      background: var(--accent-gradient);
      color: var(--bg-primary);
      padding: 0.25rem 0.6rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    .perf-metric-description {
      color: var(--text-secondary);
      font-size: 0.9rem;
      line-height: 1.5;
      margin-bottom: 0.75rem;
    }
    
    .perf-metric-scoring {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      font-size: 0.85rem;
    }
    
    .perf-metric-scoring-title {
      color: var(--text-dim);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.4rem;
    }
    
    .perf-metric-scoring-detail {
      color: var(--text-secondary);
    }
    
    /* Validator-specific breakdown */
    .perf-breakdown-section {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1.25rem;
      margin-bottom: 1rem;
    }
    
    .perf-breakdown-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
    }
    
    .perf-breakdown-identity {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .perf-breakdown-logo {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      object-fit: cover;
    }
    
    .perf-breakdown-logo-placeholder {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--accent-gradient);
      color: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 1rem;
    }
    
    .perf-breakdown-header h4 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1.1rem;
    }
    
    .perf-breakdown-total {
      font-size: 1.1rem;
      font-weight: 600;
    }
    
    .perf-breakdown-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
    }
    
    @media (max-width: 500px) {
      .perf-breakdown-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .perf-breakdown-item {
      display: flex;
      flex-direction: column;
      background: var(--bg-card);
      padding: 0.75rem;
      border-radius: 8px;
    }
    
    .perf-breakdown-label {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }
    
    .perf-breakdown-score {
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .perf-breakdown-detail {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }
    
    .perf-explainer-divider {
      height: 1px;
      background: var(--border);
      margin: 1.5rem 0;
    }

    .validator-list-item {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }

    .validator-list-item:hover {
      background: var(--bg-secondary);
    }

    .validator-list-item-logo {
      width: 36px;
      height: 36px;
      min-width: 36px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.9rem;
      color: var(--bg-primary);
      overflow: hidden;
    }

    .validator-list-item-logo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .validator-list-item-info {
      flex: 1;
      min-width: 0;
    }

    .validator-list-item-name {
      font-weight: 500;
      font-size: 0.9rem;
      margin-bottom: 0.2rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .validator-list-item-address {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-dim);
    }

    .validator-list-item-add {
      padding: 0.4rem 0.8rem;
      background: var(--accent-gradient);
      border: none;
      border-radius: 6px;
      color: var(--bg-primary);
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
    }

    .validator-list-item-add.added {
      background: var(--bg-secondary);
      color: var(--text-dim);
    }

    .loading-validators {
      text-align: center;
      padding: 2rem;
      color: var(--text-secondary);
    }

    /* Stake Breakdown Modal */
    .stake-breakdown-modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .stake-breakdown-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 3rem;
      gap: 1rem;
      color: var(--text-secondary);
    }

    .stake-breakdown-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .stake-breakdown-header-logo {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      object-fit: cover;
    }

    .stake-breakdown-header-placeholder {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--accent-gradient);
      color: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 1.25rem;
    }

    .stake-breakdown-header-info h3 {
      margin: 0 0 0.25rem 0;
      color: var(--text-primary);
      font-size: 1.1rem;
    }

    .stake-breakdown-header-info p {
      margin: 0;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .stake-pie-container {
      display: flex;
      justify-content: center;
      margin-bottom: 1.5rem;
    }

    .stake-pie-chart {
      position: relative;
      width: 240px;
      height: 240px;
    }

    .stake-pie-chart svg {
      transform: rotate(-90deg);
    }

    .stake-pie-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .stake-pie-center-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .stake-pie-center-label {
      font-size: 0.7rem;
      color: var(--text-dim);
      text-transform: uppercase;
    }

    .stake-breakdown-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .stake-stat-card {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1rem;
      text-align: center;
    }

    .stake-stat-card.self-stake {
      border-left: 3px solid var(--accent-cyan);
    }

    .stake-stat-card.delegated {
      border-left: 3px solid var(--accent-gold);
    }

    .stake-stat-icon {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }

    .stake-stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .stake-stat-label {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
      margin-top: 0.25rem;
    }

    .stake-stat-percent {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }

    .stake-delegators-section {
      border-top: 1px solid var(--border);
      padding-top: 1rem;
    }

    .stake-delegators-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .stake-delegators-header h4 {
      margin: 0;
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    .stake-delegators-count {
      font-size: 0.8rem;
      color: var(--text-secondary);
      background: var(--bg-secondary);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .stake-delegators-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .stake-delegator-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: var(--bg-secondary);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      font-size: 0.8rem;
    }

    .stake-delegator-address {
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
    }

    .stake-delegator-amount {
      color: var(--text-primary);
      font-weight: 500;
    }

    .stake-apy-section {
      background: rgba(0, 255, 163, 0.1);
      border: 1px solid rgba(0, 255, 163, 0.3);
      border-radius: 12px;
      padding: 1rem;
      margin-top: 1rem;
    }

    .stake-apy-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--success);
      margin-bottom: 0.75rem;
    }

    .stake-apy-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .stake-apy-item {
      text-align: center;
    }

    .stake-apy-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .stake-apy-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .stake-cache-note {
      font-size: 0.7rem;
      color: var(--text-dim);
      text-align: center;
      margin-top: 1rem;
      font-style: italic;
    }

    .stake-zero-commission-warning {
      display: flex;
      gap: 0.75rem;
      align-items: flex-start;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }

    .stake-warning-icon {
      font-size: 1.25rem;
      flex-shrink: 0;
    }

    .stake-warning-text {
      font-size: 0.8rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .stake-warning-text strong {
      color: var(--accent-gold);
      display: block;
      margin-bottom: 0.25rem;
    }

    /* Stake Selection Modal */
    .stake-selection-modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 700px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .stake-selection-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 3rem;
      gap: 1rem;
      color: var(--text-secondary);
    }

    .stake-selection-intro {
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1.5rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .stake-selection-intro strong {
      color: var(--accent-cyan);
    }

    .stake-selection-summary {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .stake-selection-summary-item {
      background: var(--bg-secondary);
      border-radius: 10px;
      padding: 1rem;
      text-align: center;
    }

    .stake-selection-summary-value {
      font-size: 1.25rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      margin-bottom: 0.25rem;
    }

    .stake-selection-summary-value.self {
      color: var(--accent-cyan);
    }

    .stake-selection-summary-value.delegated {
      color: var(--accent-gold);
    }

    .stake-selection-summary-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .stake-selection-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .stake-selection-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .stake-selection-item:hover {
      border-color: var(--accent-cyan);
    }

    .stake-selection-item.selected {
      border-color: var(--accent-cyan);
      background: rgba(0, 212, 255, 0.1);
    }

    .stake-selection-checkbox {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s;
    }

    .stake-selection-item.selected .stake-selection-checkbox {
      background: var(--accent-cyan);
      border-color: var(--accent-cyan);
    }

    .stake-selection-checkbox svg {
      width: 12px;
      height: 12px;
      color: var(--bg-primary);
      opacity: 0;
      transition: opacity 0.2s;
    }

    .stake-selection-item.selected .stake-selection-checkbox svg {
      opacity: 1;
    }

    .stake-selection-info {
      flex: 1;
      min-width: 0;
    }

    .stake-selection-address {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .stake-selection-details {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .stake-selection-amount {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      font-size: 1rem;
      color: var(--text-primary);
      flex-shrink: 0;
    }

    .stake-selection-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }

    .stake-selection-btn {
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .stake-selection-btn.secondary {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-primary);
    }

    .stake-selection-btn.secondary:hover {
      background: var(--bg-card);
    }

    .stake-selection-btn.primary {
      background: var(--accent-cyan);
      border: none;
      color: var(--bg-primary);
    }

    .stake-selection-btn.primary:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    /* Manage Validator Modal */
    .manage-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 900px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .manage-modal-header {
      padding: 1.25rem 1.5rem;
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .manage-header-left {
      display: flex;
      align-items: center;
      gap: 1.25rem;
    }

    .manage-back-btn {
      padding: 0.5rem 0.75rem;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: all 0.2s;
    }

    .manage-back-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .manage-validator-identity {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .manage-validator-logo {
      width: 42px;
      height: 42px;
      border-radius: 10px;
      background: var(--accent-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1.1rem;
      color: #000;
    }

    .manage-validator-identity h2 {
      font-size: 1.1rem;
      color: var(--text-primary);
      margin-bottom: 0.15rem;
    }

    .manage-validator-name {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }

    .manage-validator-address-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
    }

    .manage-validator-address {
      font-size: 0.7rem;
      color: var(--accent-cyan);
      font-family: 'JetBrains Mono', monospace;
      word-break: break-all;
    }

    .copy-address-btn {
      padding: 0.25rem;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .copy-address-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
      background: rgba(77, 166, 255, 0.1);
    }

    .copy-address-btn.copied {
      border-color: var(--success);
      color: var(--success);
      background: rgba(0, 230, 118, 0.1);
    }

    .manage-header-right {
      display: flex;
      align-items: center;
    }

    .wallet-connection {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .wallet-status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-dim);
    }

    .wallet-status-indicator.connected {
      background: var(--success);
    }

    .wallet-status-text {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }

    .wallet-status-text.connected {
      color: var(--success);
    }

    .connect-wallet-btn {
      padding: 0.5rem 1rem;
      background: var(--accent-gradient);
      border: none;
      color: #000;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: all 0.2s;
    }

    .connect-wallet-btn:hover {
      box-shadow: 0 4px 15px rgba(77, 166, 255, 0.3);
    }

    .disconnect-wallet-btn {
      padding: 0.5rem 0.75rem;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: all 0.2s;
    }

    .disconnect-wallet-btn:hover {
      border-color: var(--danger);
      color: var(--danger);
    }

    .manage-modal-body {
      padding: 1.25rem 1.5rem;
      overflow-y: auto;
      flex: 1;
    }

    .manage-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.25rem;
      margin-bottom: 1rem;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .section-header h3 {
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    .section-header-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .refresh-accounts-btn {
      padding: 0.4rem 0.8rem;
      background: rgba(77, 166, 255, 0.15);
      border: 1px solid var(--accent-blue);
      border-radius: 6px;
      color: var(--accent-blue);
      font-size: 0.75rem;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: all 0.2s;
    }

    .refresh-accounts-btn:hover {
      background: rgba(77, 166, 255, 0.25);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    /* Authority Badge */
    .authority-badge {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.35rem 0.75rem;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 500;
      background: rgba(90, 95, 104, 0.2);
      color: var(--text-dim);
    }

    .authority-badge.has-authority {
      background: rgba(0, 230, 118, 0.15);
      color: var(--success);
    }

    .authority-badge.no-authority {
      background: rgba(255, 82, 82, 0.15);
      color: var(--danger);
    }

    .authority-badge.partial-authority {
      background: rgba(255, 171, 0, 0.15);
      color: var(--warning);
    }

    .authority-badge.clickable {
      cursor: pointer;
      transition: all 0.2s;
    }

    .authority-badge.clickable:hover {
      background: rgba(77, 166, 255, 0.2);
      color: var(--accent-blue);
    }

    .authority-badges-container {
      display: flex;
      align-items: center;
    }

    .authority-badge-pair {
      display: flex;
      gap: 0.5rem;
    }

    .authority-badge-icon {
      font-size: 0.8rem;
    }

    .add-stake-btn {
      padding: 0.4rem 0.8rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-dim);
      font-size: 0.75rem;
      cursor: not-allowed;
      font-family: 'Space Grotesk', sans-serif;
      opacity: 0.6;
    }

    /* Accounts List */
    .accounts-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .account-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .account-row:hover {
      border-color: var(--accent-blue);
    }

    .account-row.selected {
      border-color: var(--accent-blue);
      background: rgba(77, 166, 255, 0.1);
    }

    .account-row-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .account-type-badge {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
    }

    /* VOTE - Purple (validator's special vote account) */
    .account-type-badge.vote {
      background: rgba(156, 39, 176, 0.2);
      color: #ce93d8;
    }

    /* Default STAKE - Green (active, earning) */
    .account-type-badge.stake {
      background: rgba(0, 230, 118, 0.2);
      color: var(--success);
    }

    /* STAKE Active - Green (healthy, earning rewards) */
    .account-type-badge.stake.active {
      background: rgba(0, 230, 118, 0.2);
      color: var(--success);
    }

    /* ACTIVATING - Cyan (coming online, positive progress) */
    .account-type-badge.stake.activating {
      background: rgba(0, 229, 255, 0.2);
      color: var(--accent-cyan);
    }

    /* DEACTIVATING - Orange (going offline, warning) */
    .account-type-badge.stake.deactivating {
      background: rgba(255, 152, 0, 0.2);
      color: #ff9800;
    }

    /* INACTIVE - Gray (dormant, not active) */
    .account-type-badge.stake.inactive {
      background: rgba(90, 95, 104, 0.2);
      color: var(--text-dim);
    }

    /* Authority indicator badges */
    .authority-badges {
      display: flex;
      gap: 0.35rem;
      margin-left: 0.5rem;
    }

    .auth-badge {
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-size: 0.6rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .auth-badge.has-auth {
      background: rgba(0, 230, 118, 0.2);
      color: #00e676;
    }

    .auth-badge.no-auth {
      background: rgba(244, 67, 54, 0.15);
      color: #e57373;
    }

    /* Authority info header */
    .authority-info-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .authority-info-btn {
      background: transparent;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 0.85rem;
      padding: 0.2rem;
      display: flex;
      align-items: center;
      transition: color 0.2s;
    }

    .authority-info-btn:hover {
      color: var(--accent-blue);
    }

    .authority-legend {
      display: none;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      font-size: 0.75rem;
    }

    .authority-legend.show {
      display: block;
    }

    .authority-legend-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }

    .authority-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.35rem;
      color: var(--text-secondary);
    }

    .authority-legend-item:last-child {
      margin-bottom: 0;
    }

    /* NEW - Yellow/Gold (action, create new) */
    .account-type-badge.create-stake {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
    }

    .account-address {
      font-size: 0.8rem;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
    }

    .account-select-btn {
      padding: 0.35rem 0.75rem;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 0.7rem;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: all 0.2s;
    }

    .account-select-btn.selected {
      background: var(--accent-gradient);
      border-color: transparent;
      color: #000;
      font-weight: 600;
    }

    .loading-text {
      text-align: center;
      padding: 1rem;
      color: var(--text-dim);
      font-size: 0.8rem;
    }

    /* Account Details Grid */
    .account-details-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
    }

    .detail-box {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
    }

    .detail-label {
      font-size: 0.7rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .detail-value {
      font-size: 1.25rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
    }

    .detail-value.accent {
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .detail-value.highlight {
      color: var(--success);
    }

    .detail-unit {
      font-size: 0.7rem;
      color: var(--text-dim);
      margin-top: 0.25rem;
    }

    .detail-address {
      font-size: 0.7rem;
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-cyan);
      word-break: break-all;
    }

    .detail-address.has-authority {
      color: var(--success);
    }

    .detail-address.no-authority {
      color: var(--text-dim);
    }

    .detail-address-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .authority-indicator {
      font-size: 0.65rem;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-weight: 600;
    }

    .authority-indicator.yours {
      background: rgba(0, 230, 118, 0.15);
      color: var(--success);
    }

    .authority-indicator.not-yours {
      background: rgba(255, 82, 82, 0.1);
      color: var(--text-dim);
    }

    .authority-status {
      margin-top: 0.5rem;
    }

    .authority-success {
      font-size: 0.7rem;
      color: var(--success);
    }

    /* Manage Actions Grid */
    .manage-actions-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
    }

    .manage-action-btn {
      padding: 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      transition: all 0.2s;
      text-align: left;
    }

    .manage-action-btn:hover {
      border-color: var(--accent-blue);
      background: rgba(77, 166, 255, 0.08);
    }

    .manage-action-btn.primary {
      background: rgba(77, 166, 255, 0.15);
      border-color: var(--accent-blue);
    }

    .manage-action-btn.primary:hover {
      background: rgba(77, 166, 255, 0.25);
    }

    .manage-action-btn .action-icon {
      font-size: 1.25rem;
      margin-top: 0.1rem;
    }

    .manage-action-btn .action-text {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .manage-action-btn .action-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .manage-action-btn .action-desc {
      font-size: 0.7rem;
      color: var(--text-dim);
    }

    .manage-action-btn.disabled {
      opacity: 0.45;
      cursor: not-allowed;
      background: var(--bg-primary);
      border-color: var(--border);
    }

    .manage-action-btn.disabled:hover {
      background: var(--bg-primary);
      border-color: var(--border);
    }

    .manage-action-btn.disabled .action-title {
      color: var(--text-secondary);
    }

    .manage-action-btn.disabled .action-icon {
      filter: grayscale(80%);
    }

    .manage-action-btn .action-lock {
      font-size: 0.65rem;
      margin-left: 0.35rem;
      opacity: 0.7;
    }

    /* Action Explainer Modal */
    .explainer-steps {
      margin: 1rem 0;
      padding-left: 0;
      list-style: none;
    }

    .explainer-steps li {
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      padding-left: 0.5rem;
      line-height: 1.5;
    }

    .explainer-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
      justify-content: flex-end;
    }

    .explainer-action-btn {
      background: var(--accent-gradient);
      color: white;
      border: none;
      padding: 0.75rem 1.25rem;
      border-radius: 8px;
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .explainer-action-btn:hover {
      opacity: 0.9;
    }

    .explainer-close-btn {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      padding: 0.75rem 1.25rem;
      border-radius: 8px;
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .explainer-close-btn:hover {
      border-color: var(--accent-blue);
    }

    /* Send XNT Modal */
    .send-modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 450px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .send-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .send-modal-header h2 {
      font-size: 1.1rem;
      color: var(--text-primary);
      margin: 0;
    }

    .send-modal-body {
      padding: 1.5rem;
      overflow-y: auto;
    }

    .send-section {
      margin-bottom: 1.25rem;
    }

    .send-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .send-destination {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
    }

    .destination-name {
      font-size: 0.95rem;
      color: var(--text-primary);
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .destination-address {
      font-size: 0.75rem;
      color: var(--accent-cyan);
      font-family: 'JetBrains Mono', monospace;
      word-break: break-all;
    }

    .destination-address-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .send-balance {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
    }

    .balance-amount {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .balance-unit {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .send-input-wrapper {
      display: flex;
      align-items: center;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem 1rem;
      transition: border-color 0.2s;
    }

    .send-input-wrapper:focus-within {
      border-color: var(--accent-blue);
    }

    .send-amount-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: 1.25rem;
      font-family: 'JetBrains Mono', monospace;
      outline: none;
      width: 100%;
    }

    .send-amount-input::placeholder {
      color: var(--text-dim);
    }

    .send-input-unit {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-left: 0.5rem;
    }

    .send-preset-buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .preset-btn {
      flex: 1;
      padding: 0.5rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .preset-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .preset-btn.max {
      background: rgba(77, 166, 255, 0.15);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .preset-btn.max:hover {
      background: rgba(77, 166, 255, 0.25);
    }

    .send-section.summary {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .summary-row:last-child {
      margin-bottom: 0;
    }

    .summary-row.total {
      padding-top: 0.5rem;
      border-top: 1px solid var(--border);
      font-weight: 600;
      color: var(--text-primary);
    }

    .balance-breakdown {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 0.75rem 1rem;
    }

    .breakdown-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 0.4rem;
    }

    .breakdown-row:last-child {
      margin-bottom: 0;
    }

    .breakdown-row.available {
      padding-top: 0.4rem;
      border-top: 1px solid var(--border);
      font-weight: 600;
      color: var(--success);
    }

    .status-note {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-left: 0.5rem;
    }

    .close-account-option {
      background: rgba(255, 152, 0, 0.1);
      border: 1px solid rgba(255, 152, 0, 0.3);
      border-radius: 8px;
      padding: 0.875rem 1rem;
    }

    .close-account-checkbox {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      position: relative;
      user-select: none;
    }

    .close-account-checkbox input {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      height: 0;
      width: 0;
    }

    .close-account-checkbox .checkmark {
      height: 20px;
      width: 20px;
      min-width: 20px;
      background: var(--bg-primary);
      border: 2px solid var(--border);
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .close-account-checkbox:hover .checkmark {
      border-color: var(--accent-cyan);
    }

    .close-account-checkbox input:checked ~ .checkmark {
      background: var(--warning);
      border-color: var(--warning);
    }

    .close-account-checkbox input:checked ~ .checkmark:after {
      content: "";
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--bg-primary);
      font-size: 0.85rem;
      font-weight: 700;
      height: 100%;
    }

    .close-account-label {
      font-weight: 500;
      color: var(--warning);
    }

    .close-account-note {
      margin-top: 0.5rem;
      margin-left: 2rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .undelegate-timeline {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 0.75rem 1rem;
    }

    .timeline-step {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .timeline-step:last-child {
      margin-bottom: 0;
    }

    .timeline-icon {
      font-size: 1rem;
      line-height: 1.4;
    }

    .timeline-text {
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .timeline-text strong {
      color: var(--text-primary);
    }

    .redelegate-search-container {
      position: relative;
      margin-bottom: 0.75rem;
    }

    .redelegate-search-input {
      width: 100%;
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 0.9rem;
      font-family: inherit;
    }

    .redelegate-search-input:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }

    .redelegate-search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-top: 0.25rem;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .redelegate-search-item {
      padding: 0.75rem 1rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
    }

    .redelegate-search-item:last-child {
      border-bottom: none;
    }

    .redelegate-search-item:hover {
      background: rgba(77, 166, 255, 0.1);
    }

    .redelegate-search-item-name {
      font-weight: 600;
      color: var(--text-primary);
    }

    .redelegate-search-item-address {
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }

    .redelegate-search-item-stake {
      font-size: 0.75rem;
      color: var(--accent-cyan);
      text-align: right;
    }

    .redelegate-no-results {
      padding: 1rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .clear-selection-btn {
      background: rgba(255, 82, 82, 0.2);
      border: none;
      color: var(--danger);
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }

    .clear-selection-btn:hover {
      background: rgba(255, 82, 82, 0.3);
    }

    .send-message {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-size: 0.85rem;
      margin-bottom: 1rem;
    }

    .send-message.error {
      background: rgba(255, 82, 82, 0.15);
      border: 1px solid var(--danger);
      color: var(--danger);
    }

    .send-message.success {
      background: rgba(0, 230, 118, 0.15);
      border: 1px solid var(--success);
      color: var(--success);
    }

    .send-message.info {
      background: rgba(77, 166, 255, 0.15);
      border: 1px solid var(--accent-blue);
      color: var(--accent-blue);
    }

    .send-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }

    .send-cancel-btn {
      flex: 1;
      padding: 0.875rem;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .send-cancel-btn:hover {
      border-color: var(--text-secondary);
      color: var(--text-primary);
    }

    .send-confirm-btn {
      flex: 2;
      padding: 0.875rem;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      border: none;
      border-radius: 8px;
      color: #000;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .send-confirm-btn:hover {
      box-shadow: 0 4px 15px rgba(77, 166, 255, 0.3);
    }

    .send-confirm-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    .authority-warning {
      display: flex;
      gap: 1rem;
      padding: 1rem;
      background: rgba(255, 82, 82, 0.1);
      border: 1px solid var(--danger);
      border-radius: 8px;
      margin-bottom: 1.25rem;
    }

    .warning-icon {
      font-size: 1.5rem;
      flex-shrink: 0;
    }

    .warning-text strong {
      color: var(--danger);
      font-size: 0.9rem;
    }

    .warning-text p {
      color: var(--text-secondary);
      font-size: 0.8rem;
      margin: 0.25rem 0 0 0;
      line-height: 1.4;
    }

    .send-address-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: 0.85rem;
      font-family: 'JetBrains Mono', monospace;
      outline: none;
      width: 100%;
    }

    .send-address-input::placeholder {
      color: var(--text-dim);
    }

    .balance-note,
    .address-note {
      font-size: 0.7rem;
      color: var(--text-dim);
      margin-top: 0.5rem;
    }

    .authority-type-selector {
      display: flex;
      gap: 0.75rem;
    }

    .authority-type-btn {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.875rem 1rem;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }

    .authority-type-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(0, 229, 255, 0.05);
    }

    .authority-type-btn.active {
      border-color: var(--accent-cyan);
      background: rgba(0, 229, 255, 0.1);
    }

    .authority-type-icon {
      font-size: 1.5rem;
    }

    .authority-type-text {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .authority-type-title {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.85rem;
    }

    .authority-type-desc {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .use-wallet-btn {
      margin-top: 0.5rem;
      padding: 0.4rem 0.75rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--accent-cyan);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .use-wallet-btn:hover {
      background: rgba(0, 229, 255, 0.1);
      border-color: var(--accent-cyan);
    }

    .danger-warning-box {
      background: rgba(255, 82, 82, 0.1);
      border: 2px solid var(--danger);
      border-radius: 12px;
      padding: 1.25rem;
      text-align: center;
    }

    .danger-icon {
      font-size: 3rem;
      margin-bottom: 0.5rem;
    }

    .danger-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--danger);
      margin-bottom: 1rem;
      letter-spacing: 0.5px;
    }

    .danger-text {
      font-size: 0.9rem;
      color: var(--text-primary);
      line-height: 1.5;
    }

    .danger-list {
      text-align: left;
      margin: 1rem 0;
      padding-left: 1.5rem;
      color: var(--text-primary);
    }

    .danger-list li {
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }

    .danger-list li strong {
      color: var(--danger);
    }

    .danger-btn:disabled {
      background: var(--bg-secondary) !important;
      color: var(--text-dim);
    }

    /* Commission Modal Styles */
    .commission-display {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      display: flex;
      align-items: baseline;
      gap: 0.25rem;
    }

    .commission-value {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .commission-percent {
      font-size: 1.25rem;
      color: var(--text-secondary);
    }

    .commission-input-wrapper {
      display: flex;
      align-items: center;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      transition: border-color 0.2s;
    }

    .commission-input-wrapper:focus-within {
      border-color: var(--accent-blue);
    }

    .commission-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: 1.5rem;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      outline: none;
      width: 100%;
      text-align: center;
    }

    .commission-input::placeholder {
      color: var(--text-dim);
    }

    .commission-input-unit {
      font-size: 1.25rem;
      color: var(--text-secondary);
      margin-left: 0.25rem;
    }

    .commission-info-box {
      display: flex;
      gap: 0.75rem;
      padding: 0.875rem 1rem;
      background: rgba(77, 166, 255, 0.1);
      border: 1px solid rgba(77, 166, 255, 0.3);
      border-radius: 8px;
      margin-bottom: 1.25rem;
    }

    .commission-info-box .info-icon {
      font-size: 1rem;
      flex-shrink: 0;
    }

    .commission-info-box .info-text {
      font-size: 0.8rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .authorities-info-box {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 0.75rem 1rem;
    }

    .authority-info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      margin-bottom: 0.4rem;
    }

    .authority-info-row:last-child {
      margin-bottom: 0;
    }

    .authority-info-label {
      color: var(--text-secondary);
    }

    .authority-info-value {
      color: var(--accent-cyan);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
    }

    /* General Info Box */
    .info-box {
      display: flex;
      gap: 0.75rem;
      padding: 0.875rem 1rem;
      background: rgba(77, 166, 255, 0.1);
      border: 1px solid rgba(77, 166, 255, 0.3);
      border-radius: 8px;
    }

    .info-box .info-icon {
      font-size: 1rem;
      flex-shrink: 0;
    }

    .info-box .info-text {
      font-size: 0.8rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .info-box .info-text p {
      margin: 0.25rem 0;
    }

    .info-box .info-text p:first-child {
      margin-top: 0;
    }

    /* Merge Stakes List */
    .merge-stakes-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-primary);
    }

    .merge-stake-item {
      display: flex;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      gap: 0.75rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .merge-stake-item:last-child {
      border-bottom: none;
    }

    .merge-stake-item:hover {
      background: var(--bg-secondary);
    }

    .merge-stake-item.selected {
      background: rgba(77, 166, 255, 0.1);
      border-color: rgba(77, 166, 255, 0.3);
    }

    .merge-stake-item.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .merge-stake-item.disabled:hover {
      background: transparent;
    }

    .merge-stake-checkbox {
      width: 18px;
      height: 18px;
      accent-color: var(--accent-cyan);
      cursor: pointer;
    }

    .merge-stake-checkbox:disabled {
      cursor: not-allowed;
    }

    .merge-stake-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .merge-stake-address {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--text-primary);
    }

    .merge-stake-details {
      font-size: 0.75rem;
      color: var(--text-secondary);
      display: flex;
      gap: 1rem;
    }

    .merge-stake-amount {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent-cyan);
      font-weight: 500;
    }

    .merge-stake-status {
      padding: 0.15rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .merge-stake-status.eligible {
      background: rgba(0, 230, 118, 0.15);
      color: var(--success);
    }

    .merge-stake-status.ineligible {
      background: rgba(255, 82, 82, 0.15);
      color: var(--danger);
    }

    .commission-epoch-warning {
      display: flex;
      gap: 0.75rem;
      padding: 0.875rem 1rem;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.4);
      border-radius: 8px;
      margin-bottom: 1.25rem;
    }

    .commission-epoch-warning .warning-icon {
      font-size: 1rem;
      flex-shrink: 0;
    }

    .commission-epoch-warning .warning-text strong {
      color: #ffc107;
      font-size: 0.85rem;
    }

    .commission-epoch-warning .warning-text p {
      color: var(--text-secondary);
      font-size: 0.75rem;
      margin: 0.25rem 0 0 0;
      line-height: 1.4;
    }

    /* Identity Modal Styles */
    .identity-modal {
      max-width: 500px;
    }

    .identity-modal code {
      background: var(--bg-primary);
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--accent-cyan);
    }

    .icon-preview-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .icon-preview-container img {
      max-width: 80px;
      max-height: 80px;
      border-radius: 8px;
    }

    /* Wallet Install Modal */
    .wallet-install-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 200;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }

    .wallet-install-content {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 2rem;
      max-width: 400px;
      width: 100%;
      text-align: center;
    }

    .wallet-install-content h3 {
      font-size: 1.2rem;
      margin-bottom: 0.75rem;
    }

    .wallet-install-content p {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 1.5rem;
    }

    .wallet-options {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .wallet-option {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-primary);
      text-decoration: none;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .wallet-option:hover {
      border-color: var(--accent-blue);
      background: rgba(77, 166, 255, 0.1);
    }

    .wallet-option-icon {
      font-size: 1.5rem;
    }

    .wallet-modal-close {
      padding: 0.6rem 1.5rem;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      border-radius: 8px;
      font-size: 0.85rem;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: all 0.2s;
    }

    .wallet-modal-close:hover {
      border-color: var(--text-secondary);
      color: var(--text-primary);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .manage-modal {
        max-height: 95vh;
        border-radius: 12px;
      }
      
      .manage-modal-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
        padding: 1rem;
      }

      .manage-header-right {
        width: 100%;
      }

      .wallet-connection {
        width: 100%;
        justify-content: space-between;
      }
      
      .manage-modal-body {
        padding: 1rem;
      }
      
      .account-details-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .manage-actions-grid {
        grid-template-columns: 1fr;
      }

      .account-address {
        font-size: 0.7rem;
      }
    }

    @media (max-width: 480px) {
      .account-details-grid {
        grid-template-columns: 1fr;
      }

      .manage-header-left {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }
    }

    /* Portfolio tab specific */
    .portfolio-actions {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 1.5rem;
    }

    .portfolio-actions button {
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .portfolio-actions button:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .portfolio-actions button.primary {
      background: var(--accent-gradient);
      border: none;
      color: var(--bg-primary);
    }

    /* Leaderboard Styles */
    .leaderboard-categories {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .leaderboard-cat-btn {
      padding: 0.7rem 1.4rem;
      border-radius: 25px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .leaderboard-cat-btn:hover {
      border-color: var(--accent-blue);
      color: var(--accent-blue);
      transform: translateY(-2px);
    }

    .leaderboard-cat-btn.active {
      background: var(--accent-gradient);
      border-color: transparent;
      color: var(--bg-primary);
      font-weight: 600;
    }

    .leaderboard-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .leaderboard-header {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .leaderboard-header h2 {
      font-size: 1.5rem;
      margin-bottom: 0.3rem;
    }

    .leaderboard-subtitle {
      color: var(--text-dim);
      font-size: 0.9rem;
    }

    .leaderboard-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem 1.25rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      transition: all 0.2s;
      cursor: pointer;
    }

    .leaderboard-item:hover {
      border-color: var(--accent-blue);
      transform: translateX(5px);
    }

    .leaderboard-item.gold {
      border-color: #ffd700;
      background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, var(--bg-secondary) 100%);
    }

    .leaderboard-item.silver {
      border-color: #c0c0c0;
      background: linear-gradient(135deg, rgba(192,192,192,0.1) 0%, var(--bg-secondary) 100%);
    }

    .leaderboard-item.bronze {
      border-color: #cd7f32;
      background: linear-gradient(135deg, rgba(205,127,50,0.1) 0%, var(--bg-secondary) 100%);
    }

    .leaderboard-rank {
      min-width: 50px;
      font-size: 1.5rem;
      font-weight: 700;
      text-align: center;
    }

    .leaderboard-rank.gold { color: #ffd700; }
    .leaderboard-rank.silver { color: #c0c0c0; }
    .leaderboard-rank.bronze { color: #cd7f32; }
    .leaderboard-rank.normal { color: var(--text-dim); font-size: 1.1rem; }

    .leaderboard-validator {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex: 1;
      min-width: 0;
    }

    .leaderboard-logo {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid var(--border);
      background: var(--bg-tertiary);
    }

    .leaderboard-logo-placeholder {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--accent-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 1rem;
      color: var(--bg-primary);
    }

    .leaderboard-name {
      font-weight: 600;
      font-size: 1rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .leaderboard-stats {
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }

    .leaderboard-stat {
      text-align: right;
      min-width: 80px;
    }

    .leaderboard-stat-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent-cyan);
    }

    .leaderboard-stat-value.highlight {
      color: var(--success);
    }

    /* Score colors need higher specificity to override default cyan */
    .leaderboard-stat-value.score-good { color: var(--success); }
    .leaderboard-stat-value.score-warning { color: var(--warning); }
    .leaderboard-stat-value.score-orange { color: #ff9800; }
    .leaderboard-stat-value.score-bad { color: var(--danger); }

    .leaderboard-stat-label {
      font-size: 0.7rem;
      color: var(--text-dim);
      text-transform: uppercase;
    }

    /* Newest validators grouped display */
    .newest-group {
      margin-bottom: 1.5rem;
    }

    .newest-group:last-child {
      margin-bottom: 0;
    }

    .newest-group-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .newest-item {
      border-left: 3px solid var(--accent-cyan);
    }

    .newest-badge {
      font-size: 1.2rem;
      min-width: 2rem;
      text-align: center;
    }

    @media (max-width: 768px) {
      .leaderboard-categories {
        gap: 0.5rem;
      }
      
      .leaderboard-cat-btn {
        padding: 0.5rem 1rem;
        font-size: 0.8rem;
      }
      
      .leaderboard-item {
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      
      .leaderboard-stats {
        width: 100%;
        justify-content: space-around;
        gap: 1rem;
      }
      
      .leaderboard-stat {
        text-align: center;
        min-width: auto;
      }
    }

    /* Compare Tool */
    .compare-container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .compare-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .compare-header h2 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .compare-subtitle {
      color: var(--text-secondary);
    }

    .compare-add-section {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: flex-start;
    }

    .compare-search-box {
      flex: 1;
      position: relative;
    }

    .compare-search-box input {
      width: 100%;
      padding: 0.875rem 1rem;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 1rem;
      font-family: inherit;
    }

    .compare-search-box input:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }

    .compare-search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 8px 8px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .compare-search-results.active {
      display: block;
    }

    .compare-search-result {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    .compare-search-result:hover {
      background: var(--bg-card-hover);
    }

    .compare-search-result-logo {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      object-fit: cover;
    }

    .compare-search-result-logo-placeholder {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .compare-search-result-info {
      flex: 1;
      min-width: 0;
    }

    .compare-search-result-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .compare-search-result-address {
      font-size: 0.75rem;
      color: var(--text-dim);
      font-family: 'JetBrains Mono', monospace;
    }

    .compare-browse-btn {
      padding: 0.875rem 1.25rem;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      cursor: pointer;
      font-family: inherit;
      font-size: 0.9rem;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .compare-browse-btn:hover {
      background: var(--bg-card-hover);
      border-color: var(--accent-cyan);
    }

    .compare-slots {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .compare-slot {
      background: var(--bg-card);
      border: 2px dashed var(--border);
      border-radius: 12px;
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .compare-slot.empty {
      cursor: pointer;
    }

    .compare-slot.empty:hover {
      border-color: var(--accent-cyan);
      background: var(--bg-card-hover);
    }

    .compare-slot.filled {
      border-style: solid;
      border-color: var(--border);
      padding: 1rem;
      flex-direction: column;
      position: relative;
    }

    .compare-slot-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      color: var(--text-dim);
    }

    .compare-slot-plus {
      font-size: 2rem;
      color: var(--accent-cyan);
    }

    .compare-slot-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
      margin-bottom: 0.5rem;
    }

    .compare-slot-logo {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
    }

    .compare-slot-logo-placeholder {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--accent-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }

    .compare-slot-name {
      flex: 1;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .compare-slot-remove {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: var(--danger);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .compare-slot.filled:hover .compare-slot-remove {
      opacity: 1;
    }

    .compare-slot-score {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .compare-slot-score-label {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
    }

    .compare-table-container {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .compare-clear-btn {
      float: right;
      background: transparent;
      border: 1px solid var(--danger);
      color: var(--danger);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      transition: all 0.2s;
      margin-bottom: 1rem;
    }

    .compare-clear-btn:hover {
      background: var(--danger);
      color: white;
    }

    .compare-table {
      width: 100%;
      clear: both;
    }

    .compare-row {
      display: grid;
      grid-template-columns: 180px repeat(var(--compare-cols, 4), 1fr);
      border-bottom: 1px solid var(--border);
    }

    .compare-row:last-child {
      border-bottom: none;
    }

    .compare-row-header {
      background: var(--bg-secondary);
      font-weight: 600;
    }

    .compare-cell {
      padding: 1rem;
      display: flex;
      align-items: center;
    }

    .compare-cell-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .compare-cell-value {
      justify-content: center;
      text-align: center;
      font-weight: 500;
    }

    .compare-cell-best {
      background: rgba(0, 230, 118, 0.1);
      color: var(--success);
    }

    .compare-empty-state {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--text-secondary);
    }

    .compare-empty-icon {
      font-size: 4rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }

    .compare-empty-state h3 {
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }

    @media (max-width: 900px) {
      .compare-slots {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .compare-add-section {
        flex-direction: column;
      }
      
      .compare-browse-btn {
        width: 100%;
      }
    }

    @media (max-width: 600px) {
      .compare-slots {
        grid-template-columns: 1fr;
      }
      
      .compare-row {
        grid-template-columns: 120px repeat(var(--compare-cols, 4), 1fr);
      }
      
      .compare-cell {
        padding: 0.75rem 0.5rem;
        font-size: 0.85rem;
      }
    }

    /* Calculators */
    .calculators-nav {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .calc-nav-btn {
      padding: 0.6rem 1.2rem;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text-secondary);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .calc-nav-btn:hover {
      border-color: var(--accent);
      color: var(--text-primary);
    }

    .calc-nav-btn.active {
      background: var(--accent-gradient);
      color: var(--bg-primary);
      border-color: transparent;
      font-weight: 600;
    }

    .calculator-panel {
      display: none;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
    }

    .calculator-panel.active {
      display: block;
    }

    .calc-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .calc-header h2 {
      margin: 0 0 0.5rem 0;
      font-size: 1.3rem;
    }

    .calc-subtitle {
      color: var(--text-secondary);
      margin: 0;
      font-size: 0.9rem;
    }

    .calc-body {
      display: grid;
      grid-template-columns: 1fr 1.5fr;
      gap: 2rem;
      padding: 1.5rem;
    }

    @media (max-width: 900px) {
      .calc-body {
        grid-template-columns: 1fr;
      }
    }

    .calc-inputs {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .calc-input-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .calc-input-group label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .calc-input-group input,
    .calc-input-group select {
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 1rem;
      font-family: 'Space Grotesk', sans-serif;
    }

    .calc-input-group input:focus,
    .calc-input-group select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .calc-input-hint {
      font-size: 0.75rem;
      color: var(--text-dim);
    }

    .calc-input-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .calc-input-row input {
      flex: 1;
    }

    .calc-input-row select {
      width: auto;
    }

    .calc-input-unit {
      color: var(--text-dim);
      font-size: 0.9rem;
    }

    .calc-results {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .calc-result-header {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 1.25rem;
      color: var(--text-primary);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .calc-toggle {
      display: flex;
      gap: 0.25rem;
      background: var(--bg-card);
      border-radius: 8px;
      padding: 0.25rem;
    }

    .calc-toggle-btn {
      padding: 0.4rem 0.75rem;
      background: transparent;
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Space Grotesk', sans-serif;
    }

    .calc-toggle-btn:hover {
      color: var(--text-primary);
    }

    .calc-toggle-btn.active {
      background: var(--accent-gradient);
      color: var(--bg-primary);
      font-weight: 600;
    }

    .calc-header-controls {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .calc-currency-toggle {
      display: flex;
      gap: 0.15rem;
      background: var(--bg-card);
      border-radius: 6px;
      padding: 0.2rem;
    }

    .calc-currency-btn {
      padding: 0.3rem 0.6rem;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
    }

    .calc-currency-btn:hover {
      color: var(--text-primary);
    }

    .calc-currency-btn.active {
      background: var(--accent-cyan);
      color: var(--bg-primary);
      font-weight: 600;
    }

    .calc-stake-type-toggle {
      display: flex;
      gap: 0.75rem;
    }

    .calc-stake-type-btn {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
      padding: 0.75rem;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
    }

    .calc-stake-type-btn:hover {
      border-color: var(--accent-blue);
      background: var(--bg-card);
    }

    .calc-stake-type-btn.active {
      border-color: var(--accent-cyan);
      background: rgba(0, 212, 255, 0.1);
    }

    .stake-type-icon {
      font-size: 1.25rem;
    }

    .stake-type-label {
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--text-primary);
    }

    .stake-type-desc {
      font-size: 0.7rem;
      color: var(--text-dim);
    }

    .calc-stake-type-btn.active .stake-type-label {
      color: var(--accent-cyan);
    }

    .calc-sim-header {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin: 1.5rem 0 1rem 0;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .calc-current-breakdown {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .calc-breakdown-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .calc-breakdown-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .calc-breakdown-item {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 0.75rem;
      text-align: center;
    }

    .calc-breakdown-item.self {
      border-left: 3px solid var(--accent-cyan);
    }

    .calc-breakdown-item.delegated {
      border-left: 3px solid var(--accent-gold);
    }

    .calc-breakdown-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .calc-breakdown-label {
      font-size: 0.7rem;
      color: var(--text-dim);
      text-transform: uppercase;
      margin-top: 0.25rem;
    }

    .calc-earnings-section {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .calc-earnings-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--success);
      margin-bottom: 0.75rem;
    }

    .calc-earnings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border);
    }

    .calc-earnings-row:last-child {
      border-bottom: none;
    }

    .calc-earnings-row.total {
      margin-top: 0.5rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--accent-cyan);
      border-bottom: none;
    }

    .calc-earnings-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .calc-earnings-value {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .calc-earnings-row.total .calc-earnings-value {
      font-size: 1.1rem;
      color: var(--success);
    }

    .calc-projection-section {
      background: rgba(0, 255, 163, 0.05);
      border: 1px solid rgba(0, 255, 163, 0.2);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .calc-projection-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .projection-period-toggle {
      display: flex;
      gap: 0.25rem;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.2rem;
    }

    .period-toggle-btn {
      padding: 0.3rem 0.75rem;
      font-size: 0.7rem;
      font-weight: 600;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      color: var(--text-secondary);
      transition: all 0.2s ease;
    }

    .period-toggle-btn:hover {
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.05);
    }

    .period-toggle-btn.active {
      background: var(--accent-cyan);
      color: var(--bg-dark);
    }

    .calc-projection-comparison {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 0.5rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    .calc-projection-box {
      text-align: center;
      padding: 0.75rem;
      background: var(--bg-card);
      border-radius: 8px;
    }

    .calc-projection-box.new {
      background: rgba(0, 255, 163, 0.1);
      border: 1px solid rgba(0, 255, 163, 0.3);
    }

    .calc-projection-arrow {
      font-size: 1.25rem;
      color: var(--text-dim);
    }

    .calc-projection-value {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .calc-projection-box.new .calc-projection-value {
      color: var(--success);
    }

    .calc-projection-label {
      font-size: 0.65rem;
      color: var(--text-dim);
      text-transform: uppercase;
      margin-top: 0.25rem;
    }

    .calc-apy-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: rgba(0, 212, 255, 0.15);
      color: var(--accent-cyan);
      padding: 0.35rem 0.65rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .calc-no-breakdown-note {
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-bottom: 1rem;
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
    }

    .calc-no-breakdown-note span:first-child {
      flex-shrink: 0;
    }

    .calc-result-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    @media (max-width: 500px) {
      .calc-result-grid {
        grid-template-columns: 1fr;
      }
    }

    .calc-result-item {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
    }

    .calc-result-item.highlight {
      background: linear-gradient(135deg, rgba(0, 255, 163, 0.1), rgba(0, 209, 255, 0.1));
      border: 1px solid rgba(0, 255, 163, 0.3);
    }

    .calc-result-value {
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .calc-result-item.highlight .calc-result-value {
      color: var(--success);
    }

    .calc-result-label {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .calc-result-summary {
      border-top: 1px solid var(--border);
      padding-top: 1rem;
    }

    .calc-summary-row {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      font-size: 0.9rem;
    }

    .calc-summary-row span:first-child {
      color: var(--text-secondary);
    }

    .calc-summary-row span:last-child {
      color: var(--text-primary);
      font-weight: 500;
    }

    .calc-summary-row.highlight {
      border-top: 1px solid var(--border);
      margin-top: 0.5rem;
      padding-top: 1rem;
    }

    .calc-summary-row.highlight span:last-child {
      color: var(--success);
      font-size: 1.1rem;
    }

    .calc-section-divider {
      height: 1px;
      background: var(--border);
      margin: 1.5rem 0;
    }

    .calc-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .calc-section-header.estimated {
      color: var(--text-secondary);
    }

    .calc-section-header.actual {
      color: var(--success);
    }

    .calc-section-badge {
      background: rgba(0, 255, 163, 0.15);
      color: var(--success);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .calc-actual-note {
      font-size: 0.75rem;
      color: var(--text-dim);
      margin-top: 0.75rem;
      text-align: center;
      font-style: italic;
    }

    .calc-new-stake-preview {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      color: var(--accent-cyan);
    }

    .calc-view-link {
      background: none;
      border: none;
      color: var(--accent-blue);
      cursor: pointer;
      font-size: 0.8rem;
      font-family: inherit;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .calc-view-link:hover {
      background: rgba(77, 166, 255, 0.2);
    }

    .calc-increase-box {
      background: rgba(0, 230, 118, 0.1);
      border: 1px solid rgba(0, 230, 118, 0.3);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .calc-increase-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .calc-increase-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--success);
      font-family: 'JetBrains Mono', monospace;
    }

    .calc-increase-percent {
      background: var(--success);
      color: var(--bg-primary);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .calc-comparison-note {
      margin-top: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg-card);
      border-radius: 6px;
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-align: center;
    }

    .calc-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      gap: 0.75rem;
      color: var(--text-dim);
    }

    /* Commission comparison */
    .commission-comparison {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .commission-row {
      display: grid;
      grid-template-columns: 80px 1fr 120px;
      gap: 1rem;
      align-items: center;
      padding: 0.75rem;
      background: var(--bg-card);
      border-radius: 8px;
    }

    .commission-row.highlight {
      background: linear-gradient(135deg, rgba(0, 255, 163, 0.1), rgba(0, 209, 255, 0.1));
      border: 1px solid rgba(0, 255, 163, 0.3);
    }

    .commission-rate {
      font-weight: 600;
      color: var(--text-primary);
    }

    .commission-bar {
      height: 8px;
      background: var(--bg-secondary);
      border-radius: 4px;
      overflow: hidden;
    }

    .commission-bar-fill {
      height: 100%;
      background: var(--accent-gradient);
      border-radius: 4px;
      transition: width 0.3s;
    }

    .commission-earnings {
      text-align: right;
      font-weight: 600;
      color: var(--success);
    }

    .commission-insight {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 1rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .commission-insight strong {
      color: var(--warning);
    }

    .commission-row.over-limit {
      border-left: 3px solid var(--warning);
    }

    .commission-row.max-allowed {
      border-left: 3px solid var(--success);
    }

    .commission-bar-fill.over-limit {
      background: var(--warning);
      opacity: 0.5;
    }

    .commission-bar-fill.actual {
      background: var(--success);
    }

    .commission-warning {
      display: flex;
      gap: 0.75rem;
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 8px;
    }

    .commission-warning-icon {
      font-size: 1.25rem;
      flex-shrink: 0;
    }

    .commission-warning-text {
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .commission-warning-text strong {
      color: var(--warning);
    }

    .commission-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      text-align: center;
      color: var(--text-dim);
    }

    .commission-empty-icon {
      font-size: 2.5rem;
      margin-bottom: 0.75rem;
      opacity: 0.5;
    }

    .commission-empty-text {
      font-size: 0.9rem;
      max-width: 250px;
      line-height: 1.5;
    }

    .calc-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      text-align: center;
      color: var(--text-dim);
    }

    .calc-empty-icon {
      font-size: 2.5rem;
      margin-bottom: 0.75rem;
      opacity: 0.5;
    }

    .calc-empty-text {
      font-size: 0.9rem;
      max-width: 280px;
      line-height: 1.5;
    }

    /* Compound growth */
    .compound-chart-container {
      height: 200px;
      margin-bottom: 1.5rem;
    }

    .compound-comparison {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 1rem;
    }

    .compound-vs {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .compound-vs-item {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
    }

    .compound-vs-label {
      color: var(--text-secondary);
    }

    .compound-vs-value {
      font-weight: 600;
      color: var(--text-primary);
    }

    .compound-vs-item.highlight {
      border-top: 1px solid var(--border);
      padding-top: 0.75rem;
      margin-top: 0.5rem;
    }

    .compound-vs-item.highlight .compound-vs-value {
      color: var(--success);
    }

    .compound-vs-value.bonus {
      color: var(--success);
      font-size: 1.1rem;
    }

    .calc-validator-apy-box {
      text-align: center;
      padding: 1rem;
      margin: 1rem 0;
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 215, 0, 0.1));
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 8px;
    }

    .calc-validator-apy-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .calc-validator-apy-value {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-gold));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1.2;
    }

    .calc-validator-apy-note {
      font-size: 0.7rem;
      color: var(--text-dim);
      margin-top: 0.25rem;
    }

    /* Unstaking timeline */
    .calc-network-status {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 0.5rem;
    }

    .calc-status-item {
      display: flex;
      justify-content: space-between;
      padding: 0.4rem 0;
      font-size: 0.9rem;
    }

    .calc-status-label {
      color: var(--text-secondary);
    }

    .calc-status-value {
      color: var(--text-primary);
      font-weight: 500;
    }

    .calc-refresh-btn {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 1rem;
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .calc-refresh-btn:hover {
      border-color: var(--accent);
      color: var(--text-primary);
    }

    .unstaking-timeline {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin-bottom: 1.5rem;
    }

    .timeline-step {
      display: flex;
      gap: 1rem;
      padding: 1rem 0;
      position: relative;
    }

    .timeline-step:not(:last-child)::after {
      content: '';
      position: absolute;
      left: 15px;
      top: 40px;
      bottom: 0;
      width: 2px;
      background: var(--border);
    }

    .timeline-step.active::after {
      background: var(--success);
    }

    .timeline-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg-card);
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
      z-index: 1;
    }

    .timeline-step.active .timeline-icon {
      border-color: var(--success);
      background: rgba(0, 255, 163, 0.1);
    }

    .timeline-step.completed .timeline-icon {
      border-color: var(--success);
      background: var(--success);
      color: var(--bg-primary);
    }

    .timeline-content {
      flex: 1;
    }

    .timeline-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .timeline-subtitle {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .timeline-date {
      font-size: 0.8rem;
      color: var(--text-dim);
      margin-top: 0.25rem;
    }

    .unstaking-summary {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
    }

    .unstaking-summary-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--success);
      margin-bottom: 0.25rem;
    }

    .unstaking-summary-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    /* Break-even */
    .breakeven-table {
      margin-top: 1.5rem;
    }

    .breakeven-table-header {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      color: var(--text-primary);
    }

    .breakeven-table-body {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .breakeven-row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 0.5rem;
      padding: 0.75rem;
      background: var(--bg-card);
      border-radius: 8px;
      font-size: 0.85rem;
    }

    .breakeven-row.header {
      background: transparent;
      color: var(--text-dim);
      font-weight: 500;
      padding: 0.5rem 0.75rem;
      text-transform: uppercase;
      font-size: 0.7rem;
      letter-spacing: 0.5px;
    }

    .breakeven-row.loss {
      border-left: 3px solid var(--danger);
    }

    .breakeven-row.profit {
      border-left: 3px solid var(--success);
    }

    .breakeven-row.breakeven {
      background: linear-gradient(135deg, rgba(0, 255, 163, 0.1), rgba(0, 209, 255, 0.1));
      border: 1px solid rgba(0, 255, 163, 0.3);
    }

    .breakeven-profit {
      font-weight: 600;
    }

    .breakeven-profit.positive {
      color: var(--success);
    }

    .breakeven-profit.negative {
      color: var(--danger);
    }

    .breakeven-status {
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 1.5rem;
      font-size: 0.95rem;
    }

    .breakeven-status.profit-status-positive {
      background: rgba(0, 255, 163, 0.1);
      border: 1px solid rgba(0, 255, 163, 0.3);
      color: var(--success);
    }

    .breakeven-status.profit-status-negative {
      background: rgba(255, 107, 107, 0.1);
      border: 1px solid rgba(255, 107, 107, 0.3);
      color: var(--danger);
    }

    .breakeven-price-box {
      background: linear-gradient(135deg, rgba(0, 209, 255, 0.1), rgba(0, 255, 163, 0.05));
      border: 1px solid rgba(0, 209, 255, 0.3);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
    }

    .breakeven-price-header {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .breakeven-price-content {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .breakeven-price-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
    }

    .breakeven-price-label {
      color: var(--text-secondary);
    }

    .breakeven-price-value {
      font-weight: 600;
      color: var(--text-primary);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .breakeven-price-value.highlight {
      color: var(--accent-cyan);
      font-size: 1rem;
    }

    .breakeven-price-value.positive {
      color: var(--success);
    }

    .breakeven-price-value.negative {
      color: var(--danger);
    }

    .breakeven-price-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 0.25rem 0;
    }

    .breakeven-status strong {
      color: var(--text-primary);
    }

    .breakeven-row.current {
      background: rgba(0, 209, 255, 0.1);
      border-left: 3px solid var(--accent-cyan);
    }

    .breakeven-note {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: var(--text-dim);
      padding: 0.75rem;
      background: var(--bg-card);
      border-radius: 8px;
    }

    @media (max-width: 768px) {
      .calculators-nav {
        gap: 0.5rem;
      }
      
      .calc-nav-btn {
        padding: 0.5rem 0.8rem;
        font-size: 0.75rem;
      }
      
      .calc-header {
        padding: 1rem;
      }
      
      .calc-header h2 {
        font-size: 1.1rem;
      }
      
      .calc-body {
        padding: 1rem;
        gap: 1.5rem;
      }
    }

    /* Footer */
    footer {
      position: relative;
      z-index: 10;
      text-align: center;
      padding: 1.5rem;
      border-top: 1px solid var(--border);
      color: var(--text-dim);
      font-size: 0.8rem;
    }

    footer a {
      color: var(--accent-blue);
      text-decoration: none;
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      header {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
        padding: 1rem;
      }

      .logo-subtitle {
        display: none;
      }

      .header-links {
        gap: 1rem;
        font-size: 0.85rem;
      }

      main {
        padding: 1rem;
      }

      .network-stats {
        padding: 0.75rem 0.5rem;
        gap: 0;
      }

      .network-stat {
        padding: 0.25rem 0.75rem;
      }

      .network-stat-value {
        font-size: 1rem;
      }

      .tabs {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        padding: 0;
      }

      .tab {
        padding: 0.6rem 1.25rem;
        font-size: 0.85rem;
        white-space: nowrap;
      }

      .search-section h1 {
        font-size: 1.5rem;
      }

      .search-input-wrapper {
        min-width: 100%;
      }

      .search-btn {
        width: 100%;
      }

      .portfolio-summary {
        grid-template-columns: repeat(2, 1fr);
        padding: 1rem;
      }

      .portfolio-stat {
        padding: 0.5rem;
      }

      .portfolio-stat-value {
        font-size: 1.1rem;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
      }

      .stat-item {
        padding: 0.75rem;
      }

      .stat-value {
        font-size: 1rem;
      }

      .validator-header {
        flex-direction: column;
      }

      .validator-name {
        font-size: 1.1rem;
      }

      .validator-logo, .validator-logo-placeholder {
        width: 40px;
        height: 40px;
        font-size: 1rem;
      }

      .validator-meta {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
      }

      .validator-address {
        font-size: 0.65rem;
      }

      .chart-stats {
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
      }

      .chart-stat-value {
        font-size: 0.9rem;
      }

      .results-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .portfolio-actions {
        flex-wrap: wrap;
      }
    }

    @media (max-width: 480px) {
      .network-stat {
        padding: 0.25rem 0.5rem;
      }

      .network-stat-value {
        font-size: 0.9rem;
      }

      .stats-grid {
        grid-template-columns: 1fr 1fr;
      }

      .portfolio-summary {
        grid-template-columns: 1fr 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- Disclaimer Modal - Must accept before using app -->
  <div class="disclaimer-modal-overlay" id="disclaimerModal">
    <div class="disclaimer-modal">
      <div class="disclaimer-modal-header">
        <h2> Terms of Use & Disclaimer</h2>
        <p>Please read carefully before using X1 Validator Headquarters</p>
      </div>
      
      <div class="disclaimer-modal-body">
        <div class="disclaimer-warning-box">
          <p>
            <span class="warning-icon"></span>
            <span>This software interacts with blockchain networks and cryptocurrency. Improper use can result in permanent, irreversible loss of funds. Proceed only if you understand and accept the risks.</span>
          </p>
        </div>

        <div class="disclaimer-section">
          <h3>1. No Warranty</h3>
          <p>This software is provided <strong>"AS IS"</strong> without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose, and noninfringement.</p>
        </div>

        <div class="disclaimer-section">
          <h3>2. Limitation of Liability</h3>
          <p>In no event shall the authors, contributors, or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the software or the use or other dealings in the software. This includes but is not limited to:</p>
          <ul>
            <li>Loss of funds, tokens, or cryptocurrency</li>
            <li>Loss of staking rewards or validator income</li>
            <li>Validator downtime, slashing, or deactivation</li>
            <li>Unauthorized access to accounts or wallets</li>
            <li>Any errors, bugs, or vulnerabilities in the software</li>
            <li>Actions taken based on information displayed by the software</li>
          </ul>
        </div>

        <div class="disclaimer-section">
          <h3>3. User Responsibility</h3>
          <p>By using this software, you acknowledge that:</p>
          <ul>
            <li>You are solely responsible for verifying all transaction details before signing</li>
            <li>You are solely responsible for safeguarding your wallet, keys, and credentials</li>
            <li>You understand how blockchain transactions, staking, and delegation work</li>
            <li>You will independently verify any information before acting on it</li>
            <li>You accept all risks associated with using this software</li>
          </ul>
        </div>

        <div class="disclaimer-section">
          <h3>4. Not Financial Advice</h3>
          <p>Nothing in this software constitutes financial, investment, legal, or tax advice. All staking decisions, validator selections, and fund management are solely your responsibility. Consult qualified professionals for financial guidance.</p>
        </div>

        <div class="disclaimer-section">
          <h3>5. Open Source Software</h3>
          <p>This is an open-source community project. The code is publicly available for review. No guarantees are made regarding security, accuracy, or continued maintenance and support.</p>
        </div>

        <div class="disclaimer-section">
          <h3>6. Third-Party Services</h3>
          <p>This software connects to third-party blockchain networks, RPC endpoints, and wallet providers. We are not responsible for the availability, security, or performance of these external services.</p>
        </div>

        <div class="disclaimer-section">
          <h3>7. No Data Collection</h3>
          <p>This software does not collect, store, or transmit your private keys, seed phrases, or passwords. All wallet interactions occur directly between your browser and your wallet provider.</p>
        </div>
      </div>

      <div class="disclaimer-modal-footer">
        <div class="disclaimer-checkbox-container">
          <input type="checkbox" id="disclaimerCheckbox" onchange="updateDisclaimerButton()">
          <label for="disclaimerCheckbox">I have read, understood, and agree to these terms. I acknowledge that I use this software entirely at my own risk.</label>
        </div>
        <button class="disclaimer-accept-btn" id="disclaimerAcceptBtn" disabled onclick="acceptDisclaimer()">
          Accept & Continue
        </button>
        <div class="disclaimer-version">Terms Version 1.0  Last Updated: December 31, 2024</div>
      </div>
    </div>
  </div>

  <div class="bg-pattern">
    <div class="bg-line bg-line-1"></div>
    <div class="bg-line bg-line-2"></div>
    <div class="bg-line bg-line-3"></div>
  </div>

  <header>
    <a href="#" class="logo" onclick="goToHome(); return false;">
      <span class="logo-x1"><span class="logo-x">X</span><span class="logo-1">1</span></span>
      <span class="logo-subtitle"><span class="logo-subtitle-validator">Validator</span> <span class="logo-subtitle-hq">Headquarters</span></span>
    </a>
    <div class="header-links">
      <a href="https://x1.xyz/" target="_blank">X1 Website</a>
      <a href="https://docs.x1.xyz/validating/create-a-read-only-node" target="_blank">Launch My Validator</a>
      <a href="https://github.com/ShakaVibe/X1-Validator-Dashboard" target="_blank">GitHub</a>
      
      <!-- Network Toggle -->
      <div class="network-toggle-container">
        <span class="network-toggle-label x1" id="x1Label">
          <span class="x1-logo-small"><span class="x-char">X</span><span class="one-char">1</span></span>
        </span>
        <button class="network-toggle" id="networkToggle" onclick="toggleNetwork()">
          <div class="network-toggle-slider"></div>
        </button>
        <span class="network-toggle-label solana inactive" id="solanaLabel">
          <svg class="solana-logo-small" viewBox="0 0 397.7 311.7">
            <path class="sol-bottom" d="M64.6 237.9c2.4-2.4 5.7-3.8 9.2-3.8h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1l62.7-62.7z"/>
            <path class="sol-top" d="M64.6 3.8C67.1 1.4 70.4 0 73.8 0h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1L64.6 3.8z"/>
            <path class="sol-middle" d="M333.1 120.1c-2.4-2.4-5.7-3.8-9.2-3.8H6.5c-5.8 0-8.7 7-4.6 11.1l62.7 62.7c2.4 2.4 5.7 3.8 9.2 3.8h317.4c5.8 0 8.7-7 4.6-11.1l-62.7-62.7z"/>
          </svg>
        </span>
      </div>
    </div>
  </header>

  <main>
    <!-- Network Stats -->
    <div class="network-stats" id="networkStats">
      <div class="network-stat">
        <div class="network-stat-value" id="totalValidators">--</div>
        <div class="network-stat-label">Validators</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="totalStake">--</div>
        <div class="network-stat-label">Total Stake</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="totalSupply">--</div>
        <div class="network-stat-label">Total Supply</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="currentEpoch">--</div>
        <div class="network-stat-label">Epoch</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="currentSlot">--</div>
        <div class="network-stat-label">Slot</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="networkTps">--</div>
        <div class="network-stat-label">TPS</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="nakamotoCoef">--</div>
        <div class="network-stat-label">Nakamoto</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="activeValidators">--</div>
        <div class="network-stat-label">Active</div>
      </div>
      <div class="network-stat">
        <div class="network-stat-value" id="delinquentValidators">--</div>
        <div class="network-stat-label">Delinquent</div>
      </div>
    </div>

    <!-- Epoch Progress -->
    <div class="epoch-progress" id="epochProgress">
      <span class="epoch-progress-label">Epoch</span>
      <div class="epoch-progress-bar">
        <div class="epoch-progress-fill" id="epochProgressFill" style="width: 0%"></div>
      </div>
      <span class="epoch-progress-percent" id="epochPercent">0%</span>
      <span class="epoch-progress-time" id="epochTimeRemaining">--</span>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab active" onclick="switchTab('map')"><span class="x1-logo-btn"><span style="color: #ffffff;">X</span><span style="color: var(--accent-blue);">1</span></span> Network</button>
      <button class="tab" onclick="switchTab('lookup')"> Validator Lookup</button>
      <button class="tab" onclick="switchTab('portfolio')"> My Data Center <span id="portfolioCount"></span></button>
      <button class="tab" onclick="switchTab('leaderboard')"> Leaderboards</button>
      <button class="tab" onclick="switchTab('compare')"> Compare <span id="compareCount"></span></button>
      <button class="tab" onclick="switchTab('calculators')"> Calculators</button>
    </div>

    <!-- X1 Network Tab -->
    <div class="tab-content active" id="mapTab">
      <div class="map-section">
        <div class="map-container">
          <div class="map-wrapper">
            <div class="map-loading" id="mapLoading">
              <div class="map-loading-spinner"></div>
              <div class="map-loading-text">Loading validator locations...</div>
            </div>
            <div id="validatorMap"></div>
            <div class="map-hint">Scroll to zoom  Drag to pan</div>
          </div>
          <div class="map-sidebar">
            <div class="map-sidebar-title">
              <span class="sidebar-x1-logo"><span style="color: #fff;">X</span><span style="color: var(--accent-blue);">1</span></span>
              Validators by Country
            </div>
            <div class="country-list" id="countryList">
              <div class="map-loading-text" style="text-align: center; padding: 2rem;">Loading...</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Leader Schedule Section -->
      <div class="leader-schedule-section">
        <div class="leader-current">
          <div class="leader-logo" id="currentLeaderLogo">?</div>
          <div class="leader-info">
            <div class="leader-current-header">Current Leader</div>
            <div class="leader-name" id="currentLeaderName">Loading...</div>
            <div class="leader-vote" id="currentLeaderVote"></div>
            <div class="leader-slot-row">
              <div class="leader-slot">Slot <span id="currentLeaderSlot">--</span></div>
              <div class="leader-block" id="currentLeaderBlock">Block 1 of 4</div>
              <div class="slot-dots">
                <div class="slot-dot"></div>
                <div class="slot-dot"></div>
                <div class="slot-dot"></div>
                <div class="slot-dot"></div>
              </div>
            </div>
          </div>
        </div>
        <div class="leader-divider"></div>
        <div class="leader-next">
          <div class="leader-next-header">Next Leaders</div>
          <div class="leader-next-list" id="nextLeadersList">
            <div class="leader-next-item">Loading...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Lookup Tab -->
    <div class="tab-content" id="lookupTab">
      <section class="search-section">
        <h1>Validator <span>Lookup</span></h1>
        <p>Search by validator name or enter a Vote Account ID</p>
        
        <div class="search-container">
          <div class="search-input-wrapper">
            <input 
              type="text" 
              class="search-input" 
              id="searchInput" 
              placeholder="Search by name or Vote Account ID..."
              autocomplete="off"
              oninput="handleSearchInput()"
            >
          </div>
          <button class="search-btn" id="searchBtn" onclick="performSearch()">
            Search
          </button>
        </div>
        
        <p class="search-help">
          <a onclick="openValidatorList()">Browse all validators</a> to find and add to your Data Center
        </p>
      </section>

      <div class="loading" id="loading">
        <div class="spinner"></div>
      </div>

      <div class="error-message" id="errorMessage">
        <p>No validators found. Try searching by name or check the Vote Account ID.</p>
      </div>

      <section class="results-section" id="resultsSection">
        <div class="results-header">
          <h2>Found <span id="resultCount">0</span> validator(s)</h2>
          <span class="last-updated" id="lastUpdated">Last updated: --</span>
        </div>

        <div id="validatorResults"></div>
      </section>
    </div>

    <!-- Portfolio Tab -->
    <div class="tab-content" id="portfolioTab">
      <section class="search-section">
        <h1>My Data <span>Center</span></h1>
        <p>Track all your validators in one place</p>
      </section>

      <div class="portfolio-actions">
        <button class="primary" onclick="openValidatorList()">+ Add Validator</button>
        <button onclick="refreshPortfolio()"> Refresh</button>
        <button onclick="clearPortfolio()">Clear All</button>
      </div>

      <div class="loading" id="portfolioLoading" style="display: none;">
        <div class="spinner"></div>
      </div>

      <div class="empty-state" id="emptyPortfolio">
        <div class="empty-state-icon"></div>
        <h3>No validators yet</h3>
        <p>Add validators to your Data Center to track their performance</p>
        <button class="empty-state-btn" onclick="openValidatorList()">Browse Validators</button>
      </div>

      <section class="results-section" id="portfolioResults" style="display: none;">
        <div class="results-header">
          <h2>Tracking <span id="portfolioResultCount">0</span> validator(s)</h2>
          <span class="last-updated" id="portfolioUpdated">Last updated: --</span>
        </div>

        <div class="portfolio-summary-wrapper">
          <div class="portfolio-summary" id="portfolioSummary">
            <div class="portfolio-stat">
              <div class="portfolio-stat-value highlight" id="totalPortfolioStake">0.00</div>
              <div class="portfolio-stat-label">Total Stake (XNT)</div>
            </div>
            <div class="portfolio-stat">
              <div class="portfolio-stat-value" id="totalPortfolioRewards" style="color: var(--warning);">0.00</div>
              <div class="portfolio-stat-label">Total Rewards (XNT)</div>
            </div>
            <div class="portfolio-stat">
              <div class="portfolio-stat-value" id="portfolioLastEpochRewards" style="color: var(--success);">0.00</div>
              <div class="portfolio-stat-label">Rewards Last Epoch (XNT)</div>
            </div>
            <div class="portfolio-stat">
              <div class="portfolio-stat-value" id="avgPortfolioPerf">0.0</div>
              <div class="portfolio-stat-label">Avg Performance (7D)</div>
            </div>
            <div class="portfolio-stat">
              <div class="portfolio-stat-value" id="activePortfolioCount" style="color: var(--accent-cyan);">0/0</div>
              <div class="portfolio-stat-label">Active</div>
            </div>
          </div>

          <!-- Combined Portfolio Chart - inside same box -->
          <div class="combined-chart-section" id="combinedChartSection">
            <div class="portfolio-action-buttons">
              <button class="validator-expand-btn stake-details-btn" onclick="toggleCombinedStakeDetails(this)">
                <span>Combined Stake Details</span>
                <span class="arrow"></span>
              </button>
              <button class="validator-expand-btn" onclick="toggleCombinedChart(this)">
                <span>View Combined Earnings Trend</span>
                <span class="arrow"></span>
              </button>
            </div>
            
            <div class="validator-stake-section" id="combinedStakeContainer">
              <div class="stake-section-loading">
                <div class="loading-spinner-small"></div>
                <span>Loading stake breakdown for all validators...</span>
              </div>
            </div>
            
            <div class="validator-chart-section" id="combinedChartContainer">
              <div class="chart-toggle-container">
                <button class="chart-toggle-btn active" onclick="switchCombinedChartType('xnt', this)" data-type="xnt">XNT Rewards</button>
                <button class="chart-toggle-btn" onclick="switchCombinedChartType('credits', this)" data-type="credits">Epoch Credits</button>
              </div>
              <div class="chart-header">
                <div>
                  <div class="chart-title" id="combinedChart-title">Combined XNT Rewards Trend</div>
                  <div class="chart-subtitle" id="combinedChart-subtitle">XNT earned per completed epoch for all validators</div>
                </div>
              </div>
              <div class="chart-container" style="height: 280px;">
                <canvas id="combinedChart"></canvas>
              </div>
              <div class="chart-legend" id="combinedChartLegend"></div>
              <div class="chart-loading" id="combinedChart-loading" style="display: none;">
                <div class="loading-spinner-small"></div>
                <span>Loading XNT rewards data for all validators...</span>
              </div>
            </div>
          </div>
        </div>

        <div id="portfolioValidatorResults"></div>
      </section>
    </div>

    <!-- Leaderboards Tab -->
    <div class="tab-content" id="leaderboardTab">
      <section class="search-section">
        <h1> Leader<span>boards</span></h1>
        <p>Top performing validators on the X1 Network</p>
      </section>

      <div class="leaderboard-categories">
        <button class="leaderboard-cat-btn active" onclick="switchLeaderboard('performance')"> Top Performance</button>
        <button class="leaderboard-cat-btn" onclick="switchLeaderboard('stake')"> Most Stake</button>
        <button class="leaderboard-cat-btn" onclick="switchLeaderboard('commission')"> Lowest Commission</button>
        <button class="leaderboard-cat-btn" onclick="switchLeaderboard('efficient')"> Most Efficient</button>
        <button class="leaderboard-cat-btn" onclick="switchLeaderboard('reliable')"> Most Reliable</button>
        <button class="leaderboard-cat-btn" onclick="switchLeaderboard('newest')"> Newest Validators</button>
      </div>

      <div class="loading" id="leaderboardLoading" style="display: none;">
        <div class="spinner"></div>
      </div>

      <div class="leaderboard-container" id="leaderboardContainer">
        <div class="leaderboard-header" id="leaderboardHeader">
          <h2> Top Performance Score</h2>
          <p class="leaderboard-subtitle">Validators ranked by 7-day performance score</p>
        </div>
        <div class="leaderboard-list" id="leaderboardList">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>

    <!-- Compare Tab -->
    <div class="tab-content" id="compareTab">
      <div class="compare-container">
        <div class="compare-header">
          <h2> Validator <span class="text-gradient">Comparison</span></h2>
          <p class="compare-subtitle">Compare up to 4 validators side-by-side</p>
        </div>

        <!-- Add Validator Section -->
        <div class="compare-add-section">
          <div class="compare-search-box">
            <input type="text" id="compareSearchInput" placeholder="Search for a validator by name or address..." oninput="handleCompareSearch()">
            <div class="compare-search-results" id="compareSearchResults"></div>
          </div>
          <button class="compare-browse-btn" onclick="openCompareValidatorList()"> Browse All Validators</button>
        </div>

        <!-- Selected Validators for Comparison -->
        <div class="compare-slots" id="compareSlots">
          <div class="compare-slot empty" id="compareSlot0" onclick="focusCompareSearch()">
            <div class="compare-slot-empty">
              <span class="compare-slot-plus">+</span>
              <span>Add Validator</span>
            </div>
          </div>
          <div class="compare-slot empty" id="compareSlot1" onclick="focusCompareSearch()">
            <div class="compare-slot-empty">
              <span class="compare-slot-plus">+</span>
              <span>Add Validator</span>
            </div>
          </div>
          <div class="compare-slot empty" id="compareSlot2" onclick="focusCompareSearch()">
            <div class="compare-slot-empty">
              <span class="compare-slot-plus">+</span>
              <span>Add Validator</span>
            </div>
          </div>
          <div class="compare-slot empty" id="compareSlot3" onclick="focusCompareSearch()">
            <div class="compare-slot-empty">
              <span class="compare-slot-plus">+</span>
              <span>Add Validator</span>
            </div>
          </div>
        </div>

        <!-- Comparison Table -->
        <div class="compare-table-container" id="compareTableContainer" style="display: none;">
          <button class="compare-clear-btn" onclick="clearComparison()"> Clear All</button>
          <div class="compare-table" id="compareTable">
            <!-- Populated by JS -->
          </div>
        </div>

        <!-- Empty State -->
        <div class="compare-empty-state" id="compareEmptyState">
          <div class="compare-empty-icon"></div>
          <h3>Select Validators to Compare</h3>
          <p>Search for validators above or browse the full list to add up to 4 validators for side-by-side comparison.</p>
        </div>
      </div>
    </div>

    <!-- Calculators Tab -->
    <div class="tab-content" id="calculatorsTab">
      <div class="calculators-nav">
        <button class="calc-nav-btn active" onclick="switchCalculator('staking')"> Staking Rewards</button>
        <button class="calc-nav-btn" onclick="switchCalculator('compound')"> Compound Growth</button>
        <button class="calc-nav-btn" onclick="switchCalculator('unstaking')"> Unstaking Timeline</button>
        <button class="calc-nav-btn" onclick="switchCalculator('breakeven')"> Break-Even</button>
      </div>

      <!-- Staking Rewards Calculator -->
      <div class="calculator-panel active" id="calcStaking">
        <div class="calc-header">
          <h2> Staking Rewards Calculator</h2>
          <p class="calc-subtitle">Calculate accurate rewards based on real stake breakdown data</p>
        </div>
        <div class="calc-body">
          <div class="calc-inputs">
            <div class="calc-input-group">
              <label>Select Your Validator</label>
              <select id="stakingValidator" onchange="onStakingValidatorChange()">
                <option value="">-- Select from your Data Center --</option>
                <option value="custom"> Custom / New Validator</option>
              </select>
              <div class="calc-input-hint" id="stakingCurrentStake">Select a validator or use custom mode</div>
            </div>
            <div class="calc-input-group" id="stakingApyGroup" style="display: none;">
              <label>Estimated APY (%)</label>
              <input type="number" id="stakingApy" placeholder="e.g. 8" value="8" min="0" max="100" step="0.1" oninput="renderStakingResults()">
              <div class="calc-input-hint">Estimated annual percentage yield for your validator</div>
            </div>
            <div class="calc-input-group" id="stakingCustomSelfGroup" style="display: none;">
              <label>Self-Stake (XNT)</label>
              <input type="text" id="stakingCustomSelf" placeholder="Your own stake" oninput="formatStakingInput(this); renderStakingResults()">
              <div class="calc-input-hint">XNT you stake yourself (earns 100% rewards)</div>
            </div>
            <div class="calc-input-group" id="stakingCustomDelegatedGroup" style="display: none;">
              <label>Delegated Stake (XNT)</label>
              <input type="text" id="stakingCustomDelegated" placeholder="Stake from delegators" oninput="formatStakingInput(this); renderStakingResults()">
              <div class="calc-input-hint">XNT delegated to you by others (you earn commission)</div>
            </div>
            <div class="calc-input-group" id="stakingCustomCommGroup" style="display: none;">
              <label>Commission Rate (%)</label>
              <input type="number" id="stakingCustomComm" placeholder="e.g. 10" value="10" min="0" max="100" step="1" oninput="renderStakingResults()">
              <div class="calc-input-hint">Your validator's commission rate</div>
            </div>
            
            <!-- Simulation inputs - shown when validator selected -->
            <div id="stakingSimInputs" style="display: none;">
              <div class="calc-sim-header"> Simulate Growth</div>
              <div class="calc-input-group">
                <label>Add Self-Stake (XNT)</label>
                <input type="text" id="stakingAddSelf" placeholder="0" oninput="formatStakingInput(this); renderStakingResults()">
                <div class="calc-input-hint">Additional XNT you'll add as self-stake (earns 100% rewards)</div>
              </div>
              <div class="calc-input-group">
                <label>Add Delegation (XNT)</label>
                <input type="text" id="stakingAddDelegation" placeholder="0" oninput="formatStakingInput(this); renderStakingResults()">
                <div class="calc-input-hint">Additional delegation you expect to receive (earns commission)</div>
              </div>
            </div>
            
            <div class="calc-input-group">
              <label>XNT Price (USD)</label>
              <input type="number" id="stakingPrice" placeholder="1.00" value="1.00" min="0" step="0.01" oninput="renderStakingResults()">
              <div class="calc-input-hint">Current price of XNT in USD</div>
            </div>
          </div>
          <div class="calc-results" id="stakingResults">
            <div class="calc-result-header">
              <span id="stakingResultsTitle">Rewards Calculator</span>
              <div class="calc-header-controls">
                <div class="calc-currency-toggle" id="stakingCurrencyToggle" style="display: none;">
                  <button class="calc-currency-btn active" onclick="toggleStakingCurrency('xnt', this)">XNT</button>
                  <button class="calc-currency-btn" onclick="toggleStakingCurrency('usd', this)">USD</button>
                </div>
              </div>
            </div>
            <div id="stakingResultsContent">
              <div class="calc-empty-state">
                <div class="calc-empty-icon"></div>
                <div class="calc-empty-text">Select a validator to see current earnings and simulate growth</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Compound Growth Calculator -->
      <div class="calculator-panel" id="calcCompound">
        <div class="calc-header">
          <h2> Compound Growth Calculator</h2>
          <p class="calc-subtitle">See how compounding frequency affects your growth over time</p>
        </div>
        <div class="calc-body">
          <div class="calc-inputs">
            <div class="calc-input-group">
              <label>Select Validator or Enter Custom</label>
              <select id="compoundValidator" onchange="onCompoundValidatorChange()">
                <option value="">-- Select from your Data Center --</option>
                <option value="custom"> Custom Values</option>
              </select>
              <div class="calc-input-hint" id="compoundValidatorHint">Select a validator or choose custom values</div>
            </div>
            <div class="calc-input-group" id="compoundInitialGroup" style="display: none;">
              <label>Initial Stake (XNT)</label>
              <input type="text" id="compoundInitial" placeholder="Enter amount" value="10,000" oninput="formatCompoundInput(this); calculateCompoundGrowth()">
            </div>
            <div class="calc-input-group" id="compoundAPYGroup" style="display: none;">
              <label>Annual APY (%)</label>
              <input type="number" id="compoundAPY" placeholder="APY %" value="8" min="0" max="100" step="0.1" oninput="calculateCompoundGrowth()">
              <div class="calc-input-hint">Estimated network APY</div>
            </div>
            <div class="calc-input-group">
              <label>Compounding Frequency</label>
              <select id="compoundFrequency" onchange="calculateCompoundGrowth()">
                <option value="365">Daily</option>
                <option value="52">Weekly</option>
                <option value="26">Bi-weekly</option>
                <option value="12" selected>Monthly</option>
                <option value="4">Quarterly</option>
                <option value="1">Yearly</option>
              </select>
              <div class="calc-input-hint">How often you restake rewards</div>
            </div>
            <div class="calc-input-group">
              <label>Time Period</label>
              <select id="compoundYears" onchange="calculateCompoundGrowth()">
                <option value="1">1 year</option>
                <option value="2">2 years</option>
                <option value="3" selected>3 years</option>
                <option value="5">5 years</option>
                <option value="10">10 years</option>
                <option value="20">20 years</option>
              </select>
            </div>
          </div>
          <div class="calc-results" id="compoundResults">
            <div class="calc-result-header">Growth Projection</div>
            <div id="compoundResultsContent">
              <div class="calc-empty-state">
                <div class="calc-empty-icon"></div>
                <div class="calc-empty-text">Select a validator or choose "Custom Values" to see earnings</div>
              </div>
            </div>
            <div id="compoundChartContainer" style="display: none; margin-top: 1rem; height: 250px;">
              <canvas id="compoundChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Unstaking Timeline Calculator -->
      <div class="calculator-panel" id="calcUnstaking">
        <div class="calc-header">
          <h2> Unstaking Timeline Calculator</h2>
          <p class="calc-subtitle">Know exactly when your unstaked funds become available</p>
        </div>
        <div class="calc-body">
          <div class="calc-inputs">
            <div class="calc-input-group">
              <label>Current Network Status</label>
              <div class="calc-network-status" id="unstakingNetworkStatus">
                <div class="calc-status-item">
                  <span class="calc-status-label">Current Epoch:</span>
                  <span class="calc-status-value" id="unstakingCurrentEpoch">Loading...</span>
                </div>
                <div class="calc-status-item">
                  <span class="calc-status-label">Epoch Progress:</span>
                  <span class="calc-status-value" id="unstakingEpochProgress">--</span>
                </div>
                <div class="calc-status-item">
                  <span class="calc-status-label">Est. Time Remaining:</span>
                  <span class="calc-status-value" id="unstakingTimeRemaining">--</span>
                </div>
              </div>
              <button class="calc-refresh-btn" onclick="refreshEpochInfo()"> Refresh</button>
            </div>
            <div class="calc-input-group">
              <label>When will you initiate unstaking?</label>
              <select id="unstakingWhen" onchange="calculateUnstakingTimeline()">
                <option value="now">Right now</option>
                <option value="next">Next epoch</option>
                <option value="custom">Specific epoch...</option>
              </select>
              <input type="number" id="unstakingCustomEpoch" placeholder="Enter epoch number" style="display: none; margin-top: 0.5rem;" oninput="calculateUnstakingTimeline()">
            </div>
          </div>
          <div class="calc-results">
            <div class="calc-result-header">Unstaking Timeline</div>
            <div class="unstaking-timeline" id="unstakingTimeline">
              <!-- Visual timeline populated by JS -->
            </div>
            <div class="unstaking-summary" id="unstakingSummary">
              <!-- Summary populated by JS -->
            </div>
          </div>
        </div>
      </div>

      <!-- Break-Even Calculator -->
      <div class="calculator-panel" id="calcBreakeven">
        <div class="calc-header">
          <h2> Validator Break-Even Calculator</h2>
          <p class="calc-subtitle">Compare your actual earnings against operating costs</p>
        </div>
        <div class="calc-body">
          <div class="calc-inputs">
            <div class="calc-input-group">
              <label>Select Your Validator</label>
              <select id="breakevenValidator" onchange="onBreakevenValidatorChange()">
                <option value="">-- Select from your Data Center --</option>
              </select>
              <div class="calc-input-hint" id="breakevenValidatorHint">Select a validator to see profitability</div>
            </div>
            <div class="calc-input-group">
              <label>Operating Costs</label>
              <div class="calc-input-row">
                <input type="number" id="breakevenCost" placeholder="Amount" value="100" min="0" oninput="calculateBreakeven()">
                <select id="breakevenCurrency" onchange="calculateBreakeven()">
                  <option value="usd">USD</option>
                  <option value="xnt">XNT</option>
                </select>
                <select id="breakevenPeriod" onchange="calculateBreakeven()">
                  <option value="monthly">/ month</option>
                  <option value="yearly">/ year</option>
                </select>
              </div>
              <div class="calc-input-hint">Include server, bandwidth, maintenance, etc.</div>
            </div>
            <div class="calc-input-group" id="breakevenPriceGroup">
              <label>Current XNT Price (USD)</label>
              <input type="number" id="breakevenPrice" placeholder="Price" value="1.00" min="0" step="0.01" oninput="calculateBreakeven()">
            </div>
          </div>
          <div class="calc-results" id="breakevenResults">
            <div class="calc-result-header">
              <span>Break-Even Analysis</span>
              <div class="calc-toggle" id="breakevenToggle">
                <button class="calc-toggle-btn active" onclick="toggleBreakevenView('monthly', this)">Monthly</button>
                <button class="calc-toggle-btn" onclick="toggleBreakevenView('yearly', this)">Yearly</button>
              </div>
            </div>
            <div id="breakevenResultsContent">
              <div class="calc-empty-state">
                <div class="calc-empty-icon"></div>
                <div class="calc-empty-text">Select a validator to see profitability analysis</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Footer Disclaimer -->
  <footer style="text-align: center; padding: 1.5rem; margin-top: 2rem; border-top: 1px solid var(--border); font-size: 0.75rem; color: var(--text-dim); line-height: 1.6;">
    <p style="margin: 0 auto; max-width: 900px;">
      <strong style="color: var(--text-secondary);">Disclaimer:</strong> This software is provided "AS IS" without warranty. 
      The authors are not liable for any losses or damages. You are solely responsible for verifying all transactions. 
      Not financial advice. Use at your own risk.
      <a href="#" onclick="showDisclaimerModal(); return false;" style="color: var(--accent-blue); margin-left: 0.5rem;">View Full Terms</a>
    </p>
  </footer>

  <!-- Validators list modal -->
  <div class="modal-overlay" id="validatorModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Browse Validators</h3>
        <button class="modal-close" onclick="closeValidatorList()">&times;</button>
      </div>
      <div class="modal-search">
        <input 
          type="text" 
          id="validatorSearchInput" 
          placeholder="Search by name or address..."
          oninput="filterValidatorList()"
        >
      </div>
      <div class="validator-list-count" id="validatorListCount">Showing 0 validators</div>
      <div class="modal-body" id="validatorListBody">
        <div class="loading-validators">Loading validators...</div>
      </div>
      <div class="validator-load-more" id="validatorLoadMore" style="display: none;">
        <button class="load-more-btn" onclick="loadMoreValidators()">Load More</button>
      </div>
    </div>
  </div>

  <!-- Manage Validator Modal -->
  <div class="modal-overlay" id="manageValidatorModal">
    <div class="manage-modal">
      <!-- Header with Validator Info and Wallet -->
      <div class="manage-modal-header">
        <div class="manage-header-left">
          <button class="manage-back-btn" onclick="closeManageValidator()"> Back</button>
          <div class="manage-validator-identity">
            <div class="manage-validator-logo" id="manageValidatorLogo">V</div>
            <div>
              <h2>Manage Your Validator</h2>
              <div class="manage-validator-name" id="manageValidatorName">Loading...</div>
              <div class="manage-validator-address-row">
                <span class="manage-validator-address" id="manageValidatorFullAddress">Loading...</span>
                <button class="copy-address-btn" onclick="copyValidatorAddress()" title="Copy address">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </div>
        <div class="manage-header-right">
          <div class="wallet-connection" id="walletConnection">
            <span class="wallet-status-indicator" id="walletStatusIndicator"></span>
            <span class="wallet-status-text" id="walletStatusText">No wallet connected</span>
            <button class="connect-wallet-btn" id="connectWalletBtn" onclick="connectWallet()">
              Connect Wallet
            </button>
            <button class="disconnect-wallet-btn" id="disconnectWalletBtn" onclick="disconnectWallet()" style="display: none;">
              Disconnect
            </button>
          </div>
        </div>
      </div>
      
      <div class="manage-modal-body">
        <!-- Accounts List Section -->
        <div class="manage-section">
          <div class="section-header">
            <h3>Select Account</h3>
            <div class="section-header-actions">
              <button class="authority-info-btn" onclick="toggleAuthorityLegend()" title="What do the authority badges mean?">
                
              </button>
              <button class="refresh-accounts-btn" onclick="refreshStakeAccounts()" title="Refresh stake accounts">
                 Refresh
              </button>
              <button class="add-stake-btn" disabled title="Coming soon">
                + Add Stake
              </button>
            </div>
          </div>
          
          <div class="authority-legend" id="authorityLegend">
            <div class="authority-legend-title">Authority Badge Colors</div>
            <div class="authority-legend-item">
              <span class="auth-badge has-auth">Stake</span>
              <span>Green = Your connected wallet has this authority</span>
            </div>
            <div class="authority-legend-item">
              <span class="auth-badge no-auth">Stake</span>
              <span>Red = Your connected wallet does NOT have this authority</span>
            </div>
            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border); color: var(--text-dim); font-size: 0.7rem;">
              <strong>Stake Authority:</strong> Allows delegating, undelegating, splitting, and merging<br>
              <strong>Withdraw Authority:</strong> Allows withdrawing funds from the stake account
            </div>
          </div>
          
          <div class="accounts-list" id="accountsList">
            <!-- Vote Account -->
            <div class="account-row" id="voteAccountRow" onclick="selectAccount('vote')">
              <div class="account-row-left">
                <span class="account-type-badge vote">VOTE</span>
                <span class="account-address" id="voteAccountAddress">Loading...</span>
                <span id="voteAccountCopyBtn"></span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div class="authority-badges" id="voteAuthorityBadges">
                  <!-- Will be populated dynamically -->
                </div>
                <button class="account-select-btn" id="voteSelectBtn">
                  Select
                </button>
              </div>
            </div>
            

            
            <!-- Stake Accounts Container -->
            <div id="stakeAccountsContainer">
              <div class="loading-text">Loading stake accounts...</div>
            </div>
          </div>
        </div>

        <!-- Selected Account Details -->
        <div class="manage-section">
          <div class="section-header">
            <h3 id="selectedAccountTitle">Vote Account Details</h3>
            <div class="authority-badges-container" id="authorityBadgesContainer">
              <!-- Single badge for vote account / no wallet -->
              <div class="authority-badge clickable" id="authorityBadge" onclick="onAuthorityBadgeClick()">
                <span class="authority-badge-icon"></span>
                <span class="authority-badge-text">No wallet connected</span>
              </div>
              <!-- Two badges for stake accounts (hidden by default) -->
              <div class="authority-badge-pair" id="authorityBadgePair" style="display: none;">
                <div class="authority-badge no-authority" id="stakeAuthorityBadge">
                  <span class="authority-badge-text">Stake Authority</span>
                </div>
                <div class="authority-badge no-authority" id="withdrawAuthorityBadge">
                  <span class="authority-badge-text">Withdraw Authority</span>
                </div>
              </div>
            </div>
          </div>
          
          <div class="account-details-grid" id="accountDetailsGrid">
            <!-- Vote Account Boxes -->
            <div class="detail-box" id="balanceBox">
              <div class="detail-label">Voter Balance</div>
              <div class="detail-value accent" id="selectedBalance">0.0000</div>
              <div class="detail-unit">XNT</div>
            </div>
            
            <!-- Stake Account Specific Boxes (hidden by default) -->
            <div class="detail-box" id="stakedBalanceBox" style="display: none;">
              <div class="detail-label">Staked Balance</div>
              <div class="detail-value accent" id="selectedStakedBalance">0.0000</div>
              <div class="detail-unit">XNT</div>
            </div>
            
            <div class="detail-box" id="liquidBalanceBox" style="display: none;">
              <div class="detail-label">Liquid Balance</div>
              <div class="detail-value accent" id="selectedLiquidBalance">0.0000</div>
              <div class="detail-unit">XNT</div>
            </div>
            
            <!-- Withdraw Authority (stake accounts only) -->
            <div class="detail-box" id="withdrawAuthorityBox" style="display: none;">
              <div class="detail-label">Withdraw Authority <span class="authority-indicator" id="withdrawAuthorityIndicator"></span></div>
              <div class="detail-address-row">
                <span class="detail-address" id="selectedWithdrawAuthority">Connect wallet to view</span>
                <span id="withdrawAuthorityCopyBtn"></span>
              </div>
            </div>
            
            <!-- Stake Authority (stake accounts only) -->
            <div class="detail-box" id="stakeAuthorityBox" style="display: none;">
              <div class="detail-label">Stake Authority <span class="authority-indicator" id="stakeAuthorityIndicator"></span></div>
              <div class="detail-address-row">
                <span class="detail-address" id="selectedStakeAuthority">Connect wallet to view</span>
                <span id="stakeAuthorityCopyBtn"></span>
              </div>
            </div>
            
            <!-- Validator ID Balance (shown for vote only) -->
            <div class="detail-box" id="validatorIdBalanceBox">
              <div class="detail-label">Validator ID Balance</div>
              <div class="detail-value accent" id="selectedValidatorIdBalance">-</div>
              <div class="detail-unit">XNT</div>
            </div>
            
            <!-- Vote Authority (vote accounts only) -->
            <div class="detail-box" id="voteAuthorityBox" style="display: none;">
              <div class="detail-label">Vote Authority <span class="authority-indicator" id="voteAuthorityIndicator"></span></div>
              <div class="detail-address-row">
                <span class="detail-address" id="selectedVoteAuthority">Loading...</span>
                <span id="voteAuthorityCopyBtn"></span>
              </div>
            </div>
            
            <!-- Vote Withdraw Authority (vote accounts only) -->
            <div class="detail-box" id="voteWithdrawAuthorityBox" style="display: none;">
              <div class="detail-label">Withdraw Authority <span class="authority-indicator" id="voteWithdrawAuthorityIndicator"></span></div>
              <div class="detail-address-row">
                <span class="detail-address" id="selectedVoteWithdrawAuthority">Loading...</span>
                <span id="voteWithdrawAuthorityCopyBtn"></span>
              </div>
            </div>
            
            <!-- Connected Wallet Balance -->
            <div class="detail-box" id="walletBalanceBox" style="display: none;">
              <div class="detail-label">Connected Wallet Balance</div>
              <div class="detail-value accent" id="selectedWalletBalance">-</div>
              <div class="detail-unit">XNT</div>
            </div>
            
            <div class="detail-box" id="commissionBox">
              <div class="detail-label">Commission</div>
              <div class="detail-value" id="selectedCommission">0%</div>
            </div>
            
            <div class="detail-box" id="creditsBox">
              <div class="detail-label">Epoch Credits</div>
              <div class="detail-value highlight" id="selectedCredits">-</div>
            </div>
          </div>
        </div>

        <!-- Actions Section -->
        <div class="manage-section">
          <div class="section-header">
            <h3>Actions</h3>
          </div>
          
          <div class="manage-actions-grid">
            <button class="manage-action-btn" id="withdrawBtn" onclick="initiateWithdraw()">
              <span class="action-icon"></span>
              <span class="action-text">
                <span class="action-title" id="withdrawBtnTitle">Withdraw XNT</span>
                <span class="action-desc">Withdraw rewards to your wallet</span>
              </span>
            </button>
            
            <button class="manage-action-btn" id="commissionBtn" onclick="initiateChangeCommission()">
              <span class="action-icon"></span>
              <span class="action-text">
                <span class="action-title">Change Commission</span>
                <span class="action-desc">Update validator commission rate</span>
              </span>
            </button>
            
            <button class="manage-action-btn" id="authorityBtn" onclick="initiateChangeAuthority()">
              <span class="action-icon"></span>
              <span class="action-text">
                <span class="action-title">Change Authority</span>
                <span class="action-desc">Transfer withdraw authority</span>
              </span>
            </button>
            
            <button class="manage-action-btn" id="identityBtn" onclick="initiateUpdateIdentity()">
              <span class="action-icon"></span>
              <span class="action-text">
                <span class="action-title">Update Identity</span>
                <span class="action-desc">Change on-chain validator info</span>
              </span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Send XNT Modal -->
  <div class="modal-overlay" id="sendXntModal" style="display: none;" onclick="if(event.target === this) closeSendXntModal()">
    <div class="send-modal" onclick="event.stopPropagation()">
      <div class="send-modal-header">
        <h2> Send XNT to Validator ID</h2>
        <button class="modal-close-btn" onclick="closeSendXntModal()"></button>
      </div>
      
      <div class="send-modal-body">
        <!-- Destination Info -->
        <div class="send-section">
          <div class="send-label">Sending to:</div>
          <div class="send-destination">
            <div class="destination-name" id="sendDestinationName">Validator Name</div>
            <div class="destination-address-row">
              <span class="destination-address" id="sendDestinationAddress">Address...</span>
              <span id="sendDestinationCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- ID Wallet Current Balance -->
        <div class="send-section">
          <div class="send-label">ID Wallet Current Balance:</div>
          <div class="send-balance">
            <span class="balance-amount" id="sendIdWalletBalance">Loading...</span>
            <span class="balance-unit">XNT</span>
          </div>
        </div>
        
        <!-- Wallet Balance -->
        <div class="send-section">
          <div class="send-label">Your Wallet Balance:</div>
          <div class="send-balance">
            <span class="balance-amount" id="sendWalletBalance">0.0000</span>
            <span class="balance-unit">XNT</span>
          </div>
        </div>
        
        <!-- Amount Input -->
        <div class="send-section">
          <div class="send-label">Amount to Send:</div>
          <div class="send-input-wrapper">
            <input type="number" class="send-amount-input" id="sendAmountInput" placeholder="0.0000" step="0.0001" min="0">
            <span class="send-input-unit">XNT</span>
          </div>
          <div class="send-preset-buttons">
            <button class="preset-btn" onclick="setSendAmount(25)">25%</button>
            <button class="preset-btn" onclick="setSendAmount(50)">50%</button>
            <button class="preset-btn" onclick="setSendAmount(75)">75%</button>
            <button class="preset-btn max" onclick="setSendAmount(100)">MAX</button>
          </div>
        </div>
        
        <!-- Transaction Summary -->
        <div class="send-section summary">
          <div class="summary-row">
            <span>Amount:</span>
            <span id="sendSummaryAmount">0.0000 XNT</span>
          </div>
          <div class="summary-row">
            <span>Network Fee (est.):</span>
            <span>~0.000005 XNT</span>
          </div>
          <div class="summary-row total">
            <span>Total:</span>
            <span id="sendSummaryTotal">0.0000 XNT</span>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="sendMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="sendXntCancelBtn" onclick="closeSendXntModal()">Cancel</button>
          <button class="send-confirm-btn" id="sendConfirmBtn" onclick="confirmSendXnt()">
            Send XNT
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Withdraw XNT Modal -->
  <div class="modal-overlay" id="withdrawXntModal" style="display: none;" onclick="if(event.target === this) closeWithdrawXntModal()">
    <div class="send-modal" onclick="event.stopPropagation()">
      <div class="send-modal-header">
        <h2> Withdraw XNT from Vote Account</h2>
        <button class="modal-close-btn" onclick="closeWithdrawXntModal()"></button>
      </div>
      
      <div class="send-modal-body">
        <!-- Authority Warning (shown if no authority) -->
        <div class="authority-warning" id="withdrawAuthorityWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Withdraw Authority</strong>
            <p>Your connected wallet does not have withdraw authority for this vote account. Only the withdraw authority can withdraw XNT.</p>
          </div>
        </div>
        
        <!-- Source Info -->
        <div class="send-section">
          <div class="send-label">Withdrawing from:</div>
          <div class="send-destination">
            <div class="destination-name" id="withdrawSourceName">Validator Name</div>
            <div class="destination-address-row">
              <span class="destination-address" id="withdrawSourceAddress">Vote Account Address...</span>
              <span id="withdrawSourceCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Available Balance -->
        <div class="send-section">
          <div class="send-label">Available to Withdraw:</div>
          <div class="send-balance">
            <span class="balance-amount" id="withdrawAvailableBalance">0.0000</span>
            <span class="balance-unit">XNT</span>
          </div>
          <div class="balance-note" id="withdrawBalanceNote">Minimum rent-exempt balance (~0.02 XNT) must remain in account</div>
        </div>
        
        <!-- Amount Input -->
        <div class="send-section">
          <div class="send-label">Amount to Withdraw:</div>
          <div class="send-input-wrapper">
            <input type="number" class="send-amount-input" id="withdrawAmountInput" placeholder="0.0000" step="0.0001" min="0">
            <span class="send-input-unit">XNT</span>
          </div>
          <div class="send-preset-buttons">
            <button class="preset-btn" onclick="setWithdrawAmount(25)">25%</button>
            <button class="preset-btn" onclick="setWithdrawAmount(50)">50%</button>
            <button class="preset-btn" onclick="setWithdrawAmount(75)">75%</button>
            <button class="preset-btn max" onclick="setWithdrawAmount(100)">MAX</button>
          </div>
        </div>
        
        <!-- Destination Address -->
        <div class="send-section">
          <div class="send-label">Send to Address:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="withdrawDestinationInput" placeholder="Destination wallet address...">
          </div>
          <div class="address-note">Defaults to withdraw authority. You can change this to any valid address.</div>
        </div>
        
        <!-- Transaction Summary -->
        <div class="send-section summary">
          <div class="summary-row">
            <span>Amount:</span>
            <span id="withdrawSummaryAmount">0.0000 XNT</span>
          </div>
          <div class="summary-row">
            <span>Network Fee (est.):</span>
            <span>~0.000005 XNT</span>
          </div>
          <div class="summary-row total">
            <span>You will receive:</span>
            <span id="withdrawSummaryTotal">0.0000 XNT</span>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="withdrawMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="withdrawXntCancelBtn" onclick="closeWithdrawXntModal()">Cancel</button>
          <button class="send-confirm-btn" id="withdrawConfirmBtn" onclick="confirmWithdrawXnt()">
            Withdraw XNT
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Change Commission Modal -->
  <div class="modal-overlay" id="commissionModal" style="display: none;" onclick="if(event.target === this) closeCommissionModal()">
    <div class="send-modal" onclick="event.stopPropagation()">
      <div class="send-modal-header">
        <h2> Change Commission Rate</h2>
        <button class="modal-close-btn" onclick="closeCommissionModal()"></button>
      </div>
      
      <div class="send-modal-body">
        <!-- Authority Warning (shown if no authority) -->
        <div class="authority-warning" id="commissionAuthorityWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Authority</strong>
            <p>Your connected wallet does not have authority to change the commission for this validator.</p>
          </div>
        </div>
        
        <!-- Validator Info -->
        <div class="send-section">
          <div class="send-label">Validator:</div>
          <div class="send-destination">
            <div class="destination-name" id="commissionValidatorName">Validator Name</div>
            <div class="destination-address-row">
              <span class="destination-address" id="commissionVoteAddress">Vote Account Address...</span>
              <span id="commissionVoteCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Current Commission -->
        <div class="send-section">
          <div class="send-label">Current Commission:</div>
          <div class="commission-display">
            <span class="commission-value" id="commissionCurrentValue">0</span>
            <span class="commission-percent">%</span>
          </div>
        </div>
        
        <!-- New Commission Input -->
        <div class="send-section">
          <div class="send-label">New Commission Rate:</div>
          <div class="commission-input-wrapper">
            <input type="number" class="commission-input" id="commissionNewInput" placeholder="0" min="0" max="100" step="1">
            <span class="commission-input-unit">%</span>
          </div>
          <div class="address-note">Commission can be set from 0% to 100%. Changes take effect next epoch.</div>
        </div>
        
        <!-- Info Box -->
        <div class="commission-info-box">
          <div class="info-icon"></div>
          <div class="info-text">
            Commission is the percentage of staking rewards that goes to the validator. The remaining percentage goes to stakers.
          </div>
        </div>
        
        <!-- Epoch Limit Warning -->
        <div class="commission-epoch-warning">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>Once Per Epoch</strong>
            <p>Commission can only be changed once per epoch. If you recently updated commission, you must wait until the next epoch.</p>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="commissionMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="commissionCancelBtn" onclick="closeCommissionModal()">Cancel</button>
          <button class="send-confirm-btn" id="commissionConfirmBtn" onclick="confirmChangeCommission()">
            Update Commission
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Update Identity Modal -->
  <div class="modal-overlay" id="identityModal" style="display: none;" onclick="if(event.target === this) closeIdentityModal()">
    <div class="send-modal identity-modal" onclick="event.stopPropagation()">
      <div class="send-modal-header">
        <h2> Update Validator Identity</h2>
        <button class="modal-close-btn" onclick="closeIdentityModal()"></button>
      </div>
      
      <div class="send-modal-body">
        <!-- Authority Warning (shown if no authority) -->
        <div class="authority-warning" id="identityAuthorityWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Authority</strong>
            <p>Your connected wallet does not match the validator's identity. Only the identity keypair can update validator info.</p>
          </div>
        </div>
        
        <!-- Current Identity Info -->
        <div class="send-section">
          <div class="send-label">Identity Account:</div>
          <div class="send-destination">
            <div class="destination-name" id="identityCurrentName">Validator Name</div>
            <div class="destination-address-row">
              <span class="destination-address" id="identityAccountAddress">Identity Address...</span>
              <span id="identityAccountCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Validator Name Input -->
        <div class="send-section">
          <div class="send-label">Validator Name:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="identityNameInput" placeholder="Enter your validator name...">
          </div>
          <div class="address-note">This is the display name shown in explorers and dashboards.</div>
        </div>
        
        <!-- Website Input -->
        <div class="send-section">
          <div class="send-label">Website URL:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="identityWebsiteInput" placeholder="https://your-website.com">
          </div>
          <div class="address-note">Your validator's website or social link.</div>
        </div>
        
        <!-- Icon URL Input -->
        <div class="send-section">
          <div class="send-label">Icon URL:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="identityIconInput" placeholder="https://your-website.com/icon.png">
          </div>
          <div class="address-note">Direct URL to your validator's icon/logo image (PNG, JPG, or SVG recommended).</div>
        </div>
        
        <!-- Icon Preview -->
        <div class="send-section" id="iconPreviewSection" style="display: none;">
          <div class="send-label">Icon Preview:</div>
          <div class="icon-preview-container">
            <img id="iconPreviewImg" src="" alt="Icon Preview" onerror="hideIconPreview()">
          </div>
        </div>
        
        <!-- Info Box -->
        <div class="commission-info-box">
          <div class="info-icon"></div>
          <div class="info-text">
            This is equivalent to running: <code>solana validator-info publish "Name" -w "website" -i "icon"</code>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="identityMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="identityCancelBtn" onclick="closeIdentityModal()">Cancel</button>
          <button class="send-confirm-btn" id="identityConfirmBtn" onclick="confirmUpdateIdentity()">
            Update Identity
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Create & Delegate Stake Modal -->
  <div class="modal-overlay" id="createStakeModal" style="display: none;" onclick="if(event.target === this) closeCreateStakeModal()">
    <div class="send-modal" onclick="event.stopPropagation()">
      <div class="send-modal-header">
        <h2><span style="color: #ffc107; font-weight: bold;">+</span> Create & Delegate Stake</h2>
        <button class="modal-close-btn" onclick="closeCreateStakeModal()"></button>
      </div>
      
      <div class="send-modal-body">
        <!-- Validator Info -->
        <div class="send-section">
          <div class="send-label">Delegating to:</div>
          <div class="send-destination">
            <div class="destination-name" id="createStakeValidatorName">Validator Name</div>
            <div class="destination-address-row">
              <span class="destination-address" id="createStakeVoteAddress">Vote Account Address...</span>
              <span id="createStakeVoteCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Wallet Balance -->
        <div class="send-section">
          <div class="send-label">Your Wallet Balance:</div>
          <div class="send-balance">
            <span class="balance-amount" id="createStakeWalletBalance">0.0000</span>
            <span class="balance-unit">XNT</span>
          </div>
          <div class="balance-note">Stake will be funded from your connected wallet</div>
        </div>
        
        <!-- Authorities Info -->
        <div class="send-section">
          <div class="send-label">Stake Authorities (set to your wallet):</div>
          <div class="authorities-info-box">
            <div class="authority-info-row">
              <span class="authority-info-label">Stake Authority:</span>
              <span class="authority-info-value" id="createStakeStakerAuthority">Connect wallet...</span>
            </div>
            <div class="authority-info-row">
              <span class="authority-info-label">Withdraw Authority:</span>
              <span class="authority-info-value" id="createStakeWithdrawAuthority">Connect wallet...</span>
            </div>
          </div>
          <div class="balance-note">These can be changed later using Set Authority actions</div>
        </div>
        
        <!-- Stake Amount Input -->
        <div class="send-section">
          <div class="send-label">Amount to Stake:</div>
          <div class="send-input-wrapper">
            <input type="number" class="send-amount-input" id="createStakeAmountInput" placeholder="0.0000" step="0.0001" min="0">
            <span class="send-input-unit">XNT</span>
          </div>
          <div class="send-preset-buttons">
            <button class="preset-btn" onclick="setCreateStakeAmount(25)">25%</button>
            <button class="preset-btn" onclick="setCreateStakeAmount(50)">50%</button>
            <button class="preset-btn" onclick="setCreateStakeAmount(75)">75%</button>
            <button class="preset-btn max" onclick="setCreateStakeAmount(100)">MAX</button>
          </div>
        </div>
        
        <!-- Minimum Stake Note -->
        <div class="commission-info-box">
          <div class="info-icon"></div>
          <div class="info-text">
            A minimum of ~0.003 XNT is required for the stake account rent-exempt reserve. The stake will be active after the current epoch ends.
          </div>
        </div>
        
        <!-- Transaction Summary -->
        <div class="send-section summary">
          <div class="summary-row">
            <span>Stake Amount:</span>
            <span id="createStakeSummaryAmount">0.0000 XNT</span>
          </div>
          <div class="summary-row">
            <span>Account Rent:</span>
            <span>~0.003 XNT</span>
          </div>
          <div class="summary-row">
            <span>Network Fee (est.):</span>
            <span>~0.000005 XNT</span>
          </div>
          <div class="summary-row total">
            <span>Total Cost:</span>
            <span id="createStakeSummaryTotal">0.0000 XNT</span>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="createStakeMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="createStakeCancelBtn" onclick="closeCreateStakeModal()">Cancel</button>
          <button class="send-confirm-btn" id="createStakeConfirmBtn" onclick="confirmCreateStake()">
            Create & Delegate Stake
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Change Vote Account Authority Modal -->
  <div class="modal-overlay" id="changeVoteAuthorityModal" style="display: none;" onclick="if(event.target === this) closeChangeVoteAuthorityModal()">
    <div class="modal send-modal">
      <div class="modal-header">
        <h2> Change Vote Account Authority</h2>
        <button class="modal-close" onclick="closeChangeVoteAuthorityModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Authority Warning -->
        <div class="authority-warning" id="voteAuthorityWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Authority</strong>
            <p id="voteAuthorityWarningText">Your connected wallet is not the current authority for this vote account.</p>
          </div>
        </div>
        
        <!-- Vote Account Info -->
        <div class="send-section">
          <div class="send-label">Vote Account:</div>
          <div class="send-destination">
            <div class="destination-name" id="changeVoteValidatorName">Validator Name</div>
            <div class="destination-address-row">
              <span class="destination-address" id="changeVoteAccountAddress">Vote Address...</span>
              <span id="changeVoteAccountCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Authority Type Selection -->
        <div class="send-section">
          <div class="send-label">Select Authority to Change:</div>
          <div class="authority-type-selector">
            <button class="authority-type-btn active" id="voteAuthorityTypeBtn" onclick="selectVoteAuthorityType('vote')">
              <span class="authority-type-icon"></span>
              <span class="authority-type-text">
                <span class="authority-type-title">Vote Authority</span>
                <span class="authority-type-desc">Who can submit votes</span>
              </span>
            </button>
            <button class="authority-type-btn" id="withdrawAuthorityTypeBtn" onclick="selectVoteAuthorityType('withdraw')">
              <span class="authority-type-icon"></span>
              <span class="authority-type-text">
                <span class="authority-type-title">Withdraw Authority</span>
                <span class="authority-type-desc">Who can withdraw funds</span>
              </span>
            </button>
          </div>
        </div>
        
        <!-- Current Authority -->
        <div class="send-section">
          <div class="send-label" id="currentVoteAuthorityLabel">Current Vote Authority:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="currentVoteAuthority">Loading...</span>
              <span id="currentVoteAuthorityCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- New Authority Input -->
        <div class="send-section">
          <div class="send-label" id="newVoteAuthorityLabel">New Vote Authority:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="newVoteAuthorityInput" placeholder="Enter new authority public key..." oninput="validateVoteAuthorityInput()">
          </div>
          <button class="use-wallet-btn" onclick="useWalletForVoteAuthority()">Use Connected Wallet</button>
          <div class="address-note" style="margin-top: 0.5rem;"> Warning: This action is irreversible. Make sure you have access to the new authority address.</div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="changeVoteAuthorityMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="changeVoteAuthorityCancelBtn" onclick="closeChangeVoteAuthorityModal()">Cancel</button>
          <button class="send-confirm-btn" id="changeVoteAuthorityBtn" onclick="confirmChangeVoteAuthority()" disabled>
            Change Authority
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Vote Authority Danger Confirmation Modal -->
  <div class="modal-overlay" id="voteAuthorityDangerModal" style="display: none;" onclick="if(event.target === this) closeVoteAuthorityDangerModal()">
    <div class="modal send-modal" style="max-width: 480px;">
      <div class="modal-header" style="background: linear-gradient(135deg, rgba(255, 82, 82, 0.2), rgba(255, 152, 0, 0.2)); border-bottom: 1px solid var(--danger);">
        <h2 style="color: var(--danger);"> DANGER: Vote Authority Change</h2>
        <button class="modal-close" onclick="closeVoteAuthorityDangerModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <div class="danger-warning-box">
          <div class="danger-icon"></div>
          <div class="danger-title">THIS ACTION CAN BRICK YOUR VALIDATOR</div>
          <div class="danger-text">
            Changing the <strong>Vote Authority</strong> is an extremely dangerous operation. If done incorrectly:
          </div>
          <ul class="danger-list">
            <li>Your validator will <strong>immediately stop voting</strong></li>
            <li>Your validator will become <strong>delinquent within minutes</strong></li>
            <li>You will <strong>lose staking rewards</strong></li>
            <li>This action is <strong>irreversible</strong></li>
          </ul>
          <div class="danger-text" style="margin-top: 1rem;">
            Only proceed if you are doing <strong>key rotation</strong> and the new key is already configured on your validator node.
          </div>
        </div>
        
        <div class="send-section" style="margin-top: 1.5rem;">
          <div class="send-label">Type <span style="color: var(--danger); font-weight: 700;">CHANGE VOTE AUTHORITY</span> to confirm:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="voteAuthorityConfirmInput" placeholder="Type exactly as shown above..." oninput="validateVoteAuthorityConfirm()" autocomplete="off">
          </div>
        </div>
        
        <div class="send-actions" style="margin-top: 1rem;">
          <button class="send-cancel-btn" onclick="closeVoteAuthorityDangerModal()">Cancel</button>
          <button class="send-confirm-btn danger-btn" id="voteAuthorityDangerBtn" onclick="proceedWithVoteAuthorityChange()" disabled style="background: linear-gradient(135deg, var(--danger), #ff5252);">
            I Understand, Proceed
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Set Withdraw Authority Modal (for Stake) -->
  <div class="modal-overlay" id="setWithdrawAuthorityModal" style="display: none;" onclick="if(event.target === this) closeSetWithdrawAuthorityModal()">
    <div class="modal send-modal">
      <div class="modal-header">
        <h2> Set Withdraw Authority</h2>
        <button class="modal-close" onclick="closeSetWithdrawAuthorityModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Authority Warning -->
        <div class="authority-warning" id="withdrawAuthorityWarning2" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Authority</strong>
            <p>Your connected wallet is not the current withdraw authority for this stake account.</p>
          </div>
        </div>
        
        <!-- Stake Account Info -->
        <div class="send-section">
          <div class="send-label">Stake Account:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="setWithdrawStakeAddress">Stake Address...</span>
              <span id="setWithdrawStakeCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Current Authority -->
        <div class="send-section">
          <div class="send-label">Current Withdraw Authority:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="setWithdrawCurrentAuthority">Address...</span>
              <span id="setWithdrawCurrentCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- New Authority Input -->
        <div class="send-section">
          <div class="send-label">New Withdraw Authority:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="setWithdrawNewAuthority" placeholder="Enter new authority public key...">
          </div>
          <div class="address-note"> Warning: This action is irreversible. Make sure you have access to the new authority address.</div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="setWithdrawAuthorityMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="setWithdrawAuthorityCancelBtn" onclick="closeSetWithdrawAuthorityModal()">Cancel</button>
          <button class="send-confirm-btn" id="setWithdrawAuthorityBtn" onclick="confirmSetWithdrawAuthority()" disabled>
            Set New Authority
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Set Stake Authority Modal -->
  <div class="modal-overlay" id="setStakeAuthorityModal" style="display: none;" onclick="if(event.target === this) closeSetStakeAuthorityModal()">
    <div class="modal send-modal">
      <div class="modal-header">
        <h2> Set Stake Authority</h2>
        <button class="modal-close" onclick="closeSetStakeAuthorityModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Authority Warning -->
        <div class="authority-warning" id="stakeAuthorityWarning2" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Authority</strong>
            <p>Your connected wallet is not the current stake authority for this stake account.</p>
          </div>
        </div>
        
        <!-- Stake Account Info -->
        <div class="send-section">
          <div class="send-label">Stake Account:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="setStakerStakeAddress">Stake Address...</span>
              <span id="setStakerStakeCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Current Authority -->
        <div class="send-section">
          <div class="send-label">Current Stake Authority:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="setStakerCurrentAuthority">Address...</span>
              <span id="setStakerCurrentCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- New Authority Input -->
        <div class="send-section">
          <div class="send-label">New Stake Authority:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="setStakerNewAuthority" placeholder="Enter new authority public key...">
          </div>
          <div class="address-note"> Warning: This action is irreversible. Make sure you have access to the new authority address.</div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="setStakeAuthorityMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="setStakeAuthorityCancelBtn" onclick="closeSetStakeAuthorityModal()">Cancel</button>
          <button class="send-confirm-btn" id="setStakeAuthorityBtn" onclick="confirmSetStakeAuthority()" disabled>
            Set New Authority
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Undelegate Stake Modal -->
  <div class="modal-overlay" id="undelegateStakeModal" style="display: none;" onclick="if(event.target === this) closeUndelegateStakeModal()">
    <div class="modal send-modal">
      <div class="modal-header">
        <h2> Undelegate Stake</h2>
        <button class="modal-close" onclick="closeUndelegateStakeModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Authority Warning -->
        <div class="authority-warning" id="undelegateAuthorityWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Stake Authority</strong>
            <p>Your connected wallet is not the stake authority for this stake account. Only the stake authority can undelegate.</p>
          </div>
        </div>
        
        <!-- Already Deactivating Warning -->
        <div class="authority-warning" id="undelegateAlreadyWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>Already Deactivating or Inactive</strong>
            <p>This stake account is already deactivating or fully inactive. No action needed.</p>
          </div>
        </div>
        
        <!-- Stake Account Info -->
        <div class="send-section">
          <div class="send-label">Stake Account:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="undelegateStakeAddress">Stake Address...</span>
              <span id="undelegateStakeAddressCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Delegated To -->
        <div class="send-section">
          <div class="send-label">Currently Delegated To:</div>
          <div class="send-destination">
            <div class="destination-name" id="undelegateValidatorName">Validator Name</div>
            <div class="destination-address-row">
              <span class="destination-address" id="undelegateVoteAccount">Vote Account...</span>
            </div>
          </div>
        </div>
        
        <!-- Stake Amount -->
        <div class="send-section">
          <div class="send-label">Staked Amount:</div>
          <div class="send-balance">
            <span class="balance-amount" id="undelegateStakeAmount">0.0000</span>
            <span class="balance-unit">XNT</span>
          </div>
        </div>
        
        <!-- What Happens -->
        <div class="send-section">
          <div class="send-label">What happens when you undelegate:</div>
          <div class="undelegate-timeline">
            <div class="timeline-step">
              <div class="timeline-icon">1</div>
              <div class="timeline-text">
                <strong>Immediately:</strong> Stake enters "Deactivating" state
              </div>
            </div>
            <div class="timeline-step">
              <div class="timeline-icon">2</div>
              <div class="timeline-text">
                <strong>End of current epoch:</strong> Stake becomes "Inactive" (cooldown complete)
              </div>
            </div>
            <div class="timeline-step">
              <div class="timeline-icon">3</div>
              <div class="timeline-text">
                <strong>Then:</strong> You can withdraw XNT to your wallet
              </div>
            </div>
          </div>
          <div class="address-note" style="margin-top: 0.5rem;"> Your stake will stop earning rewards once deactivation begins.</div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="undelegateMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="undelegateCancelBtn" onclick="closeUndelegateStakeModal()">Cancel</button>
          <button class="send-confirm-btn" id="undelegateConfirmBtn" onclick="confirmUndelegateStake()" disabled>
            Undelegate Stake
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Redelegate Stake Modal -->
  <div class="modal-overlay" id="redelegateStakeModal" style="display: none;" onclick="if(event.target === this) closeRedelegateStakeModal()">
    <div class="modal send-modal" style="max-width: 500px;">
      <div class="modal-header">
        <h2> Redelegate Stake</h2>
        <button class="modal-close" onclick="closeRedelegateStakeModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Authority Warning -->
        <div class="authority-warning" id="redelegateAuthorityWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Stake Authority</strong>
            <p>Your connected wallet is not the stake authority for this stake account. Only the stake authority can redelegate.</p>
          </div>
        </div>
        
        <!-- Not Active Warning -->
        <div class="authority-warning" id="redelegateNotActiveWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>Stake Not Active</strong>
            <p>This stake account is not currently active. You can only redelegate active stakes.</p>
          </div>
        </div>
        
        <!-- Stake Account Info -->
        <div class="send-section">
          <div class="send-label">Stake Account:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="redelegateStakeAddress">Stake Address...</span>
              <span id="redelegateStakeAddressCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Current Delegation -->
        <div class="send-section">
          <div class="send-label">Currently Delegated To:</div>
          <div class="send-destination" style="background: rgba(255, 152, 0, 0.1); border-color: rgba(255, 152, 0, 0.3);">
            <div class="destination-name" id="redelegateCurrentValidator" style="color: #ff9800;">Current Validator</div>
            <div class="destination-address-row">
              <span class="destination-address" id="redelegateCurrentVoteAccount">Vote Account...</span>
            </div>
          </div>
        </div>
        
        <!-- Stake Amount -->
        <div class="send-section">
          <div class="send-label">Staked Amount:</div>
          <div class="send-balance">
            <span class="balance-amount" id="redelegateStakeAmount">0.0000</span>
            <span class="balance-unit">XNT</span>
          </div>
        </div>
        
        <!-- New Validator Selection -->
        <div class="send-section">
          <div class="send-label">Select New Validator:</div>
          <div class="redelegate-search-container">
            <input type="text" class="redelegate-search-input" id="redelegateValidatorSearch" placeholder="Search by name or vote account..." oninput="handleRedelegateSearch()">
            <div class="redelegate-search-results" id="redelegateSearchResults" style="display: none;"></div>
          </div>
          <div class="send-destination" id="redelegateNewValidatorBox" style="display: none; background: rgba(0, 230, 118, 0.1); border-color: rgba(0, 230, 118, 0.3);">
            <div class="destination-name" id="redelegateNewValidator" style="color: var(--success);">New Validator</div>
            <div class="destination-address-row">
              <span class="destination-address" id="redelegateNewVoteAccount">Vote Account...</span>
              <button class="clear-selection-btn" onclick="clearRedelegateSelection()"></button>
            </div>
          </div>
        </div>
        
        <!-- What Happens -->
        <div class="send-section" id="redelegateWhatHappens">
          <div class="send-label">What happens when you redelegate:</div>
          <div class="undelegate-timeline" id="redelegateTimeline">
            <div class="timeline-step">
              <div class="timeline-icon">1</div>
              <div class="timeline-text">
                <strong>Immediately:</strong> Stake starts transitioning to new validator
              </div>
            </div>
            <div class="timeline-step">
              <div class="timeline-icon">2</div>
              <div class="timeline-text">
                <strong>End of epoch:</strong> Stake becomes active on new validator
              </div>
            </div>
          </div>
          <div class="address-note" id="redelegateNote" style="margin-top: 0.5rem;"> No cooldown required - stake continues earning (with brief transition).</div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="redelegateMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="redelegateCancelBtn" onclick="closeRedelegateStakeModal()">Cancel</button>
          <button class="send-confirm-btn" id="redelegateConfirmBtn" onclick="confirmRedelegateStake()" disabled>
            Redelegate Stake
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Withdraw XNT from Stake Modal -->
  <div class="modal-overlay" id="withdrawStakeModal" style="display: none;" onclick="if(event.target === this) closeWithdrawStakeModal()">
    <div class="modal send-modal">
      <div class="modal-header">
        <h2> Withdraw XNT from Stake</h2>
        <button class="modal-close" onclick="closeWithdrawStakeModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Authority Warning -->
        <div class="authority-warning" id="withdrawStakeAuthorityWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Withdraw Authority</strong>
            <p>Your connected wallet is not the withdraw authority for this stake account.</p>
          </div>
        </div>
        
        <!-- No Balance Warning -->
        <div class="authority-warning" id="withdrawStakeNoBalanceWarning" style="display: none;">
          <div class="warning-icon"></div>
          <div class="warning-text">
            <strong>No Liquid Balance Available</strong>
            <p>This stake account has no liquid (unstaked) XNT available to withdraw. You must first undelegate the stake and wait for it to fully deactivate before withdrawing.</p>
          </div>
        </div>
        
        <!-- Stake Account Info -->
        <div class="send-section">
          <div class="send-label">Stake Account:</div>
          <div class="send-destination">
            <div class="destination-address-row">
              <span class="destination-address" id="withdrawStakeAddress">Stake Address...</span>
              <span id="withdrawStakeAddressCopyBtn"></span>
            </div>
          </div>
        </div>
        
        <!-- Stake Status -->
        <div class="send-section">
          <div class="send-label">Stake Status:</div>
          <div class="send-destination">
            <span class="status-badge" id="withdrawStakeStatus">Active</span>
            <span class="status-note" id="withdrawStakeStatusNote"></span>
          </div>
        </div>
        
        <!-- Balance Breakdown -->
        <div class="send-section">
          <div class="send-label">Balance Breakdown:</div>
          <div class="balance-breakdown">
            <div class="breakdown-row">
              <span>Total Balance:</span>
              <span id="withdrawStakeTotalBalance">0.0000 XNT</span>
            </div>
            <div class="breakdown-row">
              <span>Staked (Locked):</span>
              <span id="withdrawStakeLockedBalance">0.0000 XNT</span>
            </div>
            <div class="breakdown-row available">
              <span>Available to Withdraw:</span>
              <span id="withdrawStakeAvailableBalance">0.0000 XNT</span>
            </div>
          </div>
        </div>
        
        <!-- Amount Input -->
        <div class="send-section" id="withdrawStakeAmountSection">
          <div class="send-label">Amount to Withdraw:</div>
          <div class="send-input-wrapper">
            <input type="number" class="send-amount-input" id="withdrawStakeAmountInput" placeholder="0.0000" step="0.0001" min="0">
            <span class="send-input-unit">XNT</span>
          </div>
          <div class="send-preset-buttons">
            <button class="preset-btn" onclick="setWithdrawStakeAmount(25)">25%</button>
            <button class="preset-btn" onclick="setWithdrawStakeAmount(50)">50%</button>
            <button class="preset-btn" onclick="setWithdrawStakeAmount(75)">75%</button>
            <button class="preset-btn max" onclick="setWithdrawStakeAmount(100)">MAX</button>
          </div>
        </div>
        
        <!-- Destination Address -->
        <div class="send-section" id="withdrawStakeDestSection">
          <div class="send-label">Send to Address:</div>
          <div class="send-input-wrapper">
            <input type="text" class="send-address-input" id="withdrawStakeDestInput" placeholder="Destination wallet address...">
          </div>
          <div class="address-note">Defaults to withdraw authority. You can change this to any valid address.</div>
        </div>
        
        <!-- Close Account Option (only shown for inactive stakes) -->
        <div class="send-section" id="withdrawStakeCloseSection" style="display: none;">
          <div class="close-account-option">
            <label class="close-account-checkbox">
              <input type="checkbox" id="withdrawStakeCloseCheckbox" onchange="toggleCloseStakeAccount()">
              <span class="checkmark"></span>
              <span class="close-account-label">Close account & withdraw all (including rent)</span>
            </label>
            <div class="close-account-note">
              This will withdraw the full balance including ~0.00228 XNT rent and permanently close this stake account.
            </div>
          </div>
        </div>
        
        <!-- Transaction Summary -->
        <div class="send-section summary" id="withdrawStakeSummarySection">
          <div class="summary-row">
            <span>Amount:</span>
            <span id="withdrawStakeSummaryAmount">0.0000 XNT</span>
          </div>
          <div class="summary-row">
            <span>Network Fee (est.):</span>
            <span>~0.000005 XNT</span>
          </div>
          <div class="summary-row total">
            <span>You will receive:</span>
            <span id="withdrawStakeSummaryTotal">0.0000 XNT</span>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="withdrawStakeMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="withdrawStakeCancelBtn" onclick="closeWithdrawStakeModal()">Cancel</button>
          <button class="send-confirm-btn" id="withdrawStakeConfirmBtn" onclick="confirmWithdrawFromStake()" disabled>
            Withdraw XNT
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Merge Stakes Modal -->
  <div class="modal-overlay" id="mergeStakesModal" style="display: none;" onclick="if(event.target === this) closeMergeStakesModal()">
    <div class="modal send-modal" style="max-width: 600px;">
      <div class="modal-header">
        <h2> Merge Stakes</h2>
        <button class="modal-close" onclick="closeMergeStakesModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Validator Info -->
        <div class="send-section">
          <div class="send-label">Validator:</div>
          <div class="send-value" id="mergeStakesValidatorName">-</div>
        </div>
        
        <!-- Info Box -->
        <div class="info-box" style="margin-bottom: 1rem;">
          <div class="info-icon"></div>
          <div class="info-text">
            <p><strong>Merge Requirements:</strong></p>
            <p> All selected stakes must have the same stake authority</p>
            <p> All selected stakes must have the same withdraw authority</p>
            <p> Your connected wallet must be the stake authority</p>
            <p> Stakes must be in compatible states</p>
          </div>
        </div>
        
        <!-- Stakes List -->
        <div class="send-section">
          <div class="send-label">Select Stakes to Merge: <span style="font-weight: 400; color: var(--text-dim); font-size: 0.8rem;">(first selected = destination account)</span></div>
          <div class="merge-stakes-list" id="mergeStakesList">
            <div class="loading-text">Loading stakes...</div>
          </div>
        </div>
        
        <!-- Selected Stakes Summary -->
        <div class="send-section" id="mergeStakesSummarySection" style="display: none;">
          <div class="send-label">Merge Summary:</div>
          <div class="transaction-summary">
            <div class="summary-row">
              <span class="summary-label">Stakes to merge:</span>
              <span class="summary-value" id="mergeStakesCount">0</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Total amount:</span>
              <span class="summary-value" id="mergeStakesTotal">0.0000 XNT</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Destination stake:</span>
              <span class="summary-value" id="mergeStakesDestination">-</span>
            </div>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="mergeStakesMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="mergeStakesCancelBtn" onclick="closeMergeStakesModal()">Cancel</button>
          <button class="send-confirm-btn" id="mergeStakesConfirmBtn" onclick="confirmMergeStakes()" disabled>
            Merge Selected Stakes
          </button>
        </div>
      </div>
    </div>
  </div>


  <!-- Split Stake Modal -->
  <div class="modal-overlay" id="splitStakeModal" style="display: none;" onclick="if(event.target === this) closeSplitStakeModal()">
    <div class="modal send-modal" style="max-width: 500px;">
      <div class="modal-header">
        <h2> Split Stake</h2>
        <button class="modal-close" onclick="closeSplitStakeModal()">&times;</button>
      </div>
      
      <div class="send-modal-content">
        <!-- Validator Info -->
        <div class="send-section">
          <div class="send-label">Validator:</div>
          <div class="send-value" id="splitStakeValidatorName">-</div>
        </div>
        
        <!-- Current Stake Info -->
        <div class="send-section">
          <div class="send-label">Stake Account:</div>
          <div class="send-value" id="splitStakeAddress" style="font-family: 'JetBrains Mono', monospace; font-size: 0.85rem;">-</div>
        </div>
        
        <div class="send-section">
          <div class="send-label">Current Balance:</div>
          <div class="send-balance">
            <span class="balance-amount" id="splitStakeBalance">0.0000</span>
            <span class="balance-unit">XNT</span>
          </div>
          <div class="balance-note">Minimum ~0.003 XNT must remain in each account for rent</div>
        </div>
        
        <!-- Split Amount Input -->
        <div class="send-section">
          <div class="send-label">Amount to Split Off:</div>
          <div class="send-input-wrapper">
            <input type="number" class="send-amount-input" id="splitStakeAmountInput" placeholder="0.0000" step="0.0001" min="0" oninput="updateSplitStakeSummary()">
            <span class="send-input-unit">XNT</span>
          </div>
          <div class="send-preset-btns">
            <button class="preset-btn" onclick="setSplitStakeAmount(25)">25%</button>
            <button class="preset-btn" onclick="setSplitStakeAmount(50)">50%</button>
            <button class="preset-btn" onclick="setSplitStakeAmount(75)">75%</button>
          </div>
        </div>
        
        <!-- Info Box -->
        <div class="info-box" style="margin: 1rem 0;">
          <div class="info-icon"></div>
          <div class="info-text">
            <p>Split creates a new stake account with the specified amount.</p>
            <p>The new account inherits the same authorities and delegation.</p>
          </div>
        </div>
        
        <!-- Summary -->
        <div class="send-section">
          <div class="send-label">After Split:</div>
          <div class="transaction-summary">
            <div class="summary-row">
              <span class="summary-label">Original stake will have:</span>
              <span class="summary-value" id="splitStakeRemaining">0.0000 XNT</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">New stake will have:</span>
              <span class="summary-value" id="splitStakeNew">0.0000 XNT</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Rent (from wallet):</span>
              <span class="summary-value">~0.00228 XNT</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Network fee:</span>
              <span class="summary-value">~0.000005 XNT</span>
            </div>
          </div>
        </div>
        
        <!-- Error/Status Message -->
        <div class="send-message" id="splitStakeMessage" style="display: none;"></div>
        
        <!-- Action Buttons -->
        <div class="send-actions">
          <button class="send-cancel-btn" id="splitStakeCancelBtn" onclick="closeSplitStakeModal()">Cancel</button>
          <button class="send-confirm-btn" id="splitStakeConfirmBtn" onclick="confirmSplitStake()">
            Split Stake
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Action Explainer Modal -->
  <div class="modal-overlay" id="actionExplainerModal" style="display: none;" onclick="if(event.target === this) closeActionExplainerModal()">
    <div class="modal-container" style="max-width: 420px;">
      <div class="send-modal-content">
        <div class="send-header">
          <h2 id="actionExplainerTitle">Action Unavailable</h2>
          <button class="modal-close-btn" onclick="closeActionExplainerModal()"></button>
        </div>
        <div class="send-body" id="actionExplainerContent">
          <!-- Content populated by JS -->
        </div>
      </div>
    </div>
  </div>

  <!-- Performance Score Explainer Modal -->
  <div class="perf-explainer-modal" id="perfExplainerModal" onclick="closePerfExplainerModal(event)">
    <div class="perf-explainer-content" onclick="event.stopPropagation()">
      <div class="perf-explainer-header">
        <h3> Performance Score Explained</h3>
        <button class="perf-explainer-close" onclick="closePerfExplainerModal()">&times;</button>
      </div>
      <div class="perf-explainer-body">
        <!-- Validator-specific breakdown (populated by JS) -->
        <div id="perfBreakdownSection" class="perf-breakdown-section" style="display: none;"></div>
        
        <div class="perf-explainer-divider"></div>
        
        <h4 style="color: var(--text-primary); margin-bottom: 1rem;">How Scoring Works</h4>
        <p style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
          The Performance Score is a <strong>size-independent</strong> metric that evaluates operator quality over the last 7 epochs. 
          It uses <strong>percentile rankings</strong> to spread scores and reward efficient operators regardless of stake size.
        </p>
        
        <div class="perf-metric-item">
          <div class="perf-metric-header">
            <span class="perf-metric-name"> Vote Efficiency</span>
            <span class="perf-metric-weight">30%</span>
          </div>
          <div class="perf-metric-description">
            Measures how many epoch credits the validator earns compared to the network average.
            A validator earning 105% of average credits is performing better than one earning 95%.
            This is size-independent since credits are roughly equal for all active validators.
          </div>
          <div class="perf-metric-scoring">
            <div class="perf-metric-scoring-title">Scoring</div>
            <div class="perf-metric-scoring-detail">
              105%+ = 100  101% = 96  100% = 93  99% = 88  97% = 75  95% = 65
            </div>
          </div>
        </div>
        
        <div class="perf-metric-item">
          <div class="perf-metric-header">
            <span class="perf-metric-name"> Skip Rate</span>
            <span class="perf-metric-weight">25%</span>
          </div>
          <div class="perf-metric-description">
            Measures the percentage of assigned leader slots where the validator failed to produce a block. 
            Lower is better.
          </div>
          <div class="perf-metric-scoring">
            <div class="perf-metric-scoring-title">Scoring</div>
            <div class="perf-metric-scoring-detail">
              0% = 100  0.1% = 98  0.25% = 95  0.5% = 90  1% = 82  2% = 70
            </div>
          </div>
        </div>
        
        <div class="perf-metric-item">
          <div class="perf-metric-header">
            <span class="perf-metric-name"> Consistency</span>
            <span class="perf-metric-weight">20%</span>
          </div>
          <div class="perf-metric-description">
            Measures how stable the validator's epoch credit earnings are over the last 7 epochs using Coefficient of Variation.
            Consistent validators are more predictable and reliable.
          </div>
          <div class="perf-metric-scoring">
            <div class="perf-metric-scoring-title">Scoring</div>
            <div class="perf-metric-scoring-detail">
              CV 0.5% = 96  CV 1% = 92  CV 2% = 85  CV 3% = 75  CV 5% = 60
            </div>
          </div>
        </div>
        
        <div class="perf-metric-item">
          <div class="perf-metric-header">
            <span class="perf-metric-name"> Commission</span>
            <span class="perf-metric-weight">5%</span>
          </div>
          <div class="perf-metric-description">
            The validator's commission rate directly affects delegator returns. 
            Lower commission = more rewards for delegators.
          </div>
          <div class="perf-metric-scoring">
            <div class="perf-metric-scoring-title">Scoring</div>
            <div class="perf-metric-scoring-detail">
              0% commission = 100  10% = 90  50% = 50  100% = 0
            </div>
          </div>
        </div>
        
        <div class="perf-metric-item">
          <div class="perf-metric-header">
            <span class="perf-metric-name"> Longevity</span>
            <span class="perf-metric-weight">5%</span>
          </div>
          <div class="perf-metric-description">
            How long the validator has been active on the network. Established validators 
            with a proven track record are generally more reliable than newer ones.
          </div>
          <div class="perf-metric-scoring">
            <div class="perf-metric-scoring-title">Scoring</div>
            <div class="perf-metric-scoring-detail">
              100+ epochs = 100  50+ = 90  30+ = 80  20+ = 70  10+ = 60  5+ = 50  &lt;5 = 40
            </div>
          </div>
        </div>
        
        <div class="perf-metric-item">
          <div class="perf-metric-header">
            <span class="perf-metric-name"> Software Version</span>
            <span class="perf-metric-weight">5%</span>
          </div>
          <div class="perf-metric-description">
            Whether the validator is running the latest software version. Staying updated 
            ensures compatibility, security patches, and network improvements.
          </div>
          <div class="perf-metric-scoring">
            <div class="perf-metric-scoring-title">Scoring</div>
            <div class="perf-metric-scoring-detail">
              Latest version = 100  1 behind = 85  2 behind = 60  3+ behind = 30  Major behind = 40
            </div>
          </div>
        </div>
        
        <div class="perf-metric-item">
          <div class="perf-metric-header">
            <span class="perf-metric-name"> Reliability</span>
            <span class="perf-metric-weight">10%</span>
          </div>
          <div class="perf-metric-description">
            Measures operational reliability through uptime history and consistent performance.
            Uptime is tracked over time for more accurate historical measurement.
          </div>
          <div class="perf-metric-scoring">
            <div class="perf-metric-scoring-title">Scoring</div>
            <div class="perf-metric-scoring-detail">
              +50 points: High uptime history (98%+ tracked observations)<br>
              +50 points: Consistent performance (80%+ credits in all 7 epochs)
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Stake Breakdown Modal -->
  <div class="modal-overlay" id="stakeBreakdownModal" style="display: none;" onclick="if(event.target === this) closeStakeBreakdown()">
    <div class="modal-content stake-breakdown-modal">
      <div class="modal-header">
        <h2> Stake Breakdown</h2>
        <button class="modal-close" onclick="closeStakeBreakdown()">&times;</button>
      </div>
      <div class="modal-body" id="stakeBreakdownBody">
        <div class="stake-breakdown-loading">
          <div class="loading-spinner-small"></div>
          <span>Analyzing stake accounts...</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Stake Selection Modal -->
  <div class="modal-overlay" id="stakeSelectionModal" style="display: none;" onclick="if(event.target === this) closeStakeSelection()">
    <div class="modal-content stake-selection-modal">
      <div class="modal-header">
        <h2> Manage Stake Classification</h2>
        <button class="modal-close" onclick="closeStakeSelection()">&times;</button>
      </div>
      <div class="modal-body" id="stakeSelectionBody">
        <div class="stake-selection-loading">
          <div class="loading-spinner-small"></div>
          <span>Loading stake accounts...</span>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <p>Built for the X1 Blockchain community</p>
  </footer>

  <script>
    const RPC_URL = 'https://rpc.mainnet.x1.xyz';
    const REWARDS_API_URL = null; // Set to your API URL when rewards tracker is running
    
    let allValidators = [];
    let validatorInfoCache = {};
    let myPortfolio = JSON.parse(localStorage.getItem('x1Portfolio') || '[]');
    let rewardsHistory = {};
    let inflationRewardsCache = {}; // Cache for inflation rewards by vote account
    let currentEpochNumber = null;

    // Persistent cache for self-stake account pubkeys (survives page reloads and epoch transitions)
    const SELF_STAKE_SELECTIONS_KEY = 'x1SelfStakeSelections';
    
    function loadSelfStakeSelections() {
      try {
        return JSON.parse(localStorage.getItem(SELF_STAKE_SELECTIONS_KEY) || '{}');
      } catch (e) {
        return {};
      }
    }
    
    function saveSelfStakeSelections(selections) {
      try {
        localStorage.setItem(SELF_STAKE_SELECTIONS_KEY, JSON.stringify(selections));
      } catch (e) {
        console.warn('Could not save self-stake selections:', e);
      }
    }
    
    // Get user-selected self-stake pubkeys for a validator
    function getSelfStakeSelections(voteAccount) {
      const selections = loadSelfStakeSelections();
      return selections[voteAccount] || null;
    }
    
    // Save user-selected self-stake pubkeys for a validator
    function setSelfStakeSelections(voteAccount, pubkeys) {
      const selections = loadSelfStakeSelections();
      selections[voteAccount] = {
        pubkeys: pubkeys,
        timestamp: Date.now()
      };
      saveSelfStakeSelections(selections);
    }

    // Legacy cache functions (for backwards compatibility)
    const SELF_STAKE_CACHE_KEY = 'x1SelfStakeAccounts';
    
    function loadSelfStakeCache() {
      try {
        return JSON.parse(localStorage.getItem(SELF_STAKE_CACHE_KEY) || '{}');
      } catch (e) {
        return {};
      }
    }
    
    function saveSelfStakeCache(cache) {
      try {
        localStorage.setItem(SELF_STAKE_CACHE_KEY, JSON.stringify(cache));
      } catch (e) {
        console.warn('Could not save self-stake cache:', e);
      }
    }
    
    // Save detected self-stake pubkeys for a validator
    function cacheSelfStakePubkeys(voteAccount, selfStakePubkeys, detectionMethod) {
      const cache = loadSelfStakeCache();
      cache[voteAccount] = {
        pubkeys: selfStakePubkeys,
        detectionMethod: detectionMethod,
        timestamp: Date.now(),
        epoch: currentEpochNumber
      };
      saveSelfStakeCache(cache);
    }
    
    // Get cached self-stake pubkeys for a validator
    function getCachedSelfStakePubkeys(voteAccount) {
      const cache = loadSelfStakeCache();
      const entry = cache[voteAccount];
      // Cache is valid for 7 days (stake relationships rarely change)
      if (entry && entry.timestamp > Date.now() - (7 * 24 * 60 * 60 * 1000)) {
        return entry;
      }
      return null;
    }

    // Fetch inflation rewards for a vote account across recent epochs
    async function fetchInflationRewards(voteAccount, numEpochs = 30) {
      // Check cache first - include numEpochs in cache key
      const cacheKey = `${voteAccount}-${numEpochs}`;
      const cached = inflationRewardsCache[cacheKey];
      if (cached && cached.timestamp > Date.now() - 300000) { // 5 min cache
        return cached.data;
      }
      
      try {
        // Always fetch fresh epoch info to ensure we have the current epoch
        const epochInfo = await rpcCall('getEpochInfo');
        currentEpochNumber = epochInfo.epoch;
        
        // Fetch all epochs (starting from currentEpoch - 1)
        const epochsToFetch = [];
        for (let i = 1; i <= Math.min(numEpochs, currentEpochNumber); i++) {
          epochsToFetch.push(currentEpochNumber - i);
        }
        
        // Batch requests to avoid overwhelming RPC (50 at a time)
        const batchSize = 50;
        const allRewards = [];
        
        for (let i = 0; i < epochsToFetch.length; i += batchSize) {
          const batch = epochsToFetch.slice(i, i + batchSize);
          
          const epochPromises = batch.map(async (epoch) => {
            try {
              const response = await fetch(RPC_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 1,
                  method: 'getInflationReward',
                  params: [[voteAccount], { epoch: epoch }]
                })
              });
              
              const data = await response.json();
              if (data.result && data.result[0]) {
                return {
                  epoch: epoch,
                  amount: data.result[0].amount,
                  postBalance: data.result[0].postBalance,
                  commission: data.result[0].commission
                };
              }
              return null;
            } catch (e) {
              console.warn(`Failed to fetch reward for epoch ${epoch}:`, e);
              return null;
            }
          });
          
          const batchResults = await Promise.all(epochPromises);
          allRewards.push(...batchResults.filter(r => r !== null));
        }
        
        // Sort by epoch descending (most recent first)
        allRewards.sort((a, b) => b.epoch - a.epoch);
        
        // Cache the results
        inflationRewardsCache[cacheKey] = {
          timestamp: Date.now(),
          data: allRewards
        };
        
        return allRewards;
      } catch (e) {
        console.error('Error fetching inflation rewards:', e);
        return [];
      }
    }

    // Get cached inflation rewards or empty array
    function getCachedInflationRewards(voteAccount) {
      const cached = inflationRewardsCache[voteAccount];
      return cached ? cached.data : [];
    }

    // Cache for total validator rewards (vote + self-stake)
    let totalRewardsCache = {};

    // Fetch TOTAL validator rewards (vote account commission + self-stake rewards)
    async function fetchTotalValidatorRewards(voteAccount, commission, numEpochs = 30) {
      // Check cache first
      const cacheKey = `${voteAccount}_total_${numEpochs}`;
      const cached = totalRewardsCache[cacheKey];
      if (cached && cached.timestamp > Date.now() - 300000) { // 5 min cache
        return cached.data;
      }

      try {
        // Always fetch fresh epoch info to ensure we have the current epoch
        const epochInfo = await rpcCall('getEpochInfo');
        currentEpochNumber = epochInfo.epoch;

        // Step 1: Fetch vote account rewards (commission) in parallel
        // Start from currentEpoch - 1 to exclude the current incomplete epoch
        const epochsToFetch = [];
        for (let i = 1; i <= Math.min(numEpochs, currentEpochNumber); i++) {
          epochsToFetch.push(currentEpochNumber - i);
        }

        const voteRewardsPromises = epochsToFetch.map(async (epoch) => {
          try {
            const response = await fetch(RPC_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: '2.0',
                id: 1,
                method: 'getInflationReward',
                params: [[voteAccount], { epoch: epoch }]
              })
            });
            const data = await response.json();
            if (data.result && data.result[0]) {
              return { epoch, amount: data.result[0].amount || 0 };
            }
            return { epoch, amount: 0 };
          } catch (e) {
            return { epoch, amount: 0 };
          }
        });

        // Step 2: Fetch vote account info to get authorizedWithdrawer
        let voteAccountWithdrawer = null;
        try {
          const voteAcctResponse = await fetch(RPC_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'getAccountInfo',
              params: [voteAccount, { encoding: 'jsonParsed' }]
            })
          });
          const voteAcctData = await voteAcctResponse.json();
          if (voteAcctData.result?.value?.data?.parsed?.info) {
            voteAccountWithdrawer = voteAcctData.result.value.data.parsed.info.authorizedWithdrawer;
          }
        } catch (e) {
          console.warn('Could not fetch vote account withdrawer:', e);
        }

        // Step 3: Fetch stake accounts delegated to this validator
        const stakeResponse = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getProgramAccounts',
            params: [
              'Stake11111111111111111111111111111111111111',
              {
                encoding: 'jsonParsed',
                filters: [{ memcmp: { offset: 124, bytes: voteAccount } }]
              }
            ]
          })
        });
        const stakeData = await stakeResponse.json();

        // Wait for vote rewards
        const voteRewardsResults = await Promise.all(voteRewardsPromises);
        
        // Build vote rewards map by epoch
        const rewardsByEpoch = {};
        voteRewardsResults.forEach(r => {
          rewardsByEpoch[r.epoch] = r.amount;
        });

        // Step 4: Identify self-stake accounts using WITHDRAWER MATCHING
        // (same method as stake breakdown - much more accurate than reward rate analysis)
        let selfStakeAccounts = [];
        
        if (stakeData.result && stakeData.result.length > 0 && voteAccountWithdrawer) {
          // Check for user selections first
          const userSelections = typeof getSelfStakeSelections === 'function' ? getSelfStakeSelections(voteAccount) : null;
          
          if (userSelections && userSelections.pubkeys && userSelections.pubkeys.length > 0) {
            // Use user-selected self-stake accounts
            selfStakeAccounts = userSelections.pubkeys;
            console.log(`[${voteAccount.slice(0,8)}] Using ${selfStakeAccounts.length} user-selected self-stake accounts`);
          } else {
            // Match stake account withdrawers against vote account withdrawer
            for (const acc of stakeData.result) {
              const stakeInfo = acc.account.data.parsed?.info;
              const stakeWithdrawer = stakeInfo?.meta?.authorized?.withdrawer;
              
              if (stakeWithdrawer === voteAccountWithdrawer) {
                selfStakeAccounts.push(acc.pubkey);
              }
            }
            console.log(`[${voteAccount.slice(0,8)}] Found ${selfStakeAccounts.length} self-stake accounts out of ${stakeData.result.length} total delegated (vote withdrawer: ${voteAccountWithdrawer?.slice(0,8)})`);
          }
        } else {
          console.log(`[${voteAccount.slice(0,8)}] No stake accounts or no withdrawer - stakeData: ${stakeData.result?.length || 0}, withdrawer: ${voteAccountWithdrawer?.slice(0,8) || 'null'}`);
        }

        // Step 5: If we have self-stake accounts, fetch their rewards for all epochs
        if (selfStakeAccounts.length > 0) {
          // Batch epochs to avoid too many parallel requests
          const batchSize = 50;
          
          for (let i = 0; i < epochsToFetch.length; i += batchSize) {
            const batchEpochs = epochsToFetch.slice(i, i + batchSize);
            
            const selfStakePromises = batchEpochs.map(async (epoch) => {
              try {
                const response = await fetch(RPC_URL, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getInflationReward',
                    params: [selfStakeAccounts, { epoch: epoch }]
                  })
                });
                const data = await response.json();
                if (data.result) {
                  // Sum up all self-stake rewards for this epoch
                  let totalSelfStakeReward = 0;
                  data.result.forEach(r => {
                    if (r && r.amount) totalSelfStakeReward += r.amount;
                  });
                  return { epoch, amount: totalSelfStakeReward };
                }
                return { epoch, amount: 0 };
              } catch (e) {
                return { epoch, amount: 0 };
              }
            });

            const selfStakeResults = await Promise.all(selfStakePromises);
            
            // Add self-stake rewards to vote rewards
            selfStakeResults.forEach(r => {
              if (rewardsByEpoch[r.epoch] !== undefined) {
                rewardsByEpoch[r.epoch] += r.amount;
              } else {
                rewardsByEpoch[r.epoch] = r.amount;
              }
            });
          }
        }

        // Step 6: Build final rewards array (sorted descending - most recent first)
        const rewards = Object.entries(rewardsByEpoch)
          .map(([epoch, amount]) => ({
            epoch: parseInt(epoch),
            amount: amount,
            postBalance: 0,
            commission: commission
          }))
          .sort((a, b) => b.epoch - a.epoch);

        // Cache the results (only if we got data)
        if (rewards.length > 0) {
          totalRewardsCache[cacheKey] = {
            timestamp: Date.now(),
            data: rewards
          };
        }

        console.log(`Total rewards for ${voteAccount.slice(0,8)}...: vote + ${selfStakeAccounts.length} self-stake accounts, ${rewards.length} epochs`);
        
        return rewards;
      } catch (e) {
        console.error('Error fetching total validator rewards:', e);
        // Fallback to just vote account rewards
        return fetchInflationRewards(voteAccount, numEpochs);
      }
    }

    function formatNumber(num, decimals = 2) {
      if (num === null || num === undefined || isNaN(num)) return '0.00';
      return parseFloat(num).toLocaleString('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals
      });
    }

    function copyToClipboard(text, buttonEl) {
      navigator.clipboard.writeText(text).then(() => {
        // Visual feedback
        if (buttonEl) {
          buttonEl.classList.add('copied');
          const originalTitle = buttonEl.title;
          buttonEl.title = 'Copied!';
          
          // Change icon to checkmark temporarily
          const originalSvg = buttonEl.innerHTML;
          buttonEl.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="20 6 9 17 4 12"></polyline>
          </svg>`;
          
          setTimeout(() => {
            buttonEl.classList.remove('copied');
            buttonEl.title = originalTitle;
            buttonEl.innerHTML = originalSvg;
          }, 1500);
        }
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }

    // Generate a copy button HTML
    function getCopyButtonHtml(address) {
      return `<button class="copy-address-btn" onclick="event.stopPropagation(); copyToClipboard('${address}', this)" title="Copy address">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
      </button>`;
    }

    function formatCompact(num) {
      if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      return num.toFixed(0);
    }

    function formatStake(lamports) {
      const xnt = lamports / 1e9;
      if (xnt >= 1e6) return (xnt / 1e6).toFixed(2) + 'M';
      if (xnt >= 1e3) return (xnt / 1e3).toFixed(1) + 'K';
      return xnt.toFixed(0);
    }
    
    // Format XNT values compactly for display (input is already in XNT, not lamports)
    function formatXntCompact(xnt) {
      if (xnt === null || xnt === undefined || isNaN(xnt)) return '0';
      if (xnt >= 1e6) return (xnt / 1e6).toFixed(2) + 'M';
      if (xnt >= 1e3) return formatNumber(xnt, 1);
      return formatNumber(xnt, 2);
    }

    function lamportsToXNT(lamports) {
      return lamports / 1e9;
    }

    // Compare semantic version strings (e.g., "2.2.18" vs "2.2.19")
    function compareVersions(a, b) {
      if (!a) return -1;
      if (!b) return 1;
      const partsA = a.split('.').map(n => parseInt(n) || 0);
      const partsB = b.split('.').map(n => parseInt(n) || 0);
      for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
        const numA = partsA[i] || 0;
        const numB = partsB[i] || 0;
        if (numA < numB) return -1;
        if (numA > numB) return 1;
      }
      return 0;
    }

    // Check if a version is outdated compared to the latest
    function isVersionOutdated(version) {
      if (!version || !window.latestValidatorVersion) return false;
      return compareVersions(version, window.latestValidatorVersion) < 0;
    }
    
    // Get version status with gradient scoring
    function getVersionStatus(version) {
      if (!version) {
        return { score: 50, details: 'Unknown version' };
      }
      
      if (!window.latestValidatorVersion) {
        return { score: 75, details: `v${version}` };
      }
      
      const comparison = compareVersions(version, window.latestValidatorVersion);
      
      if (comparison >= 0) {
        // Latest or newer
        return { score: 100, details: `v${version} ` };
      }
      
      // Calculate how many minor versions behind
      const currentParts = version.split('.').map(n => parseInt(n) || 0);
      const latestParts = window.latestValidatorVersion.split('.').map(n => parseInt(n) || 0);
      
      // Major version difference is critical
      if (currentParts[0] < latestParts[0]) {
        const majorDiff = latestParts[0] - currentParts[0];
        if (majorDiff >= 2) {
          return { score: 20, details: `v${version} (very outdated)` };
        }
        return { score: 40, details: `v${version} (major behind)` };
      }
      
      // Minor version difference
      const minorDiff = (latestParts[1] || 0) - (currentParts[1] || 0);
      
      if (minorDiff <= 1) {
        return { score: 85, details: `v${version} (1 behind)` };
      } else if (minorDiff <= 2) {
        return { score: 60, details: `v${version} (2 behind)` };
      } else {
        return { score: 30, details: `v${version} (3+ behind)` };
      }
    }

    async function rpcCall(method, params = []) {
      const response = await fetch(RPC_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: method,
          params: params
        })
      });
      const data = await response.json();
      if (data.error) throw new Error(data.error.message);
      return data.result;
    }

    // Fetch rewards history from tracker API
    async function fetchRewardsHistory() {
      if (!REWARDS_API_URL) return null;
      
      try {
        const response = await fetch(`${REWARDS_API_URL}/api/validators`);
        const data = await response.json();
        if (data.success) {
          rewardsHistory = data.validators;
          return data;
        }
      } catch (err) {
        console.warn('Could not fetch rewards history:', err.message);
      }
      return null;
    }

    // Get rewards history for a specific validator
    function getValidatorRewardsHistory(voteAccount) {
      if (rewardsHistory[voteAccount]) {
        return rewardsHistory[voteAccount].history || [];
      }
      return [];
    }

    // Fetch validator identity name from config account
    async function fetchValidatorIdentities() {
      try {
        // Fetch validator info accounts from config program
        const configProgramId = 'Config1111111111111111111111111111111111111';
        const accounts = await rpcCall('getProgramAccounts', [
          configProgramId,
          {
            encoding: 'jsonParsed',
            filters: [{ dataSize: 643 }] // Validator info account size
          }
        ]);

        const identities = {};
        
        for (const account of accounts) {
          try {
            const data = account.account.data;
            if (data.parsed && data.parsed.info) {
              const info = data.parsed.info;
              if (info.configData && info.keys) {
                const identityKey = info.keys.find(k => k.signer);
                if (identityKey && info.configData.name) {
                  const cfg = info.configData;
                  
                  // Try direct icon URL fields first
                  let iconUrl = cfg.iconUrl || 
                                cfg.icon_url || 
                                cfg.iconURL ||
                                cfg.icon ||
                                cfg.image ||
                                cfg.logo || '';
                  
                  // Check for keybase username
                  const keybase = cfg.keybaseUsername || 
                                  cfg.keybase || '';
                  if (!iconUrl && keybase) {
                    iconUrl = `https://keybase.io/${keybase}/picture`;
                  }
                  
                  // Parse details field - it may contain JSON with image URL
                  if (!iconUrl && cfg.details) {
                    try {
                      // Details might be a JSON string
                      const detailsObj = typeof cfg.details === 'string' 
                        ? JSON.parse(cfg.details) 
                        : cfg.details;
                      iconUrl = detailsObj.image || 
                                detailsObj.icon || 
                                detailsObj.logo || 
                                detailsObj.iconUrl || 
                                detailsObj.avatar || '';
                    } catch (e) {
                      // Details is not valid JSON, ignore
                    }
                  }
                  
                  identities[identityKey.pubkey] = {
                    name: cfg.name,
                    website: cfg.website || '',
                    details: cfg.details || '',
                    iconUrl: iconUrl
                  };
                }
              }
            }
          } catch (e) {
            // Skip malformed accounts
          }
        }
        
        return identities;
      } catch (err) {
        console.error('Failed to fetch validator identities:', err);
        return {};
      }
    }

    // Fetch network stats and all validators
    async function loadNetworkStats() {
      try {
        const [voteAccounts, epochInfo, slot, identities, clusterNodes, supply] = await Promise.all([
          rpcCall('getVoteAccounts'),
          rpcCall('getEpochInfo'),
          rpcCall('getSlot'),
          fetchValidatorIdentities(),
          rpcCall('getClusterNodes').catch(() => []),
          rpcCall('getSupply').catch(() => null)
        ]);

        // Build version map from cluster nodes
        const versionMap = {};
        clusterNodes.forEach(node => {
          if (node.pubkey && node.version) {
            versionMap[node.pubkey] = node.version;
          }
        });

        // Determine the latest validator version
        const allVersions = Object.values(versionMap).filter(v => v);
        window.latestValidatorVersion = allVersions.length > 0 
          ? allVersions.sort(compareVersions).pop() 
          : null;

        const currentValidators = voteAccounts.current || [];
        const delinquentValidators = voteAccounts.delinquent || [];
        const totalValidatorsCount = currentValidators.length + delinquentValidators.length;
        
        let totalStake = 0;
        const allValidatorsList = [...currentValidators, ...delinquentValidators];
        allValidatorsList.forEach(v => {
          totalStake += v.activatedStake;
        });

        // Sort by stake for nakamoto calculation
        const sortedByStake = [...allValidatorsList].sort((a, b) => b.activatedStake - a.activatedStake);
        
        // Calculate Nakamoto Coefficient (min validators to reach 33.33% of stake)
        let cumulativeStake = 0;
        let nakamotoCoef = 0;
        const superminorityThreshold = totalStake * 0.3333;
        for (const v of sortedByStake) {
          cumulativeStake += v.activatedStake;
          nakamotoCoef++;
          if (cumulativeStake >= superminorityThreshold) {
            break;
          }
        }

        document.getElementById('totalValidators').textContent = totalValidatorsCount;
        document.getElementById('totalStake').textContent = formatCompact(lamportsToXNT(totalStake));
        document.getElementById('currentEpoch').textContent = epochInfo.epoch;
        document.getElementById('currentSlot').textContent = formatCompact(slot);
        document.getElementById('activeValidators').textContent = currentValidators.length;
        document.getElementById('delinquentValidators').textContent = delinquentValidators.length;
        document.getElementById('nakamotoCoef').textContent = nakamotoCoef;
        
        // Total supply
        if (supply && supply.value) {
          document.getElementById('totalSupply').textContent = formatCompact(lamportsToXNT(supply.value.total));
        }

        // Calculate epoch progress
        const epochProgress = (epochInfo.slotIndex / epochInfo.slotsInEpoch) * 100;
        const remainingSlots = epochInfo.slotsInEpoch - epochInfo.slotIndex;
        const secondsRemaining = remainingSlots * 0.4; // ~400ms per slot
        
        // Format time remaining
        const hours = Math.floor(secondsRemaining / 3600);
        const minutes = Math.floor((secondsRemaining % 3600) / 60);
        let timeString = '';
        if (hours > 0) {
          timeString = `${hours}h ${minutes}m`;
        } else {
          timeString = `${minutes}m`;
        }

        // Update epoch progress UI
        document.getElementById('epochProgressFill').style.width = epochProgress + '%';
        document.getElementById('epochPercent').textContent = epochProgress.toFixed(1) + '%';
        document.getElementById('epochTimeRemaining').textContent = timeString;

        // Build all validators list with names
        allValidators = [...currentValidators, ...delinquentValidators].map(v => {
          const identity = identities[v.nodePubkey];
          return {
            votePubkey: v.votePubkey,
            nodePubkey: v.nodePubkey,
            name: identity ? identity.name : v.nodePubkey.slice(0, 16) + '...',
            website: identity ? identity.website : '',
            iconUrl: identity ? identity.iconUrl : '',
            activatedStake: v.activatedStake,
            commission: v.commission,
            epochCredits: v.epochCredits,
            delinquent: delinquentValidators.some(d => d.votePubkey === v.votePubkey),
            version: versionMap[v.nodePubkey] || null
          };
        });

        // Sort by stake descending to get ranks
        allValidators.sort((a, b) => b.activatedStake - a.activatedStake);
        allValidators.forEach((v, i) => {
          v.rank = i + 1;
          v.totalValidators = totalValidatorsCount;
        });

        // Calculate network average credits for performance scoring
        calculateNetworkAverageCredits();
        
        // Update uptime tracking for all validators
        updateUptimeTracking(allValidators);
        
        // Fetch skip rates for all validators
        await fetchAllSkipRates();
        
        updatePortfolioCount();

      } catch (err) {
        console.error('Failed to load network stats:', err);
      }
    }

    async function getValidatorInfo(voteAccount, forceRefresh = false) {
      // Check cache
      if (!forceRefresh && validatorInfoCache[voteAccount]) {
        return validatorInfoCache[voteAccount];
      }

      // Check if we have it in allValidators
      let validator = allValidators.find(v => v.votePubkey === voteAccount);
      let rank, totalValidators;
      
      if (validator) {
        // Get fresh rank from allValidators (already sorted by stake)
        rank = allValidators.findIndex(v => v.votePubkey === voteAccount) + 1;
        totalValidators = allValidators.length;
      } else {
        // Fetch fresh
        const voteAccounts = await rpcCall('getVoteAccounts');
        const all = [...voteAccounts.current, ...voteAccounts.delinquent];
        validator = all.find(v => v.votePubkey === voteAccount);
        if (!validator) return null;
        
        validator.delinquent = voteAccounts.delinquent.some(v => v.votePubkey === voteAccount);
        
        // Calculate rank
        all.sort((a, b) => b.activatedStake - a.activatedStake);
        rank = all.findIndex(v => v.votePubkey === voteAccount) + 1;
        totalValidators = all.length;
      }

      // Get balance (rewards)
      const balance = await rpcCall('getBalance', [voteAccount]);
      
      // Try to get extended epoch credits history
      let extendedEpochCredits = await fetchExtendedEpochCredits(voteAccount);
      const epochCreditsHistory = extendedEpochCredits || validator.epochCredits || [];
      
      // Fetch skip rate from block production (current epoch)
      const skipRate = await fetchSkipRate(validator.nodePubkey);
      
      // Fetch historical skip rates (past 7 epochs)
      const skipRateHistory = await fetchHistoricalSkipRates(validator.nodePubkey, 7);
      
      const info = {
        name: validator.name || validator.nodePubkey.slice(0, 8) + '...',
        voteAccount: voteAccount,
        nodePubkey: validator.nodePubkey,
        iconUrl: validator.iconUrl || '',
        activatedStake: lamportsToXNT(validator.activatedStake),
        rewardsBalance: lamportsToXNT(balance.value),
        commission: validator.commission,
        isDelinquent: validator.delinquent,
        epochCredits: epochCreditsHistory.length > 0 ? epochCreditsHistory[epochCreditsHistory.length - 1][1] : 0,
        epochCreditsHistory: epochCreditsHistory,
        skipRate: skipRate,
        skipRateHistory: skipRateHistory,
        rank: rank,
        totalValidators: totalValidators,
        version: validator.version || null
      };
      
      // Calculate and cache performance score for consistency
      info.performanceScore = calculatePerformanceScore(info);

      // Cache it
      validatorInfoCache[voteAccount] = info;
      return info;
    }

    // Fetch extended epoch credits history using getAccountInfo (returns more epochs than getVoteAccounts)
    async function fetchExtendedEpochCredits(voteAccount) {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAccountInfo',
            params: [voteAccount, { encoding: 'jsonParsed' }]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value && data.result.value.data && data.result.value.data.parsed) {
          const parsed = data.result.value.data.parsed;
          if (parsed.info && parsed.info.epochCredits) {
            // epochCredits format: array of { credits, epoch, previousCredits }
            // Convert to our format: [epoch, credits, previousCredits]
            return parsed.info.epochCredits.map(entry => [
              entry.epoch,
              entry.credits,
              entry.previousCredits
            ]);
          }
        }
        return null;
      } catch (e) {
        console.error('Error fetching extended epoch credits:', e);
        return null;
      }
    }

    // Fetch skip rate from block production data
    async function fetchSkipRate(nodePubkey) {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBlockProduction',
            params: [{ identity: nodePubkey }]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value && data.result.value.byIdentity) {
          const production = data.result.value.byIdentity[nodePubkey];
          if (production && production.length >= 2) {
            const leaderSlots = production[0];
            const blocksProduced = production[1];
            if (leaderSlots > 0) {
              return ((leaderSlots - blocksProduced) / leaderSlots) * 100;
            } else {
              return null; // No leader slots assigned yet
            }
          }
        }
        return null;
      } catch (e) {
        console.error('Error fetching skip rate:', e);
        return null;
      }
    }

    // Cache for historical skip rates per validator
    let skipRateHistoryCache = {};

    // Fetch skip rate for a specific slot range
    async function fetchSkipRateForSlotRange(nodePubkey, firstSlot, lastSlot) {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBlockProduction',
            params: [{ 
              identity: nodePubkey,
              range: { firstSlot, lastSlot }
            }]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value && data.result.value.byIdentity) {
          const production = data.result.value.byIdentity[nodePubkey];
          if (production && production.length >= 2) {
            const leaderSlots = production[0];
            const blocksProduced = production[1];
            if (leaderSlots > 0) {
              return {
                skipRate: ((leaderSlots - blocksProduced) / leaderSlots) * 100,
                leaderSlots,
                blocksProduced
              };
            }
          }
        }
        return null;
      } catch (e) {
        return null;
      }
    }

    // Fetch historical skip rates for past epochs
    async function fetchHistoricalSkipRates(nodePubkey, numEpochs = 5) {
      // Check cache
      const cacheKey = nodePubkey;
      const cached = skipRateHistoryCache[cacheKey];
      if (cached && cached.timestamp > Date.now() - 300000) { // 5 min cache
        return cached.data;
      }

      try {
        // Get epoch info
        const epochInfo = await rpcCall('getEpochInfo');
        const currentEpoch = epochInfo.epoch;
        const slotsPerEpoch = epochInfo.slotsInEpoch;
        const currentSlot = epochInfo.absoluteSlot;
        const slotIndex = epochInfo.slotIndex; // How far into current epoch
        
        // Calculate first slot of current epoch
        const firstSlotOfCurrentEpoch = currentSlot - slotIndex;
        
        // Fetch skip rates for past completed epochs in parallel
        const epochPromises = [];
        for (let i = 1; i <= numEpochs; i++) {
          const epochNum = currentEpoch - i;
          if (epochNum < 0) continue;
          
          const epochFirstSlot = firstSlotOfCurrentEpoch - (i * slotsPerEpoch);
          const epochLastSlot = epochFirstSlot + slotsPerEpoch - 1;
          
          epochPromises.push(
            fetchSkipRateForSlotRange(nodePubkey, epochFirstSlot, epochLastSlot)
              .then(result => ({ epoch: epochNum, ...result }))
          );
        }
        
        const results = await Promise.all(epochPromises);
        const validResults = results.filter(r => r && r.skipRate !== undefined);
        
        // Calculate average
        let avgSkipRate = null;
        if (validResults.length > 0) {
          avgSkipRate = validResults.reduce((sum, r) => sum + r.skipRate, 0) / validResults.length;
        }
        
        // Get last completed epoch's skip rate
        const lastEpochData = validResults.find(r => r.epoch === currentEpoch - 1);
        
        const historyData = {
          epochs: validResults,
          avgSkipRate,
          lastEpochSkipRate: lastEpochData ? lastEpochData.skipRate : null,
          currentEpoch
        };
        
        // Cache the result
        skipRateHistoryCache[cacheKey] = {
          timestamp: Date.now(),
          data: historyData
        };
        
        return historyData;
      } catch (e) {
        console.error('Error fetching historical skip rates:', e);
        return null;
      }
    }

    // =========================================
    // PERFORMANCE TRACKING SYSTEM
    // =========================================
    
    const PERF_STORAGE_KEY = 'x1ValidatorPerformanceHistory';
    const PERF_HISTORY_DAYS = 7; // Track 7 days of history
    
    // Load performance history from localStorage
    function loadPerformanceHistory() {
      try {
        const stored = localStorage.getItem(PERF_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        console.error('Error loading performance history:', e);
        return {};
      }
    }
    
    // Save performance history to localStorage
    function savePerformanceHistory(history) {
      try {
        localStorage.setItem(PERF_STORAGE_KEY, JSON.stringify(history));
      } catch (e) {
        console.error('Error saving performance history:', e);
      }
    }
    
    // ==========================================
    // VALIDATOR UPTIME TRACKING
    // Tracks delinquency observations over time
    // ==========================================
    const UPTIME_STORAGE_KEY = 'x1ValidatorUptimeHistory';
    let uptimeHistoryCache = null; // Cache to avoid repeated localStorage reads
    
    function loadUptimeHistory() {
      // Return cached version if available
      if (uptimeHistoryCache !== null) {
        return uptimeHistoryCache;
      }
      try {
        const stored = localStorage.getItem(UPTIME_STORAGE_KEY);
        uptimeHistoryCache = stored ? JSON.parse(stored) : {};
        return uptimeHistoryCache;
      } catch (e) {
        uptimeHistoryCache = {};
        return uptimeHistoryCache;
      }
    }
    
    function saveUptimeHistory(history) {
      try {
        uptimeHistoryCache = history; // Update cache
        localStorage.setItem(UPTIME_STORAGE_KEY, JSON.stringify(history));
      } catch (e) {
        console.error('Error saving uptime history:', e);
      }
    }
    
    // Get uptime data for a specific validator
    function getValidatorUptimeHistory(voteAccount) {
      const history = loadUptimeHistory();
      return history[voteAccount] || null;
    }
    
    // Update uptime tracking for all validators (called when validators are loaded)
    function updateUptimeTracking(validators) {
      if (!validators || validators.length === 0) return;
      
      const history = loadUptimeHistory();
      const now = Date.now();
      
      // Only update once per hour to avoid excessive tracking
      const lastUpdate = history._lastUpdate || 0;
      if (now - lastUpdate < 3600000) return; // 1 hour
      
      for (const v of validators) {
        const voteAccount = v.voteAccount || v.votePubkey;
        if (!voteAccount) continue;
        
        if (!history[voteAccount]) {
          history[voteAccount] = {
            observations: 0,
            delinquentCount: 0,
            firstSeen: now,
            lastSeen: now
          };
        }
        
        const record = history[voteAccount];
        record.observations++;
        record.lastSeen = now;
        
        if (v.isDelinquent || v.delinquent) {
          record.delinquentCount++;
        }
      }
      
      history._lastUpdate = now;
      
      // Clean up old entries (not seen in 30 days)
      const cutoff = now - (30 * 24 * 60 * 60 * 1000);
      for (const key of Object.keys(history)) {
        if (key === '_lastUpdate') continue;
        if (history[key].lastSeen < cutoff) {
          delete history[key];
        }
      }
      
      saveUptimeHistory(history);
    }
    
    // Clean up old entries (older than 7 days)
    function cleanupOldHistory(history) {
      const cutoffTime = Date.now() - (PERF_HISTORY_DAYS * 24 * 60 * 60 * 1000);
      
      Object.keys(history).forEach(voteAccount => {
        const validatorHistory = history[voteAccount];
        if (validatorHistory.snapshots) {
          validatorHistory.snapshots = validatorHistory.snapshots.filter(s => s.timestamp > cutoffTime);
        }
        if (validatorHistory.delinquentEvents) {
          validatorHistory.delinquentEvents = validatorHistory.delinquentEvents.filter(e => e.timestamp > cutoffTime);
        }
      });
      
      return history;
    }
    
    // Record a performance snapshot for a validator
    function recordPerformanceSnapshot(validator) {
      const history = loadPerformanceHistory();
      const voteAccount = validator.voteAccount || validator.votePubkey;
      
      if (!voteAccount) return;
      
      if (!history[voteAccount]) {
        history[voteAccount] = {
          snapshots: [],
          delinquentEvents: [],
          lastDelinquentState: false
        };
      }
      
      const validatorHistory = history[voteAccount];
      const now = Date.now();
      
      // Only record one snapshot per hour to avoid bloating storage
      const lastSnapshot = validatorHistory.snapshots[validatorHistory.snapshots.length - 1];
      if (lastSnapshot && (now - lastSnapshot.timestamp) < 3600000) {
        return; // Skip if less than 1 hour since last snapshot
      }
      
      // Record snapshot
      validatorHistory.snapshots.push({
        timestamp: now,
        isDelinquent: validator.isDelinquent || validator.delinquent || false,
        skipRate: validator.skipRate,
        version: validator.version,
        epochCredits: validator.epochCredits
      });
      
      // Track delinquency events
      const isDelinquentNow = validator.isDelinquent || validator.delinquent || false;
      if (isDelinquentNow && !validatorHistory.lastDelinquentState) {
        // Just became delinquent
        validatorHistory.delinquentEvents.push({
          timestamp: now,
          type: 'start'
        });
      } else if (!isDelinquentNow && validatorHistory.lastDelinquentState) {
        // Just recovered from delinquency
        validatorHistory.delinquentEvents.push({
          timestamp: now,
          type: 'end'
        });
      }
      validatorHistory.lastDelinquentState = isDelinquentNow;
      
      // Cleanup and save
      savePerformanceHistory(cleanupOldHistory(history));
    }
    
    // ==========================================
    // PERFORMANCE SCORING SYSTEM v2
    // Absolute scoring - rewards actual performance
    // ==========================================
    
    // Calculate comprehensive performance score
    function calculatePerformanceScore(validator) {
      const breakdown = calculatePerformanceBreakdown(validator);
      return breakdown.totalScore;
    }
    
    // Get detailed performance breakdown - ABSOLUTE SCORING
    function calculatePerformanceBreakdown(validator) {
      const breakdown = {
        voteEfficiency: { score: 85, weight: 0.30, details: '' },
        skipRate: { score: 75, weight: 0.25, details: '' },
        consistency: { score: 85, weight: 0.20, details: '' },
        commission: { score: 90, weight: 0.05, details: '' },
        longevity: { score: 50, weight: 0.05, details: '' },
        softwareVersion: { score: 50, weight: 0.05, details: '' },
        reliability: { score: 0, weight: 0.10, details: '' },
        totalScore: 50
      };
      
      const voteAccount = validator.voteAccount || validator.votePubkey;
      const epochCreditsHistory = validator.epochCreditsHistory || validator.epochCredits || [];
      
      // ==========================================
      // 1. VOTE EFFICIENCY (30%) - Absolute scoring
      // Credits earned vs network average
      // ==========================================
      if (epochCreditsHistory.length >= 2 && window.networkAverageCredits) {
        let totalCredits = 0;
        let epochCount = 0;
        
        // Skip current epoch, use last 7 completed
        for (let i = 1; i < Math.min(epochCreditsHistory.length, 8); i++) {
          const entry = epochCreditsHistory[epochCreditsHistory.length - 1 - i];
          if (entry && entry.length >= 3) {
            const earned = entry[1] - entry[2];
            totalCredits += earned;
            epochCount++;
          }
        }
        
        if (epochCount > 0) {
          const avgCredits = totalCredits / epochCount;
          const efficiency = (avgCredits / window.networkAverageCredits) * 100;
          
          // Absolute scoring: 100% of avg = 90, 105% = 100, 95% = 75
          let score;
          if (efficiency >= 105) score = 100;
          else if (efficiency >= 103) score = 98;
          else if (efficiency >= 101) score = 96;
          else if (efficiency >= 100) score = 93;
          else if (efficiency >= 99) score = 88;
          else if (efficiency >= 98) score = 82;
          else if (efficiency >= 97) score = 75;
          else if (efficiency >= 95) score = 65;
          else if (efficiency >= 93) score = 55;
          else if (efficiency >= 90) score = 45;
          else if (efficiency >= 85) score = 30;
          else if (efficiency >= 80) score = 15;
          else score = 5;
          
          breakdown.voteEfficiency.score = score;
          breakdown.voteEfficiency.details = `${efficiency.toFixed(1)}% of avg`;
        } else {
          breakdown.voteEfficiency.details = 'Insufficient data';
        }
      } else {
        breakdown.voteEfficiency.details = 'Building history...';
      }
      
      // ==========================================
      // 2. SKIP RATE (25%) - Absolute scoring
      // Lower skip rate = higher score
      // ==========================================
      const skipHistory = validator.skipRateHistory;
      let skipRate = null;
      let skipSource = '';
      
      if (skipHistory && skipHistory.avgSkipRate !== null) {
        skipRate = skipHistory.avgSkipRate;
        skipSource = '7-epoch avg';
      } else if (skipHistory && skipHistory.lastEpochSkipRate !== null) {
        skipRate = skipHistory.lastEpochSkipRate;
        skipSource = 'last epoch';
      } else if (validator.skipRate !== null && validator.skipRate !== undefined) {
        skipRate = validator.skipRate;
        skipSource = 'current';
      }
      
      if (skipRate !== null) {
        // Absolute scoring for skip rate - tighter thresholds
        let score;
        if (skipRate === 0) score = 100;
        else if (skipRate <= 0.1) score = 98;
        else if (skipRate <= 0.25) score = 95;
        else if (skipRate <= 0.5) score = 90;
        else if (skipRate <= 1.0) score = 85;
        else if (skipRate <= 2.0) score = 70;
        else if (skipRate <= 3.0) score = 50;
        else if (skipRate <= 5.0) score = 35;
        else if (skipRate <= 10.0) score = 20;
        else score = 10;
        
        breakdown.skipRate.score = score;
        breakdown.skipRate.details = `${skipRate.toFixed(2)}% (${skipSource})`;
      } else {
        breakdown.skipRate.score = 75;
        breakdown.skipRate.details = 'No blocks yet';
      }
      
      // ==========================================
      // 3. CONSISTENCY (20%) - Coefficient of Variation
      // Lower variance in credits over 7 epochs = better
      // ==========================================
      if (epochCreditsHistory.length >= 4) {
        const creditsPerEpoch = [];
        
        // Skip current epoch, use last 7 completed
        for (let i = 1; i < Math.min(epochCreditsHistory.length, 8); i++) {
          const entry = epochCreditsHistory[epochCreditsHistory.length - 1 - i];
          if (entry && entry.length >= 3) {
            const earned = entry[1] - entry[2];
            creditsPerEpoch.push(earned);
          }
        }
        
        if (creditsPerEpoch.length >= 3) {
          const avg = creditsPerEpoch.reduce((sum, c) => sum + c, 0) / creditsPerEpoch.length;
          
          // Calculate standard deviation
          let variance = 0;
          creditsPerEpoch.forEach(c => {
            variance += Math.pow(c - avg, 2);
          });
          variance /= creditsPerEpoch.length;
          const stdDev = Math.sqrt(variance);
          
          // Coefficient of variation (CV) - normalized measure of dispersion
          const cv = avg > 0 ? (stdDev / avg) * 100 : 0;
          
          // Absolute scoring: CV of 0% = 100, CV of 1% = 92, CV of 5% = 60
          let score;
          if (cv <= 0.1) score = 100;
          else if (cv <= 0.3) score = 98;
          else if (cv <= 0.5) score = 96;
          else if (cv <= 1.0) score = 92;
          else if (cv <= 2.0) score = 85;
          else if (cv <= 3.0) score = 75;
          else if (cv <= 5.0) score = 60;
          else if (cv <= 8.0) score = 45;
          else if (cv <= 12.0) score = 30;
          else score = 15;
          
          breakdown.consistency.score = score;
          breakdown.consistency.details = `CV: ${cv.toFixed(2)}% over ${creditsPerEpoch.length} epochs`;
        } else {
          breakdown.consistency.details = 'Need 3+ epochs';
        }
      } else {
        breakdown.consistency.details = 'Building history...';
      }
      
      // ==========================================
      // 4. COMMISSION (10%)
      // 0% = 100, 10% = 90, 100% = 0
      // ==========================================
      const commission = validator.commission || 0;
      const commissionScore = Math.max(0, 100 - commission);
      breakdown.commission.score = commissionScore;
      breakdown.commission.details = `${commission}%`;
      
      // ==========================================
      // 5. LONGEVITY (5%) - Validator Age
      // More epochs = more established, but flatter curve
      // ==========================================
      const epochsActive = epochCreditsHistory.length;
      let longevityScore;
      let longevityTier;
      
      if (epochsActive >= 100) {
        longevityScore = 100;
        longevityTier = 'Veteran';
      } else if (epochsActive >= 50) {
        longevityScore = 90;
        longevityTier = 'Established';
      } else if (epochsActive >= 30) {
        longevityScore = 80;
        longevityTier = 'Mature';
      } else if (epochsActive >= 20) {
        longevityScore = 70;
        longevityTier = 'Experienced';
      } else if (epochsActive >= 10) {
        longevityScore = 60;
        longevityTier = 'Growing';
      } else if (epochsActive >= 5) {
        longevityScore = 50;
        longevityTier = 'New';
      } else {
        longevityScore = 40;
        longevityTier = 'Very New';
      }
      
      breakdown.longevity.score = longevityScore;
      breakdown.longevity.details = `${epochsActive} epochs (${longevityTier})`;
      
      // ==========================================
      // 6. SOFTWARE VERSION (5%)
      // Gradient scoring based on how far behind
      // ==========================================
      if (validator.version) {
        const versionStatus = getVersionStatus(validator.version);
        breakdown.softwareVersion.score = versionStatus.score;
        breakdown.softwareVersion.details = versionStatus.details;
      } else {
        breakdown.softwareVersion.score = 50;
        breakdown.softwareVersion.details = 'Unknown version';
      }
      
      // ==========================================
      // 7. RELIABILITY (10%)
      // +50 for uptime history (tracked over observations)
      // +50 for reliable performance (80%+ credits in all epochs)
      // ==========================================
      let reliabilityScore = 0;
      const reliabilityDetails = [];
      
      // Uptime history check (+50) - uses tracked delinquency over time
      const isDelinquent = validator.isDelinquent || validator.delinquent || false;
      const uptimeData = getValidatorUptimeHistory(voteAccount);
      
      if (uptimeData && uptimeData.observations >= 5) {
        // Have enough observations, use historical uptime
        const uptimePercent = ((uptimeData.observations - uptimeData.delinquentCount) / uptimeData.observations) * 100;
        if (uptimePercent >= 98) {
          reliabilityScore += 50;
          reliabilityDetails.push(` ${uptimePercent.toFixed(0)}% uptime`);
        } else if (uptimePercent >= 90) {
          reliabilityScore += Math.round(50 * (uptimePercent / 100));
          reliabilityDetails.push(` ${uptimePercent.toFixed(0)}% uptime`);
        } else {
          reliabilityDetails.push(` ${uptimePercent.toFixed(0)}% uptime`);
        }
      } else {
        // Not enough history, use current status
        if (!isDelinquent) {
          reliabilityScore += 50;
          reliabilityDetails.push(' Active');
        } else {
          reliabilityDetails.push(' Delinquent');
        }
      }
      
      // Reliable performance check (+50) - all epochs at 80%+ of network average
      if (epochCreditsHistory.length >= 3 && window.networkEpochCredits) {
        let allGood = true;
        let checkedEpochs = 0;
        
        for (let i = 1; i < Math.min(epochCreditsHistory.length, 8); i++) {
          const entry = epochCreditsHistory[epochCreditsHistory.length - 1 - i];
          if (!entry || entry.length < 3) continue;
          
          const epoch = entry[0];
          const creditsEarned = entry[1] - entry[2];
          const networkAvg = window.networkEpochCredits[epoch];
          
          if (networkAvg && networkAvg > 0) {
            checkedEpochs++;
            const ratio = creditsEarned / networkAvg;
            if (ratio < 0.80) {
              allGood = false;
              break;
            }
          }
        }
        
        if (allGood && checkedEpochs >= 3) {
          reliabilityScore += 50;
          reliabilityDetails.push(' Consistent');
        } else {
          reliabilityDetails.push(' Gaps');
        }
      } else {
        reliabilityDetails.push('? History');
      }
      
      breakdown.reliability.score = reliabilityScore;
      breakdown.reliability.details = reliabilityDetails.join(' ');
      
      // ==========================================
      // CALCULATE TOTAL SCORE
      // ==========================================
      breakdown.totalScore = 
        (breakdown.voteEfficiency.score * breakdown.voteEfficiency.weight) +
        (breakdown.skipRate.score * breakdown.skipRate.weight) +
        (breakdown.consistency.score * breakdown.consistency.weight) +
        (breakdown.commission.score * breakdown.commission.weight) +
        (breakdown.longevity.score * breakdown.longevity.weight) +
        (breakdown.softwareVersion.score * breakdown.softwareVersion.weight) +
        (breakdown.reliability.score * breakdown.reliability.weight);
      
      // Round to 2 decimal places for more separation
      breakdown.totalScore = Math.round(Math.max(0, Math.min(100, breakdown.totalScore)) * 100) / 100;
      
      return breakdown;
    }
    
    // ==========================================
    // LEGACY PERFORMANCE SCORING (kept for rollback)
    // ==========================================
    function calculatePerformanceScore_LEGACY(validator) {
      const breakdown = calculatePerformanceBreakdown_LEGACY(validator);
      return breakdown.totalScore;
    }
    
    function calculatePerformanceBreakdown_LEGACY(validator) {
      const breakdown = {
        epochCreditsConsistency: { score: 100, weight: 0.10, details: '' },
        creditsVsNetwork: { score: 100, weight: 0.20, details: '' },
        currentStatus: { score: 100, weight: 0.10, details: '' },
        skipRate: { score: 100, weight: 0.25, details: '' },
        versionStatus: { score: 100, weight: 0.10, details: '' },
        uptimeHistory: { score: 100, weight: 0.25, details: '' },
        totalScore: 100
      };
      
      const voteAccount = validator.voteAccount || validator.votePubkey;
      const history = loadPerformanceHistory();
      const validatorHistory = history[voteAccount] || { snapshots: [], delinquentEvents: [] };
      
      // Normalize data - handle both allValidators format and getValidatorInfo format
      const epochCreditsHistory = validator.epochCreditsHistory || validator.epochCredits || [];
      
      // Determine stake in XNT - allValidators has lamports, getValidatorInfo has XNT
      // If stake > 1 billion, it's probably in lamports
      let stakeInXNT = validator.activatedStake || 0;
      if (stakeInXNT > 1e12) {
        stakeInXNT = stakeInXNT / 1e9; // Convert from lamports
      }
      
      // 1. EPOCH CREDITS CONSISTENCY (10%)
      if (epochCreditsHistory.length >= 4) {
        const creditsPerEpoch = [];
        for (let i = 1; i < Math.min(epochCreditsHistory.length, 6); i++) {
          const entry = epochCreditsHistory[epochCreditsHistory.length - 1 - i];
          if (entry && entry.length >= 3) {
            const earned = entry[1] - entry[2];
            creditsPerEpoch.push({ earned, weight: 1 });
          }
        }
        
        if (creditsPerEpoch.length >= 3) {
          const avg = creditsPerEpoch.reduce((sum, c) => sum + c.earned, 0) / creditsPerEpoch.length;
          let variance = 0;
          creditsPerEpoch.forEach(c => {
            variance += Math.pow(c.earned - avg, 2);
          });
          variance /= creditsPerEpoch.length;
          const cv = Math.sqrt(variance) / avg;
          const cvPercent = cv * 100;
          
          let score;
          if (cvPercent <= 0.3) score = 96;
          else if (cvPercent <= 0.5) score = 93;
          else if (cvPercent <= 0.8) score = 89;
          else if (cvPercent <= 1.2) score = 84;
          else if (cvPercent <= 2) score = 78;
          else if (cvPercent <= 3) score = 71;
          else if (cvPercent <= 5) score = 62;
          else if (cvPercent <= 8) score = 52;
          else if (cvPercent <= 12) score = 40;
          else if (cvPercent <= 18) score = 28;
          else if (cvPercent <= 25) score = 16;
          else score = 8;
          
          breakdown.epochCreditsConsistency.score = score;
          breakdown.epochCreditsConsistency.details = `CV: ${cvPercent.toFixed(1)}%`;
        }
      } else {
        breakdown.epochCreditsConsistency.score = 50;
      }
      
      // 2. CREDITS EFFICIENCY (20%)
      if (epochCreditsHistory.length > 1 && window.networkAverageCreditsPerStake && stakeInXNT > 1000) {
        const latestCredits = epochCreditsHistory[epochCreditsHistory.length - 2];
        if (latestCredits && latestCredits.length >= 3) {
          const earned = latestCredits[1] - latestCredits[2];
          const validatorRatio = earned / (stakeInXNT / 1000000);
          const efficiencyRatio = validatorRatio / window.networkAverageCreditsPerStake;
          
          let score;
          if (efficiencyRatio >= 1.15) score = 100;
          else if (efficiencyRatio >= 1.12) score = 96;
          else if (efficiencyRatio >= 1.10) score = 92;
          else if (efficiencyRatio >= 1.08) score = 88;
          else if (efficiencyRatio >= 1.06) score = 84;
          else if (efficiencyRatio >= 1.04) score = 80;
          else if (efficiencyRatio >= 1.02) score = 75;
          else if (efficiencyRatio >= 1.00) score = 70;
          else if (efficiencyRatio >= 0.98) score = 64;
          else if (efficiencyRatio >= 0.96) score = 57;
          else if (efficiencyRatio >= 0.94) score = 50;
          else if (efficiencyRatio >= 0.92) score = 42;
          else if (efficiencyRatio >= 0.90) score = 34;
          else if (efficiencyRatio >= 0.85) score = 24;
          else if (efficiencyRatio >= 0.80) score = 14;
          else score = 5;
          
          breakdown.creditsVsNetwork.score = score;
          breakdown.creditsVsNetwork.details = `${(efficiencyRatio * 100).toFixed(1)}% of avg`;
        }
      } else {
        breakdown.creditsVsNetwork.score = 75;
      }
      
      // 3. CURRENT STATUS (10%)
      const isDelinquent = validator.isDelinquent || validator.delinquent || false;
      breakdown.currentStatus.score = isDelinquent ? 0 : 100;
      breakdown.currentStatus.details = isDelinquent ? 'Currently delinquent' : 'Active';
      
      // 4. SKIP RATE (25%)
      const skipRate = validator.skipRate;
      const skipHistory = validator.skipRateHistory;
      
      function getSkipRateScore(rate) {
        if (rate === 0) return 100;
        if (rate <= 0.05) return 98;
        if (rate <= 0.1) return 95;
        if (rate <= 0.2) return 91;
        if (rate <= 0.35) return 86;
        if (rate <= 0.5) return 80;
        if (rate <= 0.75) return 72;
        if (rate <= 1) return 63;
        if (rate <= 1.5) return 50;
        if (rate <= 2) return 38;
        if (rate <= 3) return 25;
        if (rate <= 4) return 15;
        if (rate <= 5) return 8;
        return 0;
      }
      
      if (skipHistory && skipHistory.avgSkipRate !== null) {
        breakdown.skipRate.score = getSkipRateScore(skipHistory.avgSkipRate);
        breakdown.skipRate.details = `${skipHistory.avgSkipRate.toFixed(2)}% (7-epoch avg)`;
      } else if (skipHistory && skipHistory.lastEpochSkipRate !== null) {
        breakdown.skipRate.score = getSkipRateScore(skipHistory.lastEpochSkipRate);
        breakdown.skipRate.details = `${skipHistory.lastEpochSkipRate.toFixed(2)}% (last epoch)`;
      } else if (skipRate !== null && skipRate !== undefined) {
        breakdown.skipRate.score = getSkipRateScore(skipRate);
        breakdown.skipRate.details = `${skipRate.toFixed(2)}% (this epoch)`;
      } else {
        breakdown.skipRate.score = 75;
        breakdown.skipRate.details = 'Awaiting slots';
      }
      
      // 5. VERSION STATUS (10%)
      if (validator.version) {
        const outdated = isVersionOutdated(validator.version);
        breakdown.versionStatus.score = outdated ? 50 : 100;
        breakdown.versionStatus.details = `v${validator.version} (${outdated ? 'outdated' : 'latest'})`;
      } else {
        breakdown.versionStatus.score = 50;
        breakdown.versionStatus.details = 'Unknown version';
      }
      
      // 6. UPTIME HISTORY (25%)
      const epochCreditsHist = validator.epochCreditsHistory || validator.epochCredits || [];
      
      if (epochCreditsHist.length >= 3 && window.networkEpochCredits) {
        const epochsToCheck = Math.min(7, epochCreditsHist.length - 1);
        let goodEpochs = 0;
        let checkedEpochs = 0;
        
        for (let i = 1; i <= epochsToCheck; i++) {
          const entry = epochCreditsHist[epochCreditsHist.length - 1 - i];
          if (!entry || entry.length < 3) continue;
          
          const epoch = entry[0];
          const creditsEarned = entry[1] - entry[2];
          const networkAvg = window.networkEpochCredits[epoch];
          
          if (networkAvg && networkAvg > 0) {
            checkedEpochs++;
            const ratio = creditsEarned / networkAvg;
            if (ratio >= 0.80) goodEpochs++;
          }
        }
        
        if (checkedEpochs > 0) {
          let score;
          if (goodEpochs === checkedEpochs) score = 95;
          else if (goodEpochs >= checkedEpochs - 1) score = 80;
          else if (goodEpochs >= checkedEpochs - 2) score = 60;
          else score = Math.max(10, (goodEpochs / checkedEpochs) * 50);
          
          breakdown.uptimeHistory.score = score;
          breakdown.uptimeHistory.details = `${goodEpochs}/${checkedEpochs} good epochs`;
        } else {
          breakdown.uptimeHistory.score = 75;
        }
      } else {
        breakdown.uptimeHistory.score = 75;
        breakdown.uptimeHistory.details = 'Building history...';
      }
      
      // Calculate total
      breakdown.totalScore = 
        (breakdown.epochCreditsConsistency.score * breakdown.epochCreditsConsistency.weight) +
        (breakdown.creditsVsNetwork.score * breakdown.creditsVsNetwork.weight) +
        (breakdown.currentStatus.score * breakdown.currentStatus.weight) +
        (breakdown.skipRate.score * breakdown.skipRate.weight) +
        (breakdown.versionStatus.score * breakdown.versionStatus.weight) +
        (breakdown.uptimeHistory.score * breakdown.uptimeHistory.weight);
      
      breakdown.totalScore = Math.max(0, Math.min(100, breakdown.totalScore));
      
      return breakdown;
    }
    
    // Calculate network average credits (call this when loading validators)
    function calculateNetworkAverageCredits() {
      if (!allValidators || allValidators.length === 0) return;
      
      let totalCredits = 0;
      let totalRatio = 0;
      let count = 0;
      let ratioCount = 0;
      
      // Also calculate per-epoch network averages for uptime detection
      const epochCreditsMap = {}; // { epoch: { total: 0, count: 0 } }
      
      allValidators.forEach(v => {
        if (v.epochCredits && v.epochCredits.length > 0) {
          const latest = v.epochCredits[v.epochCredits.length - 1];
          if (latest && latest.length >= 3) {
            const earned = latest[1] - latest[2];
            totalCredits += earned;
            count++;
            
            // Calculate credits per stake ratio (credits per 1M XNT staked)
            const stakeInXNT = v.activatedStake / 1e9;
            if (stakeInXNT > 1000) { // Only include validators with meaningful stake
              const ratio = earned / (stakeInXNT / 1000000); // Credits per 1M XNT
              totalRatio += ratio;
              ratioCount++;
            }
          }
          
          // Build per-epoch credits for uptime history calculation
          // Skip current epoch (index 0 from end), look at last 7 completed epochs
          for (let i = 1; i < Math.min(v.epochCredits.length, 8); i++) {
            const entry = v.epochCredits[v.epochCredits.length - 1 - i];
            if (entry && entry.length >= 3) {
              const epoch = entry[0];
              const creditsEarned = entry[1] - entry[2];
              
              if (!epochCreditsMap[epoch]) {
                epochCreditsMap[epoch] = { total: 0, count: 0 };
              }
              epochCreditsMap[epoch].total += creditsEarned;
              epochCreditsMap[epoch].count++;
            }
          }
        }
      });
      
      window.networkAverageCredits = count > 0 ? totalCredits / count : null;
      window.networkAverageCreditsPerStake = ratioCount > 0 ? totalRatio / ratioCount : null;
      
      // Calculate per-epoch averages
      window.networkEpochCredits = {};
      for (const epoch in epochCreditsMap) {
        const data = epochCreditsMap[epoch];
        if (data.count > 0) {
          window.networkEpochCredits[epoch] = data.total / data.count;
        }
      }
    }
    
    // Fetch skip rates for all validators at once
    async function fetchAllSkipRates() {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBlockProduction'
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value && data.result.value.byIdentity) {
          const byIdentity = data.result.value.byIdentity;
          
          // Update each validator's skip rate
          allValidators.forEach(v => {
            const production = byIdentity[v.nodePubkey];
            if (production && production.length >= 2) {
              const leaderSlots = production[0];
              const blocksProduced = production[1];
              if (leaderSlots > 0) {
                v.skipRate = ((leaderSlots - blocksProduced) / leaderSlots) * 100;
              } else {
                v.skipRate = null; // No leader slots assigned yet
              }
            } else {
              v.skipRate = null; // No data available
            }
          });
        }
      } catch (e) {
        console.error('Error fetching all skip rates:', e);
      }
    }
    
    // Generate performance tooltip HTML
    function getPerformanceTooltipHtml(validator) {
      const breakdown = calculatePerformanceBreakdown(validator);
      
      return `
        <div class="perf-tooltip">
          <div class="perf-tooltip-title">Performance Breakdown (7-epoch)</div>
          <div class="perf-tooltip-row">
            <span class="perf-tooltip-label">Vote Efficiency (30%)</span>
            <span class="perf-tooltip-value ${getScoreColorClass(breakdown.voteEfficiency.score)}">${breakdown.voteEfficiency.score.toFixed(0)}</span>
          </div>
          <div class="perf-tooltip-detail">${breakdown.voteEfficiency.details}</div>
          
          <div class="perf-tooltip-row">
            <span class="perf-tooltip-label">Skip Rate (25%)</span>
            <span class="perf-tooltip-value ${getScoreColorClass(breakdown.skipRate.score)}">${breakdown.skipRate.score.toFixed(0)}</span>
          </div>
          <div class="perf-tooltip-detail">${breakdown.skipRate.details}</div>
          
          <div class="perf-tooltip-row">
            <span class="perf-tooltip-label">Consistency (20%)</span>
            <span class="perf-tooltip-value ${getScoreColorClass(breakdown.consistency.score)}">${breakdown.consistency.score.toFixed(0)}</span>
          </div>
          <div class="perf-tooltip-detail">${breakdown.consistency.details}</div>
          
          <div class="perf-tooltip-row">
            <span class="perf-tooltip-label">Commission (5%)</span>
            <span class="perf-tooltip-value ${getScoreColorClass(breakdown.commission.score)}">${breakdown.commission.score.toFixed(0)}</span>
          </div>
          <div class="perf-tooltip-detail">${breakdown.commission.details}</div>
          
          <div class="perf-tooltip-row">
            <span class="perf-tooltip-label">Longevity (5%)</span>
            <span class="perf-tooltip-value ${getScoreColorClass(breakdown.longevity.score)}">${breakdown.longevity.score.toFixed(0)}</span>
          </div>
          <div class="perf-tooltip-detail">${breakdown.longevity.details}</div>
          
          <div class="perf-tooltip-row">
            <span class="perf-tooltip-label">Software (5%)</span>
            <span class="perf-tooltip-value ${getScoreColorClass(breakdown.softwareVersion.score)}">${breakdown.softwareVersion.score.toFixed(0)}</span>
          </div>
          <div class="perf-tooltip-detail">${breakdown.softwareVersion.details}</div>
          
          <div class="perf-tooltip-row">
            <span class="perf-tooltip-label">Reliability (10%)</span>
            <span class="perf-tooltip-value ${getScoreColorClass(breakdown.reliability.score)}">${breakdown.reliability.score.toFixed(0)}</span>
          </div>
          <div class="perf-tooltip-detail">${breakdown.reliability.details}</div>
          
          <div class="perf-tooltip-total">
            <span>Total Score</span>
            <span class="${getScoreColorClass(breakdown.totalScore)}">${breakdown.totalScore.toFixed(2)}</span>
          </div>
        </div>
      `;
    }
    
    function getScoreColorClass(score) {
      if (score >= 90) return 'score-good';
      if (score >= 70) return 'score-warning';
      if (score >= 50) return 'score-orange';
      return 'score-bad';
    }

    function getPerformanceColor(score) {
      if (score >= 90) return 'success';
      if (score >= 70) return 'warning';
      if (score >= 50) return 'orange';
      return 'danger';
    }

    function getPerformanceBarColor(score) {
      if (score >= 90) return 'var(--success)';
      if (score >= 70) return 'var(--warning)';
      if (score >= 50) return '#ff9800';
      return 'var(--danger)';
    }

    function getSkipRateColor(rate) {
      if (rate === null || rate === 0) return 'success';
      if (rate <= 5) return 'success';
      if (rate <= 10) return 'warning';
      return 'danger';
    }

    function getSkipRateColorClass(rate) {
      if (rate === null || rate === undefined) return '';
      if (rate <= 2) return 'score-good';
      if (rate <= 5) return 'score-warning';
      if (rate <= 10) return 'score-orange';
      return 'score-bad';
    }

    function getCommissionColorClass(commission) {
      if (commission <= 5) return 'score-good';
      if (commission <= 10) return 'score-warning';
      if (commission <= 15) return 'score-orange';
      return 'score-bad';
    }

    function getTierBadge(rank, totalValidators) {
      if (!rank || !totalValidators) return '';
      
      const percentile = (rank / totalValidators) * 100;
      
      if (percentile <= 10) {
        return '<span class="tier-badge elite" title="This validator ranks in the top 10% by total stake"> Top 10%</span>';
      } else if (percentile <= 20) {
        return '<span class="tier-badge excellent" title="This validator ranks in the top 20% by total stake"> Top 20%</span>';
      } else if (percentile <= 30) {
        return '<span class="tier-badge great" title="This validator ranks in the top 30% by total stake"> Top 30%</span>';
      }
      
      return '';
    }

    function renderValidatorCard(validator, showAddBtn = true, showRemoveBtn = false) {
      // Use cached performance score if available, otherwise calculate
      const perfScore = validator.performanceScore !== undefined ? validator.performanceScore : calculatePerformanceScore(validator);
      const perfColor = getPerformanceColor(perfScore);
      const perfBarColor = getPerformanceBarColor(perfScore);
      const perfTooltip = getPerformanceTooltipHtml(validator);
      
      // Current epoch skip rate
      const currentSkipRate = validator.skipRate;
      
      // Historical skip rate data (from RPC, not localStorage)
      const skipHistory = validator.skipRateHistory;
      const lastEpochSkipRate = skipHistory ? skipHistory.lastEpochSkipRate : null;
      const avgSkipRate = skipHistory ? skipHistory.avgSkipRate : null;
      
      // Build skip rate display - show 7-epoch average as main value
      let skipRateDisplay, skipLabel, skipColor;
      
      if (avgSkipRate !== null && avgSkipRate !== undefined) {
        // Show 7-epoch average as main value
        skipRateDisplay = formatNumber(avgSkipRate, 2) + '%';
        skipColor = getSkipRateColor(avgSkipRate);
        skipLabel = `7-epoch average`;
      } else if (currentSkipRate !== null && currentSkipRate !== undefined) {
        // Fallback to current epoch if no history
        skipRateDisplay = formatNumber(currentSkipRate, 2) + '%';
        skipColor = getSkipRateColor(currentSkipRate);
        skipLabel = 'This epoch only';
      } else if (lastEpochSkipRate !== null) {
        // No current epoch data, but have last epoch
        skipRateDisplay = formatNumber(lastEpochSkipRate, 2) + '%';
        skipColor = getSkipRateColor(lastEpochSkipRate);
        skipLabel = 'Last epoch only';
      } else {
        // No data at all
        skipRateDisplay = 'Awaiting';
        skipColor = '';
        skipLabel = 'No slots yet';
      }
      
      const isInPortfolio = myPortfolio.includes(validator.voteAccount);
      
      // Record performance snapshot for history tracking
      recordPerformanceSnapshot(validator);

      let actionBtn = '';
      if (showRemoveBtn) {
        actionBtn = `<button class="remove-btn" onclick="removeFromPortfolio('${validator.voteAccount}')">Remove</button>`;
      } else if (showAddBtn && !isInPortfolio) {
        actionBtn = `<button class="add-btn" onclick="addToPortfolio('${validator.voteAccount}')">+ Add</button>`;
      } else if (showAddBtn && isInPortfolio) {
        actionBtn = `<button class="add-btn" style="opacity: 0.5;" disabled>Added</button>`;
      }

      // Generate logo or placeholder
      const firstLetter = validator.name.charAt(0).toUpperCase();
      const logoHtml = validator.iconUrl 
        ? `<img class="validator-logo" src="${validator.iconUrl}" alt="${validator.name}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
           <div class="validator-logo-placeholder" style="display:none;">${firstLetter}</div>`
        : `<div class="validator-logo-placeholder">${firstLetter}</div>`;

      // Version badge with update warning if outdated
      let versionHtml = '';
      if (validator.version) {
        const outdated = isVersionOutdated(validator.version);
        if (outdated) {
          versionHtml = `<span class="version-badge outdated">v${validator.version}</span><span class="version-update-warning" title="Latest version: v${window.latestValidatorVersion}"> Update Available</span>`;
        } else {
          versionHtml = `<span class="version-badge">v${validator.version}</span>`;
        }
      }

      // Unique ID for chart
      const chartId = 'chart-' + validator.voteAccount.slice(0, 8);

      // Get chart data - prefer XNT rewards from API, fallback to epoch credits
      let rewardsData = [];
      let epochLabels = [];
      let chartType = 'credits'; // 'xnt' or 'credits'
      
      // Check for XNT rewards history from API
      const xntHistory = getValidatorRewardsHistory(validator.voteAccount);
      if (xntHistory && xntHistory.length > 1) {
        chartType = 'xnt';
        xntHistory.slice(-30).forEach(entry => {
          epochLabels.push(entry.epoch);
          rewardsData.push(entry.earned);
        });
      } else {
        // Fallback to epoch credits
        // Skip the current (most recent) epoch as it will always show 0 until finalized
        const epochCreditsHistory = validator.epochCreditsHistory || [];
        if (epochCreditsHistory.length > 2) {
          for (let i = 1; i < Math.min(epochCreditsHistory.length, 31); i++) {
            const entry = epochCreditsHistory[epochCreditsHistory.length - 1 - i];
            if (entry && entry.length >= 3) {
              const creditsEarned = entry[1] - entry[2];
              rewardsData.unshift(creditsEarned);
              epochLabels.unshift(entry[0]);
            }
          }
        }
      }

      // Store chart data globally for initialization
      if (!window.chartDataStore) window.chartDataStore = {};
      window.chartDataStore[chartId] = {
        labels: epochLabels,
        data: rewardsData,
        name: validator.name,
        type: chartType,
        voteAccount: validator.voteAccount,
        commission: validator.commission
      };

      return `
        <div class="validator-card">
          <div class="validator-header">
            <div class="validator-info">
              ${logoHtml}
              <div>
                <div class="validator-name">
                  ${validator.name}${getTierBadge(validator.rank, validator.totalValidators)}
                  <span class="validator-rank" title="Stake rank: Position among all validators sorted by total stake">#${validator.rank} of ${validator.totalValidators}</span>
                </div>
                <div class="validator-meta">
                  <span class="validator-address">${validator.voteAccount}</span>
                  <button class="copy-address-btn" onclick="event.stopPropagation(); copyToClipboard('${validator.voteAccount}', this)" title="Copy address">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                  </button>
                  ${versionHtml}
                </div>
              </div>
            </div>
            <div class="manage-validator-btn-wrapper">
              <button class="manage-validator-btn" onclick="openManageValidator('${validator.voteAccount}', '${validator.name.replace(/'/g, "\\'")}', ${validator.rewardsBalance}, ${validator.commission}, '${validator.nodePubkey || ''}', '${validator.iconUrl || ''}')">
                 Manage Validator
              </button>
            </div>
            <div class="validator-actions">
              <div class="status-badge ${validator.isDelinquent ? 'status-delinquent' : 'status-active'}">
                ${validator.isDelinquent ? 'Delinquent' : 'Active'}
              </div>
              ${actionBtn}
            </div>
          </div>
          
          <div class="stats-grid">
            <div class="stat-item" title="The validator's accumulated rewards that can be withdrawn.">
              <div class="stat-label">Rewards<br>Balance</div>
              <div class="stat-value accent">${formatNumber(validator.rewardsBalance)}</div>
              <div class="stat-subtext">XNT</div>
            </div>
            
            <div class="stat-item" title="Total validator rewards (vote + self-stake) earned in the last completed epoch." id="lastEpoch-${validator.voteAccount.slice(0,8)}">
              <div class="stat-label">Last Epoch<br>Earned</div>
              <div class="stat-value" style="color: var(--success);">--</div>
              <div class="stat-subtext">XNT</div>
              <div class="stat-change" id="lastEpochChange-${validator.voteAccount.slice(0,8)}"></div>
            </div>
            
            <div class="stat-item clickable-stat" onclick="openStakeSelection('${validator.voteAccount}', '${validator.name.replace(/'/g, "\\'")}')" title="Click to manage self-stake vs delegated classification">
              <div class="stat-label">Active<br>Stake</div>
              <div class="stat-value">${formatXntCompact(validator.activatedStake)}</div>
              <div class="stat-subtext">XNT</div>
              <div class="stat-subtext" style="color: var(--accent-cyan); font-size: 0.65rem;">Click to manage</div>
            </div>
            
            <div class="stat-item" title="Epoch credits represent the validator's voting activity. More credits generally means better uptime and participation in consensus.">
              <div class="stat-label">Epoch<br>Credits</div>
              <div class="stat-value">${formatCompact(validator.epochCredits)}</div>
              <div class="stat-subtext">Current epoch</div>
            </div>
            
            <div class="stat-item" title="Commission is the percentage of staking rewards the validator keeps. The remaining percentage goes to delegators.">
              <div class="stat-label">Commission<br>Rate</div>
              <div class="stat-value">${validator.commission}%</div>
              <div class="stat-subtext">Fee rate</div>
            </div>
            
            <div class="stat-item" title="Skip rate shows the percentage of assigned leader slots where the validator failed to produce a block. Lower is better. Shows 7-day average when available, with current epoch status below.">
              <div class="stat-label">Skip<br>Rate</div>
              <div class="stat-value ${skipColor}">${skipRateDisplay}</div>
              <div class="stat-subtext">${skipLabel}</div>
            </div>
            
            <div class="stat-item perf-score-wrapper" onclick="openPerfExplainerModal(event, '${validator.voteAccount}')">
              <div class="stat-label">Performance (7D) <span class="perf-info-icon">?</span></div>
              <div class="stat-value ${perfColor}">${formatNumber(perfScore, 2)}</div>
              <div class="perf-bar-container">
                <div class="perf-bar">
                  <div class="perf-bar-fill" style="width: ${perfScore}%; background: ${perfBarColor};"></div>
                </div>
              </div>
              <div class="perf-click-hint">Click for details</div>
            </div>
          </div>

          <div class="validator-action-buttons">
            <button class="validator-expand-btn stake-details-btn" onclick="toggleStakeDetails('${validator.voteAccount}', '${validator.name.replace(/'/g, "\\'")}', ${validator.activatedStake}, ${validator.commission}, this)">
              <span>Stake Details</span>
              <span class="arrow"></span>
            </button>
            <button class="validator-expand-btn" onclick="toggleChart('${chartId}', this)">
              <span>View Earnings Trend</span>
              <span class="arrow"></span>
            </button>
          </div>

          <div class="validator-stake-section" id="stake-${validator.voteAccount}-section">
            <div class="stake-section-loading">
              <div class="loading-spinner-small"></div>
              <span>Analyzing stake accounts...</span>
            </div>
          </div>

          <div class="validator-chart-section" id="${chartId}-section">
            <div class="chart-toggle-container">
              <button class="chart-toggle-btn active" onclick="switchChartType('${chartId}', 'xnt', this)" data-type="xnt">XNT Rewards</button>
              <button class="chart-toggle-btn" onclick="switchChartType('${chartId}', 'credits', this)" data-type="credits">Epoch Credits</button>
            </div>
            <div class="chart-header">
              <div>
                <div class="chart-title" id="${chartId}-title">XNT Rewards Trend</div>
                <div class="chart-subtitle" id="${chartId}-subtitle">Credits earned per epoch (last ${epochLabels.length} epochs)</div>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="${chartId}"></canvas>
            </div>
            <div class="chart-stats" id="${chartId}-stats">
              <div class="chart-stat">
                <div class="chart-stat-value" id="${chartId}-last">${rewardsData.length > 0 ? formatNumber(rewardsData[rewardsData.length - 1], 0) : '--'}</div>
                <div class="chart-stat-label">Last Epoch</div>
              </div>
              <div class="chart-stat">
                <div class="chart-stat-value" id="${chartId}-avg">${rewardsData.length > 0 ? formatNumber(rewardsData.reduce((a, b) => a + b, 0) / rewardsData.length, 0) : '--'}</div>
                <div class="chart-stat-label">Average</div>
              </div>
              <div class="chart-stat">
                <div class="chart-stat-value" id="${chartId}-peak">${rewardsData.length > 0 ? formatNumber(Math.max(...rewardsData), 0) : '--'}</div>
                <div class="chart-stat-label">Peak</div>
              </div>
            </div>
            <div class="chart-loading" id="${chartId}-loading" style="display: none;">
              <div class="loading-spinner-small"></div>
              <span>Loading XNT rewards data...</span>
            </div>
          </div>
        </div>
      `;
    }

    // Search functionality
    function handleSearchInput() {
      const input = document.getElementById('searchInput').value.trim();
      if (input.length < 2) return;
      
      // Auto-search as user types (for name search)
      if (input.length > 3 && input.length < 44) {
        // Likely a name search, not a full address
        performSearch();
      }
    }

    // Lookup a specific validator (called from leaderboard)
    function lookupValidator(voteAccount) {
      // Clear cache to get fresh data with skip rate
      delete validatorInfoCache[voteAccount];
      
      // Switch to lookup tab
      switchTab('lookup');
      
      // Set the search input
      document.getElementById('searchInput').value = voteAccount;
      
      // Perform the search
      performSearch();
    }

    async function performSearch() {
      const input = document.getElementById('searchInput').value.trim();
      if (!input) return;

      const loading = document.getElementById('loading');
      const results = document.getElementById('resultsSection');
      const error = document.getElementById('errorMessage');

      results.style.display = 'none';
      error.style.display = 'none';
      loading.style.display = 'flex';

      try {
        let validators = [];

        // Check if it's a vote account address (44 characters)
        if (input.length >= 43 && input.length <= 44) {
          const validator = await getValidatorInfo(input);
          if (validator) {
            validators.push(validator);
          }
        } else {
          // Search by name
          const searchLower = input.toLowerCase();
          const matches = allValidators.filter(v => 
            v.name.toLowerCase().includes(searchLower) ||
            v.votePubkey.toLowerCase().includes(searchLower) ||
            v.nodePubkey.toLowerCase().includes(searchLower)
          ).slice(0, 20); // Limit to 20 results

          for (const match of matches) {
            const validator = await getValidatorInfo(match.votePubkey);
            if (validator) {
              validators.push(validator);
            }
          }
        }
        
        if (validators.length === 0) {
          throw new Error('No validators found');
        }

        // Render results
        document.getElementById('validatorResults').innerHTML = validators.map(v => renderValidatorCard(v, true, false)).join('');
        document.getElementById('resultCount').textContent = validators.length;
        document.getElementById('lastUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
        
        // Fetch last epoch rewards for each card
        fetchLastEpochForCards(validators);
        
        loading.style.display = 'none';
        results.style.display = 'block';

      } catch (err) {
        console.error(err);
        loading.style.display = 'none';
        error.style.display = 'block';
      }
    }

    // Portfolio management
    function savePortfolio() {
      localStorage.setItem('x1Portfolio', JSON.stringify(myPortfolio));
      updatePortfolioCount();
    }

    function updatePortfolioCount() {
      const countEl = document.getElementById('portfolioCount');
      if (myPortfolio.length > 0) {
        countEl.textContent = `(${myPortfolio.length})`;
      } else {
        countEl.textContent = '';
      }
    }

    function addToPortfolio(voteAccount) {
      if (!myPortfolio.includes(voteAccount)) {
        myPortfolio.push(voteAccount);
        savePortfolio();
        
        // Re-render current results to update button
        performSearch();
      }
    }

    function removeFromPortfolio(voteAccount) {
      myPortfolio = myPortfolio.filter(v => v !== voteAccount);
      savePortfolio();
      loadPortfolio();
    }

    function clearPortfolio() {
      if (confirm('Are you sure you want to remove all validators from your Data Center?')) {
        myPortfolio = [];
        savePortfolio();
        loadPortfolio();
      }
    }

    async function loadPortfolio() {
      const loading = document.getElementById('portfolioLoading');
      const results = document.getElementById('portfolioResults');
      const empty = document.getElementById('emptyPortfolio');

      if (myPortfolio.length === 0) {
        results.style.display = 'none';
        empty.style.display = 'block';
        loading.style.display = 'none';
        return;
      }

      empty.style.display = 'none';
      loading.style.display = 'flex';
      results.style.display = 'none';

      try {
        const validators = [];
        
        for (const voteAccount of myPortfolio) {
          const validator = await getValidatorInfo(voteAccount, true);
          if (validator) {
            validators.push(validator);
          }
        }

        if (validators.length === 0) {
          empty.style.display = 'block';
          loading.style.display = 'none';
          return;
        }

        // Update summary
        let totalStake = 0;
        let totalRewards = 0;
        let totalPerf = 0;
        let activeCount = 0;

        validators.forEach(v => {
          totalStake += v.activatedStake;
          totalRewards += v.rewardsBalance;
          // Use cached performance score if available
          totalPerf += v.performanceScore !== undefined ? v.performanceScore : calculatePerformanceScore(v);
          if (!v.isDelinquent) activeCount++;
        });

        document.getElementById('totalPortfolioStake').textContent = formatNumber(totalStake);
        document.getElementById('totalPortfolioRewards').textContent = formatNumber(totalRewards);
        document.getElementById('portfolioLastEpochRewards').textContent = 'Loading...';
        const avgPerf = totalPerf / validators.length;
        const avgPerfEl = document.getElementById('avgPortfolioPerf');
        avgPerfEl.textContent = formatNumber(avgPerf, 1);
        avgPerfEl.style.color = getPerformanceBarColor(avgPerf);
        document.getElementById('activePortfolioCount').textContent = `${activeCount}/${validators.length}`;
        document.getElementById('portfolioResultCount').textContent = validators.length;
        document.getElementById('portfolioUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();

        // Fetch last epoch rewards for all validators (async)
        fetchPortfolioLastEpochRewards(validators);

        // Sort validators alphabetically (natural sort for numbers)
        const sortedValidators = [...validators].sort((a, b) => {
          return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
        });

        // Store combined chart data (sorted)
        window.combinedChartValidators = sortedValidators;
        
        // Store color mapping for each validator
        window.validatorColorMap = {};
        sortedValidators.forEach((v, index) => {
          window.validatorColorMap[v.voteAccount] = index;
        });

        // Render validator cards (also sorted alphabetically)
        document.getElementById('portfolioValidatorResults').innerHTML = sortedValidators.map(v => renderValidatorCard(v, false, true)).join('');

        // Fetch last epoch rewards for each card
        fetchLastEpochForCards(sortedValidators);

        loading.style.display = 'none';
        results.style.display = 'block';

        // Destroy old combined chart if exists
        if (chartInstances['combinedChart']) {
          chartInstances['combinedChart'].destroy();
          delete chartInstances['combinedChart'];
        }

      } catch (err) {
        console.error('Failed to load portfolio:', err);
        loading.style.display = 'none';
        empty.style.display = 'block';
      }
    }

    function refreshPortfolio() {
      // Clear cache to force refresh
      validatorInfoCache = {};
      loadPortfolio();
    }

    // Fetch last epoch rewards for all portfolio validators
    async function fetchPortfolioLastEpochRewards(validators) {
      try {
        let totalLastEpochRewards = 0;
        
        // Fetch rewards for each validator in parallel
        const rewardPromises = validators.map(async (v) => {
          try {
            const rewards = await fetchTotalValidatorRewards(v.voteAccount, v.commission || 0, 1);
            if (rewards && rewards.length > 0) {
              // Amount is in lamports, convert to XNT
              return (rewards[0].amount || 0) / 1e9;
            }
            return 0;
          } catch (e) {
            console.error(`Error fetching rewards for ${v.voteAccount}:`, e);
            return 0;
          }
        });
        
        const rewardResults = await Promise.all(rewardPromises);
        totalLastEpochRewards = rewardResults.reduce((sum, r) => sum + r, 0);
        
        document.getElementById('portfolioLastEpochRewards').textContent = formatNumber(totalLastEpochRewards, 2);
      } catch (e) {
        console.error('Error fetching portfolio last epoch rewards:', e);
        document.getElementById('portfolioLastEpochRewards').textContent = '-';
      }
    }

    // Fetch last epoch rewards for each validator card
    async function fetchLastEpochForCards(validators) {
      for (const v of validators) {
        try {
          // Fetch 2 epochs to calculate change
          const rewards = await fetchTotalValidatorRewards(v.voteAccount, v.commission || 0, 2);
          const cardEl = document.getElementById(`lastEpoch-${v.voteAccount.slice(0,8)}`);
          const changeEl = document.getElementById(`lastEpochChange-${v.voteAccount.slice(0,8)}`);
          
          if (cardEl && rewards && rewards.length > 0) {
            const lastEpochAmount = (rewards[0].amount || 0) / 1e9;
            cardEl.querySelector('.stat-value').textContent = formatNumber(lastEpochAmount, 2);
            
            // Calculate change if we have 2 epochs of data
            if (changeEl && rewards.length >= 2 && rewards[1].amount > 0) {
              const priorEpochAmount = (rewards[1].amount || 0) / 1e9;
              const changePercent = ((lastEpochAmount - priorEpochAmount) / priorEpochAmount) * 100;
              
              if (changePercent > 0) {
                changeEl.innerHTML = `<span style="color: var(--success);"> ${formatNumber(changePercent, 2)}%</span>`;
              } else if (changePercent < 0) {
                changeEl.innerHTML = `<span style="color: var(--danger);"> ${formatNumber(Math.abs(changePercent), 2)}%</span>`;
              } else {
                changeEl.innerHTML = `<span style="color: var(--text-dim);"> 0%</span>`;
              }
            }
          }
        } catch (e) {
          console.error(`Error fetching last epoch for ${v.voteAccount}:`, e);
        }
      }
    }

    // ==========================================
    // X1 Network Functions
    // ==========================================
    
    let validatorMap = null;
    window.mapInitialized = false;
    
    // Country code to flag emoji mapping
    const countryFlags = {
      'US': '', 'DE': '', 'FR': '', 'GB': '', 'NL': '', 
      'CA': '', 'AU': '', 'JP': '', 'SG': '', 'KR': '',
      'SE': '', 'FI': '', 'CH': '', 'IE': '', 'PL': '',
      'ES': '', 'IT': '', 'BR': '', 'IN': '', 'RU': '',
      'CN': '', 'HK': '', 'TW': '', 'UA': '', 'CZ': '',
      'AT': '', 'BE': '', 'DK': '', 'NO': '', 'PT': '',
      'RO': '', 'BG': '', 'HU': '', 'GR': '', 'LT': '',
      'LV': '', 'EE': '', 'SK': '', 'SI': '', 'HR': '',
      'RS': '', 'ZA': '', 'MX': '', 'AR': '', 'CL': '',
      'NZ': '', 'TH': '', 'VN': '', 'MY': '', 'ID': '',
      'PH': '', 'AE': '', 'IL': '', 'TR': '', 'SA': ''
    };

    // Create clean dot marker icon
    function createGlowDot() {
      return L.divIcon({
        className: 'glow-dot-wrapper',
        html: `<div class="glow-dot"></div>`,
        iconSize: [6, 6],
        iconAnchor: [3, 3],
        popupAnchor: [0, -3]
      });
    }

    // Initialize the map
    async function initializeMap() {
      if (window.mapInitialized) return;
      
      const mapContainer = document.getElementById('validatorMap');
      const loadingEl = document.getElementById('mapLoading');
      
      // Create map with dark theme
      validatorMap = L.map('validatorMap', {
        center: [35, -30],
        zoom: 2,
        minZoom: 2,
        maxZoom: 10,
        worldCopyJump: true
      });

      // Add dark themed tile layer (CartoDB Dark Matter)
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        subdomains: 'abcd',
        maxZoom: 19
      }).addTo(validatorMap);

      window.mapInitialized = true;

      // Load validator locations
      await loadValidatorLocations();
      
      if (loadingEl) loadingEl.style.display = 'none';
    }

    // Get cluster nodes with IPs
    async function getClusterNodesWithIPs() {
      try {
        const nodes = await rpcCall('getClusterNodes');
        return nodes;
      } catch (err) {
        console.error('Error fetching cluster nodes:', err);
        return [];
      }
    }

    // Geolocation - loads from pre-generated JSON file for instant loading
    const GEO_DATA_URL = 'validator-locations.json';
    const GEO_CACHE_KEY = 'x1GeoCache';
    const GEO_CACHE_DURATION = 6 * 60 * 60 * 1000; // 6 hours
    
    let geoData = null;
    
    // Load pre-generated geo data from static JSON file
    async function loadStaticGeoData() {
      try {
        const response = await fetch(GEO_DATA_URL + '?t=' + Date.now());
        if (response.ok) {
          geoData = await response.json();
          return geoData;
        }
      } catch (e) {
        console.log('Static geo data not available, using dynamic lookup');
      }
      return null;
    }
    
    function getGeoCache() {
      try {
        const cached = JSON.parse(localStorage.getItem(GEO_CACHE_KEY) || '{}');
        return cached;
      } catch (e) {
        return { timestamp: 0, data: {} };
      }
    }
    
    function saveGeoCache(data) {
      try {
        localStorage.setItem(GEO_CACHE_KEY, JSON.stringify({
          timestamp: Date.now(),
          data: data
        }));
      } catch (e) { /* localStorage may fail due to quota limits - safe to ignore */ }
    }
    
    // Get geo data - prefers static file, falls back to API
    async function batchGeolocateIPs(ips, progressCallback) {
      // First, try to use static pre-generated data
      if (geoData && geoData.locations && Object.keys(geoData.locations).length > 50) {
        return geoData.locations;
      }
      
      // Check localStorage cache
      const cache = getGeoCache();
      const results = { ...cache.data };
      const cacheAge = Date.now() - (cache.timestamp || 0);
      const cacheAgeMinutes = Math.round(cacheAge / 1000 / 60);
      
      // If cache has good data and is fresh, use it
      if (cacheAge < GEO_CACHE_DURATION && Object.keys(results).length > 50) {
        return results;
      }
      
      // Find IPs not in cache
      const uncachedIPs = ips.filter(ip => !results[ip]);
      
      if (uncachedIPs.length === 0) {
        return results;
      }
      
      // Test API with known working IP
      let apiWorks = false;
      try {
        const testRes = await fetch('https://ipwho.is/8.8.8.8');
        const testData = await testRes.json();
        if (testData.success !== false && testData.latitude) {
          apiWorks = true;
        }
      } catch (e) {
        // API test failed
      }
      
      if (!apiWorks) {
        return results;
      }
      
      // Process IPs one at a time with delays to avoid rate limits
      let successCount = 0;
      const maxToProcess = Math.min(uncachedIPs.length, 500); // Limit to avoid long waits
      
      for (let i = 0; i < maxToProcess; i++) {
        const ip = uncachedIPs[i];
        
        try {
          const res = await fetch('https://ipwho.is/' + ip);
          const data = await res.json();
          
          if (data.success !== false && data.latitude && data.longitude) {
            results[ip] = {
              country: data.country,
              countryCode: data.country_code,
              city: data.city || 'Unknown',
              lat: data.latitude,
              lon: data.longitude
            };
            successCount++;
          }
        } catch (e) {
          // Skip failed lookups
        }
        
        // Progress callback
        if (progressCallback && (i % 10 === 0 || i === maxToProcess - 1)) {
          progressCallback(i + 1, maxToProcess, successCount);
        }
        
        // Save cache periodically
        if (successCount > 0 && successCount % 100 === 0) {
          saveGeoCache(results);
        }
        
        // Delay between requests (ipwho.is allows ~1000/day for free)
        await new Promise(r => setTimeout(r, 200));
      }
      
      // Final save
      if (successCount > 0) {
        saveGeoCache(results);
      }
      
      return results;
    }
    
    // Background refresh
    async function refreshGeoDataInBackground(ips) {
      const cache = getGeoCache();
      const results = { ...cache.data };
      
      const uncachedIPs = ips.filter(ip => !results[ip]);
      if (uncachedIPs.length === 0) return;
      
      const batchSize = 10;
      
      for (let i = 0; i < uncachedIPs.length; i += batchSize) {
        const batch = uncachedIPs.slice(i, i + batchSize);
        
        const promises = batch.map(async (ip) => {
          try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 5000);
            
            const res = await fetch(`https://ipwho.is/${ip}`, { signal: controller.signal });
            clearTimeout(timeout);
            
            if (res.ok) {
              const d = await res.json();
              if (d.success !== false && d.latitude && d.longitude) {
                results[ip] = {
                  country: d.country,
                  countryCode: d.country_code,
                  city: d.city || 'Unknown',
                  lat: d.latitude,
                  lon: d.longitude
                };
              }
            }
          } catch (e) { /* Individual IP lookup failed - continue with others */ }
        });
        
        await Promise.all(promises);
        
        if (i % 50 === 0) {
          saveGeoCache(results);
        }
        
        await new Promise(r => setTimeout(r, 1000));
      }
      
      saveGeoCache(results);
    }

    // Load and display validator locations
    async function loadValidatorLocations() {
      try {
        // First try to load pre-generated static data
        const staticData = await loadStaticGeoData();
        
        if (staticData && staticData.locations && Object.keys(staticData.locations).length > 100) {
          // Use static data - instant load!
          document.getElementById('mapLoading').style.display = 'none';
          
          // Render countries from static data
          if (staticData.countries) {
            const sortedCountries = Object.entries(staticData.countries)
              .sort((a, b) => b[1].count - a[1].count);
            
            const countryListHtml = sortedCountries.map(([code, data]) => `
              <div class="country-item">
                <div class="country-info">
                  <span class="country-flag">${countryFlags[code] || ''}</span>
                  <span class="country-name">${data.name}</span>
                </div>
                <span class="country-count">${data.count}</span>
              </div>
            `).join('');
            
            document.getElementById('countryList').innerHTML = countryListHtml;
          }
          
          // Add markers from static data
          const markerGroup = L.featureGroup();
          
          Object.entries(staticData.locations).forEach(([ip, loc]) => {
            if (!loc || !loc.lat || !loc.lon) return;
            
            const marker = L.marker(
              [loc.lat + (Math.random() - 0.5) * 0.2, loc.lon + (Math.random() - 0.5) * 0.2], 
              { icon: createGlowDot() }
            );
            
            marker.bindPopup(`
              <div class="popup-validator-name">${loc.city}</div>
              <div class="popup-validator-location">${loc.country}</div>
            `);
            
            markerGroup.addLayer(marker);
          });
          
          markerGroup.addTo(validatorMap);
          return;
        }
        
        // Fall back to dynamic loading
        const nodes = await getClusterNodesWithIPs();
        
        if (!nodes || nodes.length === 0) {
          document.getElementById('mapLoading').style.display = 'none';
          document.getElementById('countryList').innerHTML = '<div class="map-loading-text">No validator data available</div>';
          return;
        }

        // Extract unique IPs
        const ipSet = new Set();
        const nodeMap = {}; // IP -> node info
        
        nodes.forEach(node => {
          if (node.gossip) {
            const ip = node.gossip.split(':')[0];
            if (ip && !ip.startsWith('127.') && !ip.startsWith('10.') && !ip.startsWith('192.168.') && !ip.startsWith('0.')) {
              ipSet.add(ip);
              if (!nodeMap[ip]) nodeMap[ip] = [];
              nodeMap[ip].push(node);
            }
          }
        });

        const uniqueIPs = Array.from(ipSet);
        const totalNodes = nodes.length;
        
        // Update loading text to show progress
        const loadingTextEl = document.querySelector('#mapLoading .map-loading-text');
        
        // Geolocate ALL IPs with progress updates
        const locations = await batchGeolocateIPs(uniqueIPs, (processed, total, found) => {
          if (loadingTextEl) {
            loadingTextEl.textContent = `Locating validators... ${found} found (${processed}/${total} IPs checked)`;
          }
        });
        
        // Hide loading
        document.getElementById('mapLoading').style.display = 'none';
        
        // Count validators per country and collect marker data
        const countryCount = {};
        const markers = [];
        
        Object.entries(locations).forEach(([ip, loc]) => {
          if (!loc || !loc.lat || !loc.lon) return;
          
          const nodesAtIP = nodeMap[ip] || [];
          const validatorCount = nodesAtIP.length;
          
          // Count by country
          if (!countryCount[loc.countryCode]) {
            countryCount[loc.countryCode] = {
              name: loc.country,
              count: 0
            };
          }
          countryCount[loc.countryCode].count += validatorCount;
          
          // Add marker
          nodesAtIP.forEach(node => {
            // Find validator name
            const validator = allValidators.find(v => v.nodePubkey === node.pubkey);
            const name = validator ? validator.name : node.pubkey.slice(0, 12) + '...';
            
            markers.push({
              lat: loc.lat + (Math.random() - 0.5) * 0.3,
              lon: loc.lon + (Math.random() - 0.5) * 0.3,
              name: name,
              city: loc.city,
              country: loc.country,
              pubkey: node.pubkey,
              version: node.version
            });
          });
        });

        // Add markers to map
        if (markers.length > 0) {
          const markerGroup = L.featureGroup();
          
          markers.forEach(m => {
            const marker = L.marker([m.lat, m.lon], { icon: createGlowDot() });
            
            const versionOutdated = isVersionOutdated(m.version);
            const versionWarning = versionOutdated ? ' <span style="color: #ffc107;"> Update</span>' : '';
            
            marker.bindPopup(`
              <div class="popup-validator-name">${m.name}</div>
              <div class="popup-validator-location">${m.city}, ${m.country}</div>
              <div class="popup-validator-location" style="margin-top: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.7rem;">v${m.version || 'unknown'}${versionWarning}</div>
            `);
            
            markerGroup.addLayer(marker);
          });
          
          markerGroup.addTo(validatorMap);
        }
        
        // Update country list sidebar
        const sortedCountries = Object.entries(countryCount)
          .sort((a, b) => b[1].count - a[1].count);
        
        if (sortedCountries.length > 0) {
          const countryListHtml = sortedCountries.map(([code, data]) => `
            <div class="country-item">
              <div class="country-info">
                <span class="country-flag">${countryFlags[code] || ''}</span>
                <span class="country-name">${data.name}</span>
              </div>
              <span class="country-count">${data.count}</span>
            </div>
          `).join('');
          
          document.getElementById('countryList').innerHTML = countryListHtml;
        } else {
          document.getElementById('countryList').innerHTML = '<div class="map-loading-text" style="padding: 1rem;">Could not load location data. Map shows network nodes exist but geolocation unavailable.</div>';
        }

      } catch (err) {
        console.error('Error loading validator locations:', err);
        document.getElementById('mapLoading').style.display = 'none';
        document.getElementById('countryList').innerHTML = '<div class="map-loading-text">Error loading data</div>';
      }
    }

    // Tab switching
    // =========================================
    // LEADERBOARDS
    // =========================================
    
    let currentLeaderboard = 'performance';
    let leaderboardData = null;
    
    function switchLeaderboard(category) {
      currentLeaderboard = category;
      
      // Update active button
      document.querySelectorAll('.leaderboard-cat-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector(`.leaderboard-cat-btn[onclick="switchLeaderboard('${category}')"]`).classList.add('active');
      
      // Update header
      const header = document.getElementById('leaderboardHeader');
      const headers = {
        'performance': { title: ' Top Performance Score', subtitle: 'Validators ranked by 7-day performance score' },
        'stake': { title: ' Most Stake', subtitle: 'Validators with the highest total stake' },
        'commission': { title: ' Lowest Commission', subtitle: 'Active validators with the lowest commission rates' },
        'efficient': { title: ' Most Efficient', subtitle: 'Validators earning the most credits relative to their stake' },
        'reliable': { title: ' Most Reliable', subtitle: 'Validators with the lowest skip rates and best uptime' },
        'newest': { title: ' Newest Validators', subtitle: 'Most recently started validators on the network' }
      };
      header.innerHTML = `<h2>${headers[category].title}</h2><p class="leaderboard-subtitle">${headers[category].subtitle}</p>`;
      
      // Render the list
      renderLeaderboard(category);
    }
    
    async function loadLeaderboard() {
      const loading = document.getElementById('leaderboardLoading');
      const container = document.getElementById('leaderboardContainer');
      
      if (!allValidators || allValidators.length === 0) {
        loading.style.display = 'flex';
        container.style.display = 'none';
        await loadNetworkStats();
      }
      
      // Make sure skip rates are loaded
      if (!allValidators[0] || allValidators[0].skipRate === undefined) {
        loading.style.display = 'flex';
        container.style.display = 'none';
        await fetchAllSkipRates();
      }
      
      loading.style.display = 'none';
      container.style.display = 'block';
      
      // Calculate performance scores - use cached validator info if available for consistency
      leaderboardData = allValidators.map(v => {
        // Check if we have cached detailed info for this validator
        const cached = validatorInfoCache[v.votePubkey];
        
        if (cached && cached.performanceScore !== undefined) {
          // Use cached performance score directly for consistency with validator card
          return {
            ...v,
            ...cached,
            activatedStake: v.activatedStake, // Keep lamports for leaderboard display
            performanceScore: cached.performanceScore
          };
        }
        
        // No cache - use allValidators data but check for skip rate history cache
        const skipHistoryFromCache = skipRateHistoryCache[v.nodePubkey];
        const validatorData = {
          ...v,
          epochCreditsHistory: v.epochCredits || [],
          isDelinquent: v.delinquent,
          skipRateHistory: skipHistoryFromCache ? skipHistoryFromCache.data : null
        };
        
        const score = calculatePerformanceScore(validatorData);
        
        return {
          ...validatorData,
          performanceScore: score
        };
      });
      
      renderLeaderboard(currentLeaderboard);
    }
    
    function renderLeaderboard(category) {
      if (!leaderboardData || leaderboardData.length === 0) {
        document.getElementById('leaderboardList').innerHTML = '<p style="text-align: center; color: var(--text-dim);">No data available</p>';
        return;
      }
      
      let sorted = [...leaderboardData];
      
      // Sort based on category
      switch (category) {
        case 'performance':
          sorted = sorted.filter(v => v.performanceScore > 0).sort((a, b) => b.performanceScore - a.performanceScore);
          break;
        case 'stake':
          sorted = sorted.sort((a, b) => b.activatedStake - a.activatedStake);
          break;
        case 'commission':
          // Only active validators with some minimum stake
          sorted = sorted.filter(v => !v.delinquent && v.activatedStake > 10000)
                        .sort((a, b) => a.commission - b.commission);
          break;
        case 'efficient':
          // Validators with highest credits efficiency (credits per stake)
          sorted = sorted.filter(v => {
              const stakeInXNT = v.activatedStake / 1e9;
              const credits = v.epochCredits && v.epochCredits.length > 0 ? v.epochCredits[v.epochCredits.length - 1][1] - v.epochCredits[v.epochCredits.length - 1][2] : 0;
              return credits > 0 && stakeInXNT > 1000 && !v.delinquent;
            })
            .map(v => {
              const stakeInXNT = v.activatedStake / 1e9;
              const credits = v.epochCredits[v.epochCredits.length - 1][1] - v.epochCredits[v.epochCredits.length - 1][2];
              v.efficiencyRatio = credits / (stakeInXNT / 1000000); // Credits per 1M XNT
              return v;
            })
            .sort((a, b) => b.efficiencyRatio - a.efficiencyRatio);
          break;
        case 'reliable':
          // Validators with lowest skip rates and best uptime - must have skip rate data
          sorted = sorted.filter(v => 
              v.skipRate !== null && 
              v.skipRate !== undefined && 
              !v.delinquent &&
              v.activatedStake > 10000 * 1e9
            )
            .sort((a, b) => {
              // Primary: lowest skip rate
              if (a.skipRate !== b.skipRate) return a.skipRate - b.skipRate;
              // Secondary: highest performance score
              return b.performanceScore - a.performanceScore;
            });
          break;
        case 'newest':
          // Most recently activated validators - sorted by first epoch in their credits history
          // First, determine the current epoch from the data
          let maxEpochSeen = 0;
          sorted.forEach(v => {
            if (v.epochCredits && v.epochCredits.length > 0) {
              const latestEpoch = v.epochCredits[v.epochCredits.length - 1][0];
              if (latestEpoch > maxEpochSeen) maxEpochSeen = latestEpoch;
            }
          });
          const currentEpoch = maxEpochSeen || currentEpochNumber || 0;
          
          sorted = sorted.filter(v => 
              v.epochCredits && 
              v.epochCredits.length > 0 && 
              !v.delinquent
            )
            .map(v => {
              // Get the first (oldest) epoch in their history
              v.firstEpoch = v.epochCredits[0][0];
              v.epochsActive = v.epochCredits.length;
              v.epochsAgo = currentEpoch - v.firstEpoch;
              return v;
            })
            .sort((a, b) => {
              // Sort by first epoch descending (highest/newest first)
              return b.firstEpoch - a.firstEpoch;
            })
            .slice(0, 50); // Take top 50 newest, then group
          break;
      }
      
      // Take top 20
      const top20 = sorted.slice(0, 20);
      
      const list = document.getElementById('leaderboardList');
      
      if (top20.length === 0) {
        list.innerHTML = '<p style="text-align: center; color: var(--text-dim); padding: 2rem;">No validators match this criteria</p>';
        return;
      }
      
      // Special rendering for newest validators - grouped by time period
      if (category === 'newest') {
        // Group by how long ago they started
        const currentEpochValidators = top20.filter(v => v.epochsAgo === 0);
        const lastEpochValidators = top20.filter(v => v.epochsAgo === 1);
        const recentValidators = top20.filter(v => v.epochsAgo >= 2);
        
        const renderNewestGroup = (validators, title) => {
          if (validators.length === 0) return '';
          
          return `
            <div class="newest-group">
              <div class="newest-group-title">${title}</div>
              ${validators.map(v => {
                // Logo
                let logoHtml;
                if (v.iconUrl) {
                  logoHtml = `<img class="leaderboard-logo" src="${v.iconUrl}" alt="${v.name}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
                              <div class="leaderboard-logo-placeholder" style="display:none;">${v.name.charAt(0).toUpperCase()}</div>`;
                } else {
                  logoHtml = `<div class="leaderboard-logo-placeholder">${v.name.charAt(0).toUpperCase()}</div>`;
                }
                
                return `
                  <div class="leaderboard-item newest-item" onclick="lookupValidator('${v.votePubkey}')">
                    <div class="newest-badge"></div>
                    <div class="leaderboard-validator">
                      ${logoHtml}
                      <div class="leaderboard-name">${v.name}</div>
                    </div>
                    <div class="leaderboard-stats">
                      <div class="leaderboard-stat">
                        <div class="leaderboard-stat-value highlight">Epoch ${v.firstEpoch}</div>
                        <div class="leaderboard-stat-label">Started</div>
                      </div>
                      <div class="leaderboard-stat">
                        <div class="leaderboard-stat-value">${formatStake(v.activatedStake)}</div>
                        <div class="leaderboard-stat-label">Stake</div>
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          `;
        };
        
        let html = '';
        html += renderNewestGroup(currentEpochValidators, ' Started This Epoch');
        html += renderNewestGroup(lastEpochValidators, ' Started Last Epoch');
        html += renderNewestGroup(recentValidators, ' Started Recently');
        
        if (html === '') {
          list.innerHTML = '<p style="text-align: center; color: var(--text-dim); padding: 2rem;">No validators found</p>';
        } else {
          list.innerHTML = html;
        }
        return;
      }
      
      list.innerHTML = top20.map((v, index) => {
        const rank = index + 1;
        const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : 'normal';
        const itemClass = rank <= 3 ? rankClass : '';
        const rankDisplay = rank === 1 ? '' : rank === 2 ? '' : rank === 3 ? '' : `#${rank}`;
        
        // Logo
        let logoHtml;
        if (v.iconUrl) {
          logoHtml = `<img class="leaderboard-logo" src="${v.iconUrl}" alt="${v.name}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
                      <div class="leaderboard-logo-placeholder" style="display:none;">${v.name.charAt(0).toUpperCase()}</div>`;
        } else {
          logoHtml = `<div class="leaderboard-logo-placeholder">${v.name.charAt(0).toUpperCase()}</div>`;
        }
        
        // Stats based on category
        let statsHtml = '';
        switch (category) {
          case 'performance':
            const perfScoreClass = getScoreColorClass(v.performanceScore);
            statsHtml = `
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value ${perfScoreClass}">${v.performanceScore.toFixed(2)}</div>
                <div class="leaderboard-stat-label">Score</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value">${formatStake(v.activatedStake)}</div>
                <div class="leaderboard-stat-label">Stake</div>
              </div>`;
            break;
          case 'stake':
            statsHtml = `
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value highlight">${formatStake(v.activatedStake)}</div>
                <div class="leaderboard-stat-label">Stake</div>
              </div>`;
            break;
          case 'commission':
            const commClass = getCommissionColorClass(v.commission);
            statsHtml = `
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value ${commClass}">${v.commission}%</div>
                <div class="leaderboard-stat-label">Commission</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value">${formatStake(v.activatedStake)}</div>
                <div class="leaderboard-stat-label">Stake</div>
              </div>`;
            break;
          case 'efficient':
            const effRatio = v.efficiencyRatio ? formatCompact(v.efficiencyRatio) : 'N/A';
            const effScoreClass = v.performanceScore > 0 ? getScoreColorClass(v.performanceScore) : '';
            statsHtml = `
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value highlight">${effRatio}</div>
                <div class="leaderboard-stat-label">Credits/1M XNT</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value ${effScoreClass}">${v.performanceScore > 0 ? v.performanceScore.toFixed(2) : 'N/A'}</div>
                <div class="leaderboard-stat-label">Score</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value">${formatStake(v.activatedStake)}</div>
                <div class="leaderboard-stat-label">Stake</div>
              </div>`;
            break;
          case 'reliable':
            // Use 7-epoch average if available, otherwise current epoch
            const avgSkip = v.skipRateHistory && v.skipRateHistory.avgSkipRate !== null ? v.skipRateHistory.avgSkipRate : v.skipRate;
            const skipRateDisplay = avgSkip !== null && avgSkip !== undefined ? avgSkip.toFixed(2) + '%' : 'N/A';
            const skipClass = getSkipRateColorClass(avgSkip);
            const relScoreClass = v.performanceScore > 0 ? getScoreColorClass(v.performanceScore) : '';
            statsHtml = `
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value ${skipClass}">${skipRateDisplay}</div>
                <div class="leaderboard-stat-label">Skip Rate</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value ${relScoreClass}">${v.performanceScore > 0 ? v.performanceScore.toFixed(2) : 'N/A'}</div>
                <div class="leaderboard-stat-label">Score</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value">${formatStake(v.activatedStake)}</div>
                <div class="leaderboard-stat-label">Stake</div>
              </div>`;
            break;
          case 'newest':
            const newScoreClass = v.performanceScore > 0 ? getScoreColorClass(v.performanceScore) : '';
            statsHtml = `
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value highlight">Epoch ${v.firstEpoch}</div>
                <div class="leaderboard-stat-label">Started</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value ${newScoreClass}">${v.performanceScore > 0 ? v.performanceScore.toFixed(2) : 'N/A'}</div>
                <div class="leaderboard-stat-label">Score</div>
              </div>
              <div class="leaderboard-stat">
                <div class="leaderboard-stat-value">${formatStake(v.activatedStake)}</div>
                <div class="leaderboard-stat-label">Stake</div>
              </div>`;
            break;
        }
        
        return `
          <div class="leaderboard-item ${itemClass}" onclick="lookupValidator('${v.votePubkey}')">
            <div class="leaderboard-rank ${rankClass}">${rankDisplay}</div>
            <div class="leaderboard-validator">
              ${logoHtml}
              <div class="leaderboard-name">${v.name}</div>
            </div>
            <div class="leaderboard-stats">
              ${statsHtml}
            </div>
          </div>
        `;
      }).join('');
    }

    // ========== COMPARE TOOL ==========
    let compareValidators = []; // Array of up to 4 validators
    let compareSearchTimeout = null;

    function handleCompareSearch() {
      const input = document.getElementById('compareSearchInput');
      const query = input.value.trim().toLowerCase();
      const resultsContainer = document.getElementById('compareSearchResults');

      clearTimeout(compareSearchTimeout);

      if (query.length < 2) {
        resultsContainer.classList.remove('active');
        return;
      }

      compareSearchTimeout = setTimeout(() => {
        if (!allValidators || allValidators.length === 0) {
          resultsContainer.innerHTML = '<div class="compare-search-result">Loading validators...</div>';
          resultsContainer.classList.add('active');
          return;
        }

        const matches = allValidators.filter(v => {
          const nameMatch = v.name.toLowerCase().includes(query);
          const addressMatch = v.votePubkey.toLowerCase().includes(query);
          const alreadyAdded = compareValidators.some(cv => cv.votePubkey === v.votePubkey);
          return (nameMatch || addressMatch) && !alreadyAdded;
        }).slice(0, 10);

        if (matches.length === 0) {
          resultsContainer.innerHTML = '<div class="compare-search-result" style="color: var(--text-dim);">No validators found</div>';
        } else {
          resultsContainer.innerHTML = matches.map(v => {
            const logoHtml = v.iconUrl
              ? `<img class="compare-search-result-logo" src="${v.iconUrl}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
                 <div class="compare-search-result-logo-placeholder" style="display:none;">${v.name.charAt(0).toUpperCase()}</div>`
              : `<div class="compare-search-result-logo-placeholder">${v.name.charAt(0).toUpperCase()}</div>`;

            return `
              <div class="compare-search-result" onclick="addToComparison('${v.votePubkey}')">
                ${logoHtml}
                <div class="compare-search-result-info">
                  <div class="compare-search-result-name">${v.name}</div>
                  <div class="compare-search-result-address">${v.votePubkey.slice(0, 8)}...${v.votePubkey.slice(-6)}</div>
                </div>
              </div>
            `;
          }).join('');
        }
        resultsContainer.classList.add('active');
      }, 200);
    }

    function focusCompareSearch() {
      document.getElementById('compareSearchInput').focus();
    }

    async function addToComparison(votePubkey) {
      if (compareValidators.length >= 4) {
        showToast('Maximum 4 validators can be compared');
        return;
      }

      if (compareValidators.some(v => v.votePubkey === votePubkey)) {
        showToast('Validator already added to comparison');
        return;
      }

      // Find validator in allValidators
      let validator = allValidators.find(v => v.votePubkey === votePubkey);
      if (!validator) {
        showToast('Validator not found');
        return;
      }

      // Get detailed info
      const detailedInfo = await getValidatorInfo(votePubkey);
      if (detailedInfo) {
        validator = { ...validator, ...detailedInfo };
      }

      // Fetch last epoch rewards
      try {
        const rewards = await fetchTotalValidatorRewards(votePubkey, validator.commission || 0, 1);
        if (rewards && rewards.length > 0) {
          validator.lastEpochReward = rewards[0].amount / 1e9; // Convert lamports to XNT
          validator.lastEpochRewardEpoch = rewards[0].epoch;
        }
      } catch (e) {
        console.warn('Could not fetch last epoch rewards for comparison:', e);
      }

      // Use cached performance score if available, otherwise calculate
      if (validator.performanceScore === undefined) {
        validator.performanceScore = calculatePerformanceScore(validator);
      }

      compareValidators.push(validator);
      
      // Clear search
      const searchInput = document.getElementById('compareSearchInput');
      const searchResults = document.getElementById('compareSearchResults');
      if (searchInput) searchInput.value = '';
      if (searchResults) searchResults.classList.remove('active');

      renderComparison();
      
      // Show helpful toast with count
      const count = compareValidators.length;
      if (count === 1) {
        showToast(`Added ${validator.name} to comparison. Add more validators to compare!`);
      } else if (count < 4) {
        showToast(`Added ${validator.name} (${count}/4). Go to Compare tab to see results.`);
      } else {
        showToast(`Added ${validator.name}. Comparison full (4/4)!`);
      }
    }

    function removeFromComparison(votePubkey) {
      compareValidators = compareValidators.filter(v => v.votePubkey !== votePubkey);
      renderComparison();
    }

    function clearComparison() {
      compareValidators = [];
      renderComparison();
    }

    function updateCompareCount() {
      const countEl = document.getElementById('compareCount');
      if (countEl) {
        countEl.textContent = compareValidators.length > 0 ? `(${compareValidators.length})` : '';
      }
    }

    function renderComparison() {
      updateCompareCount();
      const slotsContainer = document.getElementById('compareSlots');
      const tableContainer = document.getElementById('compareTableContainer');
      const emptyState = document.getElementById('compareEmptyState');

      // Render slots
      for (let i = 0; i < 4; i++) {
        const slot = document.getElementById(`compareSlot${i}`);
        const validator = compareValidators[i];

        if (validator) {
          const logoHtml = validator.iconUrl
            ? `<img class="compare-slot-logo" src="${validator.iconUrl}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
               <div class="compare-slot-logo-placeholder" style="display:none;">${validator.name.charAt(0).toUpperCase()}</div>`
            : `<div class="compare-slot-logo-placeholder">${validator.name.charAt(0).toUpperCase()}</div>`;

          const scoreColor = getPerformanceBarColor(validator.performanceScore);

          slot.className = 'compare-slot filled';
          slot.onclick = null;
          slot.innerHTML = `
            <button class="compare-slot-remove" onclick="removeFromComparison('${validator.votePubkey}')">&times;</button>
            <div class="compare-slot-header">
              ${logoHtml}
              <div class="compare-slot-name">${validator.name}</div>
            </div>
            <div class="compare-slot-score" style="color: ${scoreColor}">${validator.performanceScore.toFixed(2)}</div>
            <div class="compare-slot-score-label">Performance Score</div>
          `;
        } else {
          slot.className = 'compare-slot empty';
          slot.onclick = focusCompareSearch;
          slot.innerHTML = `
            <div class="compare-slot-empty">
              <span class="compare-slot-plus">+</span>
              <span>Add Validator</span>
            </div>
          `;
        }
      }

      // Show/hide table and empty state
      if (compareValidators.length >= 2) {
        tableContainer.style.display = 'block';
        emptyState.style.display = 'none';
        renderComparisonTable();
      } else {
        tableContainer.style.display = 'none';
        emptyState.style.display = compareValidators.length === 0 ? 'block' : 'none';
      }
    }

    function renderComparisonTable() {
      const table = document.getElementById('compareTable');
      const cols = compareValidators.length;
      table.style.setProperty('--compare-cols', cols);

      // Define comparison metrics
      const metrics = [
        { 
          label: 'Performance Score', 
          getValue: v => v.performanceScore.toFixed(2),
          getRaw: v => v.performanceScore,
          higherIsBetter: true,
          getColor: v => getPerformanceBarColor(v.performanceScore)
        },
        { 
          label: 'Commission', 
          getValue: v => v.commission + '%',
          getRaw: v => v.commission,
          higherIsBetter: false,
          getColor: v => v.commission <= 5 ? 'var(--success)' : v.commission <= 10 ? 'var(--warning)' : 'var(--danger)'
        },
        { 
          label: 'Last Epoch Earned', 
          getValue: v => {
            if (v.lastEpochReward !== undefined) {
              return formatNumber(v.lastEpochReward, 2) + ' XNT';
            }
            return 'Loading...';
          },
          getRaw: v => v.lastEpochReward || 0,
          higherIsBetter: true,
          getColor: () => 'var(--success)'
        },
        { 
          label: 'Skip Rate (7d avg)', 
          getValue: v => {
            const rate = v.skipRateHistory?.avgSkipRate ?? v.skipRate;
            return rate !== null && rate !== undefined ? rate.toFixed(2) + '%' : 'N/A';
          },
          getRaw: v => v.skipRateHistory?.avgSkipRate ?? v.skipRate ?? 999,
          higherIsBetter: false,
          getColor: v => {
            const rate = v.skipRateHistory?.avgSkipRate ?? v.skipRate;
            if (rate === null || rate === undefined) return 'var(--text-dim)';
            if (rate <= 0.5) return 'var(--success)';
            if (rate <= 1) return 'var(--warning)';
            return 'var(--danger)';
          }
        },
        { 
          label: 'Epoch Credits', 
          getValue: v => {
            const credits = v.epochCredits || 0;
            return formatCompact(credits);
          },
          getRaw: v => v.epochCredits || 0,
          higherIsBetter: true,
          getColor: () => 'var(--accent-blue)'
        },
        { 
          label: 'Total Stake', 
          getValue: v => {
            // activatedStake could be in lamports (from allValidators) or XNT (from getValidatorInfo)
            const stake = v.activatedStake || 0;
            // If stake is very large (> 1 billion), it's in lamports
            const xnt = stake > 1e9 ? stake / 1e9 : stake;
            return formatCompact(xnt) + ' XNT';
          },
          getRaw: v => {
            const stake = v.activatedStake || 0;
            return stake > 1e9 ? stake / 1e9 : stake;
          },
          higherIsBetter: true,
          getColor: () => 'var(--accent-cyan)'
        },
        { 
          label: 'Rewards Balance', 
          getValue: v => formatNumber(v.rewardsBalance || 0, 2) + ' XNT',
          getRaw: v => v.rewardsBalance || 0,
          higherIsBetter: true,
          getColor: () => 'var(--warning)'
        },
        { 
          label: 'Status', 
          getValue: v => v.delinquent || v.isDelinquent ? 'Delinquent' : 'Active',
          getRaw: v => v.delinquent || v.isDelinquent ? 0 : 1,
          higherIsBetter: true,
          getColor: v => v.delinquent || v.isDelinquent ? 'var(--danger)' : 'var(--success)'
        },
        { 
          label: 'Version', 
          getValue: v => v.version || 'Unknown',
          getRaw: v => v.version || '',
          higherIsBetter: null, // No comparison
          getColor: v => isVersionOutdated(v.version) ? 'var(--warning)' : 'var(--text-primary)'
        },
        { 
          label: 'First Seen', 
          getValue: v => {
            // Show the first epoch we have data for
            // RPC only returns last 64 epochs, so if first epoch is 64+ ago, show "64+ epochs"
            if (v.epochCreditsHistory && v.epochCreditsHistory.length > 0) {
              const firstEpoch = v.epochCreditsHistory[0][0];
              const currentEpoch = v.epochCreditsHistory[v.epochCreditsHistory.length - 1][0];
              const epochsAgo = currentEpoch - firstEpoch;
              
              if (v.epochCreditsHistory.length >= 64) {
                return 'Epoch ' + firstEpoch + '+';
              } else {
                return 'Epoch ' + firstEpoch;
              }
            }
            return 'Unknown';
          },
          getRaw: v => {
            if (v.epochCreditsHistory && v.epochCreditsHistory.length > 0) {
              return v.epochCreditsHistory[0][0];
            }
            return 0;
          },
          higherIsBetter: null, // Not really comparable
          getColor: v => {
            if (!v.epochCreditsHistory || v.epochCreditsHistory.length === 0) return 'var(--text-dim)';
            // Green if they have full 64 epoch history (established)
            if (v.epochCreditsHistory.length >= 64) return 'var(--success)';
            // Yellow if newer (less than 64 epochs)
            if (v.epochCreditsHistory.length >= 10) return 'var(--warning)';
            return 'var(--text-dim)';
          }
        }
      ];

      // Find best values for each metric
      const bestValues = metrics.map(metric => {
        if (metric.higherIsBetter === null) return null;
        const values = compareValidators.map(v => metric.getRaw(v));
        if (metric.higherIsBetter) {
          return Math.max(...values);
        } else {
          return Math.min(...values);
        }
      });

      // Build table HTML
      let html = '';

      // Header row with validator names
      html += `<div class="compare-row compare-row-header">
        <div class="compare-cell compare-cell-label">Metric</div>
        ${compareValidators.map(v => `<div class="compare-cell compare-cell-value">${v.name}</div>`).join('')}
      </div>`;

      // Metric rows
      metrics.forEach((metric, idx) => {
        html += `<div class="compare-row">
          <div class="compare-cell compare-cell-label">${metric.label}</div>
          ${compareValidators.map(v => {
            const value = metric.getValue(v);
            const raw = metric.getRaw(v);
            const isBest = bestValues[idx] !== null && raw === bestValues[idx];
            const color = metric.getColor(v);
            return `<div class="compare-cell compare-cell-value ${isBest ? 'compare-cell-best' : ''}" style="color: ${color}">${value}</div>`;
          }).join('')}
        </div>`;
      });

      table.innerHTML = html;
    }

    function openCompareValidatorList() {
      openValidatorList('compare');
    }

    // Close compare search results when clicking outside
    document.addEventListener('click', function(e) {
      const searchBox = document.querySelector('.compare-search-box');
      const results = document.getElementById('compareSearchResults');
      if (searchBox && results && !searchBox.contains(e.target)) {
        results.classList.remove('active');
      }
    });

    // Modify the existing selectValidatorForSearch to handle compare mode
    const originalSelectValidatorForSearch = typeof selectValidatorForSearch === 'function' ? selectValidatorForSearch : null;
    
    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add('active');

      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById(tab + 'Tab').classList.add('active');

      if (tab === 'portfolio') {
        loadPortfolio();
      }
      
      if (tab === 'map') {
        if (!window.mapInitialized) {
          initializeMap();
        } else if (validatorMap) {
          // Invalidate map size when returning to map tab
          // This fixes rendering issues when the map container was hidden
          setTimeout(() => {
            validatorMap.invalidateSize();
          }, 100);
        }
      }
      
      if (tab === 'leaderboard') {
        loadLeaderboard();
      }
      
      if (tab === 'calculators') {
        initializeCalculators();
      }
    }

    // =========================================
    // Calculator Functions
    // =========================================
    
    let calculatorsInitialized = false;
    let compoundChartInstance = null;
    let currentEpochData = null;
    
    function switchCalculator(calc) {
      // Update nav buttons
      document.querySelectorAll('.calc-nav-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector(`.calc-nav-btn[onclick="switchCalculator('${calc}')"]`).classList.add('active');
      
      // Show appropriate panel
      document.querySelectorAll('.calculator-panel').forEach(p => p.classList.remove('active'));
      
      const panelMap = {
        'staking': 'calcStaking',
        'compound': 'calcCompound',
        'unstaking': 'calcUnstaking',
        'breakeven': 'calcBreakeven'
      };
      
      document.getElementById(panelMap[calc]).classList.add('active');
      
      // Initialize specific calculator
      switch (calc) {
        case 'staking':
          onStakingValidatorChange();
          break;
        case 'compound':
          calculateCompoundGrowth();
          break;
        case 'unstaking':
          refreshEpochInfo();
          break;
        case 'breakeven':
          calculateBreakeven();
          break;
      }
    }
    
    async function initializeCalculators() {
      if (calculatorsInitialized) return;
      
      // Make sure we have network data loaded for validator info
      if (!allValidators || allValidators.length === 0) {
        await loadNetworkStats();
      }
      
      // Build portfolio options with names, then sort alphabetically
      let portfolioOptions = [];
      if (myPortfolio.length > 0) {
        portfolioOptions = myPortfolio.map(voteAccount => {
          // Try to get name from cache or allValidators
          let name = voteAccount.slice(0, 8) + '...';
          if (validatorInfoCache[voteAccount]) {
            name = validatorInfoCache[voteAccount].name;
          } else if (allValidators) {
            const v = allValidators.find(v => v.votePubkey === voteAccount);
            if (v) name = v.name || v.votePubkey.slice(0, 8) + '...';
          }
          return { voteAccount, name };
        });
        
        // Sort alphabetically by name
        portfolioOptions.sort((a, b) => a.name.localeCompare(b.name));
      }
      
      const portfolioOptionsHtml = portfolioOptions.map(opt => 
        `<option value="${opt.voteAccount}">${opt.name}</option>`
      ).join('');
      
      // Populate staking calculator validator dropdown
      const stakingSelect = document.getElementById('stakingValidator');
      if (myPortfolio.length > 0) {
        stakingSelect.innerHTML = '<option value="">-- Select from your Data Center --</option><option value="custom"> Custom / New Validator</option>' + portfolioOptionsHtml;
      } else {
        stakingSelect.innerHTML = '<option value="">-- No validators in Data Center --</option><option value="custom"> Custom / New Validator</option>';
      }
      
      // Populate compound calculator validator dropdown
      const compoundSelect = document.getElementById('compoundValidator');
      if (myPortfolio.length > 0) {
        compoundSelect.innerHTML = '<option value="">-- Select from your Data Center --</option><option value="custom"> Custom Values</option>' + portfolioOptionsHtml;
      } else {
        compoundSelect.innerHTML = '<option value="">-- No validators in Data Center --</option><option value="custom"> Custom Values</option>';
      }
      
      // Populate breakeven calculator validator dropdown
      const breakevenSelect = document.getElementById('breakevenValidator');
      if (myPortfolio.length > 0) {
        breakevenSelect.innerHTML = '<option value="">-- Select from your Data Center --</option><option value="custom"> Custom Values</option>' + portfolioOptionsHtml;
      } else {
        breakevenSelect.innerHTML = '<option value="">-- No validators in Data Center --</option><option value="custom"> Custom Values</option>';
      }
      
      // Initialize all calculators with default values (show empty states)
      onStakingValidatorChange();
      calculateCompoundGrowth();
      calculateBreakeven();
      
      // Setup unstaking when dropdown
      document.getElementById('unstakingWhen').addEventListener('change', function() {
        const customInput = document.getElementById('unstakingCustomEpoch');
        customInput.style.display = this.value === 'custom' ? 'block' : 'none';
      });
      
      calculatorsInitialized = true;
    }
    
    // ===== STAKING REWARDS CALCULATOR =====
    let stakingCurrency = 'xnt'; // 'xnt' or 'usd'
    let stakingCalcData = { currentStake: 0, commission: 0, selfStake: 0, delegatedStake: 0 };
    let stakingProjectionPeriod = 'yearly'; // 'yearly' or 'monthly'
    let stakingRealRewardsData = null;
    
    function formatStakingInput(input) {
      let value = input.value.replace(/[^0-9.]/g, '');
      if (value) {
        const num = parseFloat(value);
        if (!isNaN(num)) {
          input.value = num.toLocaleString('en-US');
        }
      }
    }
    
    function toggleStakingCurrency(currency, button) {
      stakingCurrency = currency;
      document.querySelectorAll('#stakingCurrencyToggle .calc-currency-btn').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      renderStakingResults();
    }
    
    async function onStakingValidatorChange() {
      const validatorSelect = document.getElementById('stakingValidator');
      const resultsContent = document.getElementById('stakingResultsContent');
      const apyGroup = document.getElementById('stakingApyGroup');
      const customSelfGroup = document.getElementById('stakingCustomSelfGroup');
      const customDelegatedGroup = document.getElementById('stakingCustomDelegatedGroup');
      const customCommGroup = document.getElementById('stakingCustomCommGroup');
      const simInputs = document.getElementById('stakingSimInputs');
      const currencyToggle = document.getElementById('stakingCurrencyToggle');
      
      // Handle custom mode
      if (validatorSelect.value === 'custom') {
        apyGroup.style.display = 'block';
        customSelfGroup.style.display = 'block';
        customDelegatedGroup.style.display = 'block';
        customCommGroup.style.display = 'block';
        simInputs.style.display = 'none';
        currencyToggle.style.display = 'flex';
        document.getElementById('stakingCurrentStake').textContent = 'Enter your validator details below';
        stakingRealRewardsData = null;
        stakingCalcData = { currentStake: 0, commission: 0, selfStake: 0, delegatedStake: 0, isCustom: true };
        renderStakingResults();
        return;
      }
      
      // Hide custom inputs for real validators
      apyGroup.style.display = 'none';
      customSelfGroup.style.display = 'none';
      customDelegatedGroup.style.display = 'none';
      customCommGroup.style.display = 'none';
      stakingCalcData.isCustom = false;
      
      // If no validator selected, show empty state
      if (!validatorSelect.value) {
        simInputs.style.display = 'none';
        currencyToggle.style.display = 'none';
        stakingRealRewardsData = null;
        resultsContent.innerHTML = `
          <div class="calc-empty-state">
            <div class="calc-empty-icon"></div>
            <div class="calc-empty-text">Select a validator to see current earnings and simulate growth</div>
          </div>
        `;
        document.getElementById('stakingCurrentStake').textContent = 'Select a validator or use custom mode';
        return;
      }
      
      // Get current stake and commission from validator selection
      let currentStake = 0;
      let commission = 0;
      let validatorName = '';
      if (validatorInfoCache[validatorSelect.value]) {
        currentStake = validatorInfoCache[validatorSelect.value].activatedStake || 0;
        commission = validatorInfoCache[validatorSelect.value].commission || 0;
        validatorName = validatorInfoCache[validatorSelect.value].name || '';
      } else if (allValidators) {
        const validator = allValidators.find(v => v.votePubkey === validatorSelect.value);
        if (validator) {
          currentStake = validator.activatedStake / 1e9;
          commission = validator.commission || 0;
          validatorName = validator.name || '';
        }
      }
      
      stakingCalcData.currentStake = currentStake;
      stakingCalcData.commission = commission;
      stakingCalcData.validatorName = validatorName;
      
      // Show simulation inputs and currency toggle
      simInputs.style.display = 'block';
      currencyToggle.style.display = 'flex';
      
      // Check if we have stake breakdown data for this validator
      let breakdownData = window.stakeBreakdownData && window.stakeBreakdownData[validatorSelect.value];
      
      // If no breakdown data, auto-fetch it
      if (!breakdownData) {
        document.getElementById('stakingCurrentStake').innerHTML = `
          <span style="color: var(--text-secondary);">Loading stake breakdown...</span>
        `;
        
        // Fetch breakdown in background
        try {
          breakdownData = await fetchStakeBreakdownForCalc(validatorSelect.value, commission);
          if (breakdownData) {
            if (!window.stakeBreakdownData) window.stakeBreakdownData = {};
            window.stakeBreakdownData[validatorSelect.value] = breakdownData;
          }
        } catch (e) {
          console.warn('Could not auto-fetch breakdown:', e);
        }
      }
      
      if (breakdownData) {
        stakingCalcData.selfStake = breakdownData.selfStake;
        stakingCalcData.delegatedStake = breakdownData.delegatedStake;
        stakingCalcData.hasBreakdown = true;
        document.getElementById('stakingCurrentStake').innerHTML = `
          <span style="color: var(--success);"> Stake breakdown loaded</span> - 
          Self: ${formatNumber(breakdownData.selfStake, 0)} | Delegated: ${formatNumber(breakdownData.delegatedStake, 0)} | Commission: ${commission}%
          <span style="color: var(--accent-cyan); cursor: pointer; margin-left: 0.5rem;" onclick="openStakeBreakdown('${validatorSelect.value}', '${validatorName}', ${currentStake}, ${commission})"></span>
        `;
      } else {
        stakingCalcData.selfStake = 0;
        stakingCalcData.delegatedStake = 0;
        stakingCalcData.hasBreakdown = false;
        document.getElementById('stakingCurrentStake').innerHTML = `
          Total stake: ${formatNumber(currentStake, 0)} XNT | Commission: ${commission}%
          <span style="color: var(--accent-gold); cursor: pointer; margin-left: 0.5rem;" onclick="fetchAndShowBreakdown('${validatorSelect.value}', '${validatorName}', ${currentStake}, ${commission})"> Retry</span>
        `;
      }
      
      // Show loading while fetching real data
      resultsContent.innerHTML = `
        <div class="calc-loading">
          <div class="loading-spinner-small"></div>
          <span>Fetching validator data...</span>
        </div>
      `;
      
      // Fetch real rewards data (vote account + self-stake rewards)
      try {
        const rewards = await fetchTotalValidatorRewards(validatorSelect.value, commission, 7);
        if (rewards && rewards.length > 0) {
          const totalRewardsXNT = rewards.reduce((sum, r) => sum + r.amount, 0) / 1e9;
          const avgEpochRewardsXNT = totalRewardsXNT / rewards.length;
          
          // Calculate actual APY from real data
          const actualAPY = currentStake > 0 ? (avgEpochRewardsXNT * 365 / currentStake) * 100 : 0;
          
          stakingRealRewardsData = {
            avgEpoch: avgEpochRewardsXNT,
            totalFetched: totalRewardsXNT,
            epochs: rewards.length,
            actualAPY: actualAPY
          };
        } else {
          stakingRealRewardsData = null;
        }
      } catch (err) {
        console.error('Failed to fetch real rewards:', err);
        stakingRealRewardsData = null;
      }
      
      renderStakingResults();
    }
    
    // Fetch stake breakdown data for calculator (without opening modal)
    async function fetchStakeBreakdownForCalc(voteAccount, commission) {
      try {
        // Fetch all stake accounts for this validator
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getProgramAccounts',
            params: [
              'Stake11111111111111111111111111111111111111',
              {
                encoding: 'jsonParsed',
                filters: [{ memcmp: { offset: 124, bytes: voteAccount } }]
              }
            ]
          })
        });
        
        const data = await response.json();
        if (!data.result || data.result.length === 0) return null;
        
        // Get vote account's authorized withdrawer for matching
        let voteAccountWithdrawer = null;
        try {
          const voteAcctResponse = await fetch(RPC_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'getAccountInfo',
              params: [voteAccount, { encoding: 'jsonParsed' }]
            })
          });
          
          const voteAcctData = await voteAcctResponse.json();
          if (voteAcctData.result?.value?.data?.parsed?.info) {
            voteAccountWithdrawer = voteAcctData.result.value.data.parsed.info.authorizedWithdrawer;
          }
        } catch (e) {
          console.warn('Could not fetch vote account withdrawer:', e);
        }
        
        // Parse stake accounts
        const stakeAccounts = data.result.map(acc => {
          const stakeInfo = acc.account.data.parsed?.info;
          const meta = stakeInfo?.meta;
          return {
            pubkey: acc.pubkey,
            stakeXNT: acc.account.lamports / 1e9,
            withdrawer: meta?.authorized?.withdrawer || null
          };
        });
        
        // Check for user selections first
        const userSelections = getSelfStakeSelections(voteAccount);
        
        let selfStake = 0;
        let delegatedStake = 0;
        
        if (userSelections && userSelections.pubkeys && userSelections.pubkeys.length > 0) {
          const selectedPubkeys = new Set(userSelections.pubkeys);
          stakeAccounts.forEach(acc => {
            if (selectedPubkeys.has(acc.pubkey)) {
              selfStake += acc.stakeXNT;
            } else {
              delegatedStake += acc.stakeXNT;
            }
          });
        } else if (voteAccountWithdrawer) {
          // Use withdrawer matching
          stakeAccounts.forEach(acc => {
            if (acc.withdrawer === voteAccountWithdrawer) {
              selfStake += acc.stakeXNT;
            } else {
              delegatedStake += acc.stakeXNT;
            }
          });
        } else {
          // Fallback - treat all as delegated
          stakeAccounts.forEach(acc => {
            delegatedStake += acc.stakeXNT;
          });
        }
        
        return { selfStake, delegatedStake };
      } catch (e) {
        console.error('Error fetching breakdown for calc:', e);
        return null;
      }
    }
    
    // Helper function to fetch breakdown and update calculator
    async function fetchAndShowBreakdown(voteAccount, validatorName, totalStake, commission) {
      // Open the breakdown modal which will fetch and cache the data
      await openStakeBreakdown(voteAccount, validatorName, totalStake, commission);
      
      // After modal closes, the data should be cached - refresh the calculator
      setTimeout(() => {
        onStakingValidatorChange();
      }, 500);
    }
    
    function renderStakingResults() {
      const validatorSelect = document.getElementById('stakingValidator');
      const resultsContent = document.getElementById('stakingResultsContent');
      const currencyToggle = document.getElementById('stakingCurrencyToggle');
      const priceInput = document.getElementById('stakingPrice');
      
      const xntPrice = parseFloat(priceInput.value) || 1.00;
      
      // Helper to format value based on currency selection
      const formatValue = (xntAmount, decimals = 2) => {
        if (stakingCurrency === 'usd') {
          return '$' + formatNumber(xntAmount * xntPrice, decimals);
        }
        return formatNumber(xntAmount, decimals) + ' XNT';
      };
      
      // Handle custom mode
      if (validatorSelect.value === 'custom') {
        const apyInput = document.getElementById('stakingApy');
        const selfInput = document.getElementById('stakingCustomSelf');
        const delegatedInput = document.getElementById('stakingCustomDelegated');
        const commInput = document.getElementById('stakingCustomComm');
        
        const apy = parseFloat(apyInput.value) || 0;
        const selfStakeStr = selfInput.value.replace(/,/g, '');
        const delegatedStakeStr = delegatedInput.value.replace(/,/g, '');
        const selfStake = parseFloat(selfStakeStr) || 0;
        const delegatedStake = parseFloat(delegatedStakeStr) || 0;
        const commission = parseFloat(commInput.value) || 0;
        const totalStake = selfStake + delegatedStake;
        
        if (totalStake <= 0) {
          resultsContent.innerHTML = `
            <div class="calc-empty-state">
              <div class="calc-empty-icon"></div>
              <div class="calc-empty-text">Enter your self-stake and/or delegated amounts to see estimated rewards</div>
            </div>
          `;
          return;
        }
        
        // Calculate percentages
        const selfPercent = totalStake > 0 ? (selfStake / totalStake * 100).toFixed(0) : 0;
        const delegatedPercent = totalStake > 0 ? (delegatedStake / totalStake * 100).toFixed(0) : 0;
        
        // Calculate earnings
        const selfStakeEarnings = selfStake * (apy / 100);
        const commissionEarnings = delegatedStake * (apy / 100) * (commission / 100);
        const totalEarnings = selfStakeEarnings + commissionEarnings;
        
        resultsContent.innerHTML = `
          <div class="calc-current-breakdown">
            <div class="calc-breakdown-title"> Custom Validator Estimate</div>
            <div class="calc-breakdown-grid">
              <div class="calc-breakdown-item self">
                <div class="calc-breakdown-value">${formatNumber(selfStake, 0)}</div>
                <div class="calc-breakdown-label">Self-Stake (${selfPercent}%)</div>
              </div>
              <div class="calc-breakdown-item delegated">
                <div class="calc-breakdown-value">${formatNumber(delegatedStake, 0)}</div>
                <div class="calc-breakdown-label">Delegated (${delegatedPercent}%)</div>
              </div>
            </div>
          </div>
          
          <div class="calc-earnings-section">
            <div class="calc-earnings-title"> Estimated Annual Earnings</div>
            <div class="calc-earnings-row">
              <span class="calc-earnings-label">From Self-Stake (${apy}% APY)</span>
              <span class="calc-earnings-value">${formatValue(selfStakeEarnings)}</span>
            </div>
            <div class="calc-earnings-row">
              <span class="calc-earnings-label">From ${commission}% Commission</span>
              <span class="calc-earnings-value">${formatValue(commissionEarnings)}</span>
            </div>
            <div class="calc-earnings-row total">
              <span class="calc-earnings-label">Total Validator Earnings</span>
              <span class="calc-earnings-value">${formatValue(totalEarnings)}/year</span>
            </div>
          </div>
        `;
        return;
      }
      
      // If no validator selected
      if (!validatorSelect.value) {
        currencyToggle.style.display = 'none';
        return;
      }
      
      const { currentStake, commission, selfStake, delegatedStake, hasBreakdown, validatorName } = stakingCalcData;
      
      // Get simulation inputs
      const addSelfInput = document.getElementById('stakingAddSelf');
      const addDelegationInput = document.getElementById('stakingAddDelegation');
      const addSelfStr = addSelfInput ? addSelfInput.value.replace(/,/g, '') : '0';
      const addDelegationStr = addDelegationInput ? addDelegationInput.value.replace(/,/g, '') : '0';
      const addSelf = parseFloat(addSelfStr) || 0;
      const addDelegation = parseFloat(addDelegationStr) || 0;
      
      // Calculate actual APY from real rewards data
      let actualAPY = 8; // Default fallback
      if (stakingRealRewardsData && stakingRealRewardsData.actualAPY) {
        actualAPY = stakingRealRewardsData.actualAPY;
      }
      
      // For self-stake, APY is the full network rate (we derive it from actual data)
      // The validator's total rewards include: 100% of self-stake rewards + commission% of delegated stake rewards
      // So: totalRewards = selfStake * baseAPY + delegatedStake * baseAPY * (commission/100)
      // We know totalRewards from real data, and if we have breakdown, we can solve for baseAPY
      
      let baseAPY = 8; // Default network base APY
      if (hasBreakdown && stakingRealRewardsData && selfStake > 0) {
        const totalAnnualRewards = stakingRealRewardsData.avgEpoch * 365;
        // totalRewards = selfStake * baseAPY + delegatedStake * baseAPY * (commission/100)
        // totalRewards = baseAPY * (selfStake + delegatedStake * commission/100)
        const divisor = selfStake + (delegatedStake * commission / 100);
        if (divisor > 0) {
          baseAPY = (totalAnnualRewards / divisor) * 100;
        }
      }
      
      // Current earnings breakdown
      const currentSelfEarnings = selfStake * (baseAPY / 100);
      const currentCommissionEarnings = delegatedStake * (baseAPY / 100) * (commission / 100);
      const currentTotalEarnings = currentSelfEarnings + currentCommissionEarnings;
      
      // Calculate Validator APY = total earnings / self-stake (effective return on investment)
      const validatorAPY = selfStake > 0 ? (currentTotalEarnings / selfStake) * 100 : baseAPY;
      
      // Projected earnings with new stake
      const newSelfStake = selfStake + addSelf;
      const newDelegatedStake = delegatedStake + addDelegation;
      const newTotalStake = newSelfStake + newDelegatedStake;
      
      const projectedSelfEarnings = newSelfStake * (baseAPY / 100);
      const projectedCommissionEarnings = newDelegatedStake * (baseAPY / 100) * (commission / 100);
      const projectedTotalEarnings = projectedSelfEarnings + projectedCommissionEarnings;
      
      const earningsIncrease = projectedTotalEarnings - currentTotalEarnings;
      const earningsIncreasePercent = currentTotalEarnings > 0 ? (earningsIncrease / currentTotalEarnings) * 100 : 0;
      
      let html = '';
      
      // Show warning if no breakdown data
      if (!hasBreakdown) {
        html += `
          <div class="calc-no-breakdown-note">
            <span></span>
            <span>Stake breakdown not loaded. Click " Load breakdown" above for accurate self-stake vs delegation data. Currently using estimates.</span>
          </div>
        `;
      }
      
      // Current Stake Breakdown
      html += `
        <div class="calc-current-breakdown">
          <div class="calc-breakdown-title">
             Current Stake Breakdown
            <span class="calc-apy-badge"> ${formatNumber(validatorAPY, 2)}% Validator APY <span style="font-size: 0.7rem; opacity: 0.8;">(7-day avg)</span></span>
          </div>
          <div class="calc-breakdown-grid">
            <div class="calc-breakdown-item self">
              <div class="calc-breakdown-value">${formatNumber(selfStake, 0)}</div>
              <div class="calc-breakdown-label"> Self-Stake</div>
            </div>
            <div class="calc-breakdown-item delegated">
              <div class="calc-breakdown-value">${formatNumber(delegatedStake, 0)}</div>
              <div class="calc-breakdown-label"> Delegated</div>
            </div>
          </div>
        </div>
      `;
      
      // Current Earnings
      html += `
        <div class="calc-earnings-section">
          <div class="calc-earnings-title"> Current Annual Earnings</div>
          <div class="calc-earnings-row">
            <span class="calc-earnings-label">From Self-Stake (${formatNumber(baseAPY, 2)}% base APY)</span>
            <span class="calc-earnings-value">${formatValue(currentSelfEarnings)}</span>
          </div>
          <div class="calc-earnings-row">
            <span class="calc-earnings-label">From ${commission}% Commission on Delegations</span>
            <span class="calc-earnings-value">${formatValue(currentCommissionEarnings)}</span>
          </div>
          <div class="calc-earnings-row total">
            <span class="calc-earnings-label">Total Validator Earnings</span>
            <span class="calc-earnings-value">${formatValue(currentTotalEarnings)}/year</span>
          </div>
        </div>
      `;
      
      // Show projection if user entered simulation values
      if (addSelf > 0 || addDelegation > 0) {
        const isMonthly = stakingProjectionPeriod === 'monthly';
        const periodDivisor = isMonthly ? 12 : 1;
        const periodLabel = isMonthly ? '/month' : '/year';
        
        const displayCurrentEarnings = currentTotalEarnings / periodDivisor;
        const displayProjectedEarnings = projectedTotalEarnings / periodDivisor;
        const displayEarningsIncrease = earningsIncrease / periodDivisor;
        
        html += `
          <div class="calc-projection-section">
            <div class="calc-projection-title">
               Projected After Adding Stake
              <div class="calc-toggle">
                <button class="calc-toggle-btn ${!isMonthly ? 'active' : ''}" onclick="setProjectionPeriod('yearly')">Year</button>
                <button class="calc-toggle-btn ${isMonthly ? 'active' : ''}" onclick="setProjectionPeriod('monthly')">Month</button>
              </div>
            </div>
            
            <div class="calc-projection-comparison">
              <div class="calc-projection-box">
                <div class="calc-projection-value">${formatValue(displayCurrentEarnings)}</div>
                <div class="calc-projection-label">Current ${periodLabel}</div>
              </div>
              <div class="calc-projection-arrow"></div>
              <div class="calc-projection-box new">
                <div class="calc-projection-value">${formatValue(displayProjectedEarnings)}</div>
                <div class="calc-projection-label">Projected ${periodLabel}</div>
              </div>
            </div>
            
            <div class="calc-earnings-row">
              <span class="calc-earnings-label">New Self-Stake Total</span>
              <span class="calc-earnings-value">${formatNumber(newSelfStake, 0)} XNT</span>
            </div>
            <div class="calc-earnings-row">
              <span class="calc-earnings-label">New Delegated Total</span>
              <span class="calc-earnings-value">${formatNumber(newDelegatedStake, 0)} XNT</span>
            </div>
            <div class="calc-earnings-row" style="color: var(--success);">
              <span class="calc-earnings-label">Earnings Increase${isMonthly ? ' (monthly)' : ''}</span>
              <span class="calc-earnings-value">+${formatValue(displayEarningsIncrease)} (+${formatNumber(earningsIncreasePercent, 1)}%)</span>
            </div>
        `;
        
        // Show breakdown of increase
        if (addSelf > 0) {
          const addSelfEarnings = (addSelf * (baseAPY / 100)) / periodDivisor;
          html += `
            <div class="calc-earnings-row" style="font-size: 0.75rem; color: var(--text-dim);">
              <span class="calc-earnings-label"> From +${formatNumber(addSelf, 0)} self-stake</span>
              <span class="calc-earnings-value">+${formatValue(addSelfEarnings)}</span>
            </div>
          `;
        }
        if (addDelegation > 0) {
          const addDelegationEarnings = (addDelegation * (baseAPY / 100) * (commission / 100)) / periodDivisor;
          html += `
            <div class="calc-earnings-row" style="font-size: 0.75rem; color: var(--text-dim);">
              <span class="calc-earnings-label"> From +${formatNumber(addDelegation, 0)} delegation (${commission}% comm)</span>
              <span class="calc-earnings-value">+${formatValue(addDelegationEarnings)}</span>
            </div>
          `;
        }
        
        html += `</div>`;
      }
      
      // Real data note
      if (stakingRealRewardsData) {
        html += `
          <div class="calc-actual-note" style="margin-top: 1rem;">
             APY calculated from actual reward data (last ${stakingRealRewardsData.epochs} days)
          </div>
        `;
      }
      
      resultsContent.innerHTML = html;
    }
    
    function setProjectionPeriod(period) {
      stakingProjectionPeriod = period;
      renderStakingResults();
    }
    
    // ===== COMPOUND GROWTH CALCULATOR =====
    let compoundValidatorStake = 0;
    let compoundRealRewardsData = null;
    
    function formatCompoundInput(input) {
      let value = input.value.replace(/[^0-9.]/g, '');
      if (value) {
        const num = parseFloat(value);
        if (!isNaN(num)) {
          input.value = num.toLocaleString('en-US');
        }
      }
    }
    
    async function onCompoundValidatorChange() {
      const validatorSelect = document.getElementById('compoundValidator');
      const initialGroup = document.getElementById('compoundInitialGroup');
      const apyGroup = document.getElementById('compoundAPYGroup');
      const hintEl = document.getElementById('compoundValidatorHint');
      const resultsContent = document.getElementById('compoundResultsContent');
      
      if (validatorSelect.value === 'custom') {
        // Show manual inputs for custom
        initialGroup.style.display = 'block';
        apyGroup.style.display = 'block';
        hintEl.textContent = 'Enter your custom stake amount and APY above';
        compoundValidatorStake = 0;
        compoundRealRewardsData = null;
        calculateCompoundGrowth();
      } else if (validatorSelect.value) {
        // Hide manual inputs for validator
        initialGroup.style.display = 'none';
        apyGroup.style.display = 'none';
        
        let stake = 0;
        let commission = 0;
        if (validatorInfoCache[validatorSelect.value]) {
          stake = validatorInfoCache[validatorSelect.value].activatedStake || 0;
          commission = validatorInfoCache[validatorSelect.value].commission || 0;
        } else if (allValidators) {
          const validator = allValidators.find(v => v.votePubkey === validatorSelect.value);
          if (validator) {
            stake = validator.activatedStake / 1e9;
            commission = validator.commission || 0;
          }
        }
        compoundValidatorStake = stake;
        hintEl.textContent = `Current stake: ${formatNumber(stake, 0)} XNT`;
        
        // Show loading
        resultsContent.innerHTML = `
          <div class="calc-loading">
            <div class="loading-spinner-small"></div>
            <span>Fetching stake breakdown...</span>
          </div>
        `;
        
        // Fetch stake breakdown to calculate validator APY
        let selfStake = 0;
        let delegatedStake = 0;
        
        try {
          // Check cache first
          let breakdownData = window.stakeBreakdownData && window.stakeBreakdownData[validatorSelect.value];
          
          if (!breakdownData) {
            // Fetch breakdown
            breakdownData = await fetchStakeBreakdownForCalc(validatorSelect.value, commission);
            if (breakdownData) {
              if (!window.stakeBreakdownData) window.stakeBreakdownData = {};
              window.stakeBreakdownData[validatorSelect.value] = breakdownData;
            }
          }
          
          if (breakdownData) {
            selfStake = breakdownData.selfStake || 0;
            delegatedStake = breakdownData.delegatedStake || 0;
          }
        } catch (e) {
          console.warn('Could not fetch stake breakdown:', e);
        }
        
        // Fetch real rewards data (vote account + self-stake rewards)
        try {
          const rewards = await fetchTotalValidatorRewards(validatorSelect.value, commission, 7);
          if (rewards && rewards.length > 0) {
            // Convert from lamports to XNT (divide by 1e9)
            const totalRewardsXNT = rewards.reduce((sum, r) => sum + r.amount, 0) / 1e9;
            const avgDailyRewardsXNT = totalRewardsXNT / rewards.length;
            
            // Calculate validator's effective APY using derived base APY
            // totalRewards = selfStake * baseAPY + delegatedStake * baseAPY * (commission/100)
            // totalRewards = baseAPY * (selfStake + delegatedStake * commission/100)
            // Solve for baseAPY:
            const totalAnnualRewards = avgDailyRewardsXNT * 365;
            const divisor = selfStake + (delegatedStake * commission / 100);
            let baseAPY = 8; // Default
            if (divisor > 0) {
              baseAPY = (totalAnnualRewards / divisor) * 100;
            }
            
            // Now calculate earnings with derived baseAPY
            const selfStakeEarnings = selfStake * (baseAPY / 100);
            const commissionEarnings = delegatedStake * (baseAPY / 100) * (commission / 100);
            const totalValidatorEarnings = selfStakeEarnings + commissionEarnings;
            
            // Effective APY = total earnings / self-stake (their investment)
            const validatorAPY = selfStake > 0 ? (totalValidatorEarnings / selfStake) * 100 : baseAPY;
            
            compoundRealRewardsData = {
              avgDaily: avgDailyRewardsXNT,
              validatorAPY: validatorAPY,
              baseAPY: baseAPY,
              selfStake: selfStake,
              delegatedStake: delegatedStake,
              commission: commission,
              epochs: rewards.length
            };
            
            // Update hint to show self-stake
            if (selfStake > 0) {
              hintEl.textContent = `Self-stake: ${formatNumber(selfStake, 0)} XNT  Delegated: ${formatNumber(delegatedStake, 0)} XNT`;
            }
          } else {
            compoundRealRewardsData = null;
          }
        } catch (err) {
          console.error('Failed to fetch real rewards:', err);
          compoundRealRewardsData = null;
        }
        
        calculateCompoundGrowth();
      } else {
        // No selection
        initialGroup.style.display = 'none';
        hintEl.textContent = 'Select a validator or choose custom values';
        compoundValidatorStake = 0;
        compoundRealRewardsData = null;
        calculateCompoundGrowth();
      }
    }
    
    function calculateCompoundGrowth() {
      const validatorSelect = document.getElementById('compoundValidator');
      const resultsContent = document.getElementById('compoundResultsContent');
      const chartContainer = document.getElementById('compoundChartContainer');
      
      // If no validator selected and not custom, show empty state
      if (!validatorSelect.value) {
        resultsContent.innerHTML = `
          <div class="calc-empty-state">
            <div class="calc-empty-icon"></div>
            <div class="calc-empty-text">Select a validator or choose "Custom Values" to calculate compound growth</div>
          </div>
        `;
        chartContainer.style.display = 'none';
        return;
      }
      
      // Get inputs
      let initial = 0;
      let apy = 8; // Default base network APY
      let isValidatorMode = false;
      
      if (validatorSelect.value === 'custom') {
        const amountStr = document.getElementById('compoundInitial').value.replace(/,/g, '');
        initial = parseFloat(amountStr) || 0;
        apy = parseFloat(document.getElementById('compoundAPY').value) || 8;
      } else {
        // For validators, use self-stake and validator's effective APY
        if (compoundRealRewardsData && compoundRealRewardsData.selfStake > 0) {
          initial = compoundRealRewardsData.selfStake;
          apy = compoundRealRewardsData.validatorAPY || 8;
          isValidatorMode = true;
        } else {
          // Fallback to total stake with base APY
          initial = compoundValidatorStake;
          apy = 8;
        }
      }
      
      const years = parseFloat(document.getElementById('compoundYears').value) || 3;
      const frequency = parseInt(document.getElementById('compoundFrequency').value) || 12;
      
      // Get frequency label
      const freqLabels = {
        365: 'Daily',
        52: 'Weekly',
        26: 'Bi-weekly',
        12: 'Monthly',
        4: 'Quarterly',
        1: 'Yearly'
      };
      const freqLabel = freqLabels[frequency] || 'Periodic';
      
      const rate = apy / 100;
      
      // Calculate compound and simple growth
      const compoundFinal = initial * Math.pow(1 + rate / frequency, frequency * years);
      const simpleFinal = initial * (1 + rate * years);
      const bonus = compoundFinal - simpleFinal;
      
      // Show actual current earnings if we have real data
      let earningsHtml = '';
      if (compoundRealRewardsData && validatorSelect.value !== 'custom') {
        const avgDaily = compoundRealRewardsData.avgDaily;
        const avgMonthly = avgDaily * 30;
        const avgAnnual = avgDaily * 365;
        const selfStake = compoundRealRewardsData.selfStake || 0;
        const delegatedStake = compoundRealRewardsData.delegatedStake || 0;
        const commission = compoundRealRewardsData.commission || 0;
        
        earningsHtml = `
          <div class="calc-section-header actual">
            <span> Current Validator Earnings</span>
            <span class="calc-section-badge">Last ${compoundRealRewardsData.epochs} epochs</span>
          </div>
          <div class="calc-result-grid">
            <div class="calc-result-item">
              <div class="calc-result-value">${formatNumber(avgDaily, 2)} XNT</div>
              <div class="calc-result-label">Per Day</div>
            </div>
            <div class="calc-result-item">
              <div class="calc-result-value">${formatNumber(avgMonthly, 2)} XNT</div>
              <div class="calc-result-label">Per Month</div>
            </div>
            <div class="calc-result-item highlight">
              <div class="calc-result-value">${formatNumber(avgAnnual, 2)} XNT</div>
              <div class="calc-result-label">Per Year</div>
            </div>
          </div>
          ${selfStake > 0 ? `
          <div class="calc-validator-apy-box">
            <div class="calc-validator-apy-label">Validator Effective APY (7-day avg)</div>
            <div class="calc-validator-apy-value">${apy.toFixed(2)}%</div>
            <div class="calc-validator-apy-note">
              ${formatNumber(selfStake, 0)} self-stake + ${commission}% commission on ${formatNumber(delegatedStake, 0)} delegated
            </div>
          </div>
          ` : ''}
          <div class="calc-section-divider"></div>
        `;
      }
      
      // Label for starting stake
      const startingLabel = isValidatorMode ? 'Self-Stake (Your Investment):' : 'Starting Stake:';
      
      resultsContent.innerHTML = `
        ${earningsHtml}
        <div class="calc-section-header">
          <span> ${years}-Year Projection (${freqLabel} Compounding @ ${apy.toFixed(2)}% APY)</span>
        </div>
        <div class="compound-comparison">
          <div class="compound-vs">
            <div class="compound-vs-item">
              <span class="compound-vs-label">${startingLabel}</span>
              <span class="compound-vs-value">${formatNumber(initial, 0)} XNT</span>
            </div>
            <div class="compound-vs-item">
              <span class="compound-vs-label">Without Compounding:</span>
              <span class="compound-vs-value">${formatNumber(simpleFinal, 0)} XNT</span>
            </div>
            <div class="compound-vs-item">
              <span class="compound-vs-label">With ${freqLabel} Compounding:</span>
              <span class="compound-vs-value">${formatNumber(compoundFinal, 0)} XNT</span>
            </div>
            <div class="compound-vs-item highlight">
              <span class="compound-vs-label">Compounding Bonus:</span>
              <span class="compound-vs-value bonus">+${formatNumber(bonus, 0)} XNT</span>
            </div>
          </div>
        </div>
        <div class="calc-actual-note">
          Projection based on ${apy.toFixed(2)}% APY (7-day average). Actual results will vary.
        </div>
      `;
      
      // Show and draw chart
      chartContainer.style.display = 'block';
      drawCompoundChart(initial, apy, years, frequency);
    }
    
    function drawCompoundChart(initial, apy, years, n) {
      const ctx = document.getElementById('compoundChart');
      if (!ctx) return;
      
      // Destroy existing chart
      if (compoundChartInstance) {
        compoundChartInstance.destroy();
      }
      
      // Generate data points - show EARNINGS (growth) not total balance
      const labels = [];
      const compoundData = [];
      const simpleData = [];
      const rate = apy / 100;
      
      // For periods over 5 years, use yearly data points; otherwise monthly
      const useYearly = years > 5;
      const dataPoints = useYearly ? years : years * 12;
      
      for (let i = 0; i <= dataPoints; i++) {
        const t = useYearly ? i : i / 12; // Time in years
        
        // Labels
        if (i === 0) {
          labels.push('Start');
        } else if (useYearly) {
          labels.push(`${i}yr`);
        } else {
          // Show year markers more prominently
          if (i % 12 === 0) {
            labels.push(`${i/12}yr`);
          } else if (i % 6 === 0) {
            labels.push(`${i}mo`);
          } else {
            labels.push('');
          }
        }
        
        // Compound growth with frequency n - show EARNINGS only (subtract initial)
        const periodsElapsed = t * n;
        const compoundTotal = initial * Math.pow(1 + rate / n, periodsElapsed);
        const compoundEarnings = compoundTotal - initial;
        compoundData.push(compoundEarnings);
        
        // Simple (no compounding) - show EARNINGS only
        const simpleTotal = initial * (1 + rate * t);
        const simpleEarnings = simpleTotal - initial;
        simpleData.push(simpleEarnings);
      }
      
      compoundChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'With Compounding',
              data: compoundData,
              borderColor: '#00ffa3',
              backgroundColor: 'rgba(0, 255, 163, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4
            },
            {
              label: 'Without Compounding',
              data: simpleData,
              borderColor: '#8a8f98',
              backgroundColor: 'transparent',
              borderWidth: 2,
              borderDash: [5, 5],
              fill: false,
              tension: 0.4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#8a8f98',
                usePointStyle: true,
                padding: 15
              }
            },
            tooltip: {
              backgroundColor: '#1a1d24',
              titleColor: '#ffffff',
              bodyColor: '#8a8f98',
              borderColor: '#2a2d35',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                  return context.dataset.label + ': +' + formatNumber(context.raw, 2) + ' XNT';
                }
              }
            }
          },
          scales: {
            x: {
              grid: { color: 'rgba(255, 255, 255, 0.05)' },
              ticks: { color: '#8a8f98', maxRotation: 0 }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Earnings (XNT)',
                color: '#8a8f98'
              },
              grid: { color: 'rgba(255, 255, 255, 0.05)' },
              ticks: {
                color: '#8a8f98',
                callback: function(value) {
                  if (value >= 1000000) return '+' + (value / 1000000).toFixed(1) + 'M';
                  if (value >= 1000) return '+' + (value / 1000).toFixed(0) + 'K';
                  return '+' + value;
                }
              }
            }
          }
        }
      });
    }
    
    // ===== UNSTAKING TIMELINE CALCULATOR =====
    async function refreshEpochInfo() {
      try {
        document.getElementById('unstakingCurrentEpoch').textContent = 'Loading...';
        
        const epochInfo = await rpcCall('getEpochInfo');
        currentEpochData = epochInfo;
        
        const currentEpoch = epochInfo.epoch;
        const slotIndex = epochInfo.slotIndex;
        const slotsInEpoch = epochInfo.slotsInEpoch;
        const progress = ((slotIndex / slotsInEpoch) * 100).toFixed(1);
        
        // Estimate time remaining (assuming ~400ms per slot)
        const slotsRemaining = slotsInEpoch - slotIndex;
        const msRemaining = slotsRemaining * 400;
        const hoursRemaining = msRemaining / (1000 * 60 * 60);
        
        let timeStr;
        if (hoursRemaining < 1) {
          timeStr = Math.round(hoursRemaining * 60) + ' minutes';
        } else if (hoursRemaining < 24) {
          timeStr = hoursRemaining.toFixed(1) + ' hours';
        } else {
          timeStr = (hoursRemaining / 24).toFixed(1) + ' days';
        }
        
        document.getElementById('unstakingCurrentEpoch').textContent = currentEpoch;
        document.getElementById('unstakingEpochProgress').textContent = progress + '%';
        document.getElementById('unstakingTimeRemaining').textContent = '~' + timeStr;
        
        calculateUnstakingTimeline();
      } catch (err) {
        console.error('Failed to fetch epoch info:', err);
        document.getElementById('unstakingCurrentEpoch').textContent = 'Error';
      }
    }
    
    function calculateUnstakingTimeline() {
      if (!currentEpochData) return;
      
      const whenSelect = document.getElementById('unstakingWhen').value;
      const customEpoch = parseInt(document.getElementById('unstakingCustomEpoch').value) || 0;
      
      const currentEpoch = currentEpochData.epoch;
      let initiateEpoch;
      
      switch (whenSelect) {
        case 'now':
          initiateEpoch = currentEpoch;
          break;
        case 'next':
          initiateEpoch = currentEpoch + 1;
          break;
        case 'custom':
          initiateEpoch = customEpoch || currentEpoch;
          break;
      }
      
      // X1/Solana unstaking: 
      // 1. Initiate unstaking during current epoch
      // 2. Deactivation begins at end of current epoch, cooldown through next epoch
      // 3. Funds available at start of the epoch after cooldown
      
      const deactivateEpoch = initiateEpoch + 1;
      const availableEpoch = deactivateEpoch + 1;
      
      // Estimate dates (assuming ~1 day per epoch on X1)
      const epochDurationMs = 1 * 24 * 60 * 60 * 1000;
      const now = new Date();
      
      // Calculate remaining time in current epoch
      const slotIndex = currentEpochData.slotIndex;
      const slotsInEpoch = currentEpochData.slotsInEpoch;
      const progressRatio = slotIndex / slotsInEpoch;
      const currentEpochRemainingMs = epochDurationMs * (1 - progressRatio);
      
      // initiateDate = when you click unstake (now, or future epoch)
      const epochsUntilInitiate = initiateEpoch - currentEpoch;
      const initiateDate = epochsUntilInitiate === 0 ? now : new Date(now.getTime() + currentEpochRemainingMs + ((epochsUntilInitiate - 1) * epochDurationMs));
      
      // deactivateDate = end of current epoch (when deactivation starts)
      const deactivateDate = new Date(now.getTime() + currentEpochRemainingMs + (epochsUntilInitiate * epochDurationMs));
      
      // availableDate = end of deactivation epoch (when funds become available)
      const availableDate = new Date(deactivateDate.getTime() + epochDurationMs);
      
      // Build timeline HTML
      const timeline = document.getElementById('unstakingTimeline');
      timeline.innerHTML = `
        <div class="timeline-step ${initiateEpoch === currentEpoch ? 'active' : ''}">
          <div class="timeline-icon"></div>
          <div class="timeline-content">
            <div class="timeline-title">Initiate Unstake</div>
            <div class="timeline-subtitle">Epoch ${initiateEpoch}</div>
            <div class="timeline-date">${formatDate(initiateDate)}</div>
          </div>
        </div>
        <div class="timeline-step">
          <div class="timeline-icon"></div>
          <div class="timeline-content">
            <div class="timeline-title">Deactivation Period</div>
            <div class="timeline-subtitle">Epoch ${deactivateEpoch} - Stake stops earning rewards</div>
            <div class="timeline-date">${formatDate(deactivateDate)}</div>
          </div>
        </div>
        <div class="timeline-step">
          <div class="timeline-icon"></div>
          <div class="timeline-content">
            <div class="timeline-title">Funds Available</div>
            <div class="timeline-subtitle">Epoch ${availableEpoch} - Withdraw anytime</div>
            <div class="timeline-date">${formatDate(availableDate)}</div>
          </div>
        </div>
      `;
      
      // Calculate total time
      const totalMs = availableDate.getTime() - now.getTime();
      const totalDays = totalMs / (1000 * 60 * 60 * 24);
      
      document.getElementById('unstakingSummary').innerHTML = `
        <div class="unstaking-summary-value">~${totalDays.toFixed(1)} days</div>
        <div class="unstaking-summary-label">Until funds are available (approximately)</div>
      `;
    }
    
    function formatDate(date) {
      const options = { weekday: 'short', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
      return date.toLocaleDateString('en-US', options);
    }
    
    // ===== BREAK-EVEN CALCULATOR =====
    let breakevenValidatorStake = 0;
    let breakevenViewMode = 'monthly'; // 'monthly' or 'yearly'
    let breakevenRealRewardsData = null;
    
    function formatBreakevenInput(input) {
      let value = input.value.replace(/[^0-9.]/g, '');
      if (value) {
        const num = parseFloat(value);
        if (!isNaN(num)) {
          input.value = num.toLocaleString('en-US');
        }
      }
    }
    
    async function onBreakevenValidatorChange() {
      const validatorSelect = document.getElementById('breakevenValidator');
      const hintEl = document.getElementById('breakevenValidatorHint');
      const resultsContent = document.getElementById('breakevenResultsContent');
      
      if (validatorSelect.value) {
        let stake = 0;
        let commission = 0;
        if (validatorInfoCache[validatorSelect.value]) {
          stake = validatorInfoCache[validatorSelect.value].activatedStake || 0;
          commission = validatorInfoCache[validatorSelect.value].commission || 0;
        } else if (allValidators) {
          const validator = allValidators.find(v => v.votePubkey === validatorSelect.value);
          if (validator) {
            stake = validator.activatedStake / 1e9;
            commission = validator.commission || 0;
          }
        }
        breakevenValidatorStake = stake;
        hintEl.textContent = `Current stake: ${formatNumber(stake, 0)} XNT`;
        
        // Show loading
        resultsContent.innerHTML = `
          <div class="calc-loading">
            <div class="loading-spinner-small"></div>
            <span>Fetching real reward data...</span>
          </div>
        `;
        
        // Fetch real rewards data (vote account + self-stake rewards)
        try {
          const rewards = await fetchTotalValidatorRewards(validatorSelect.value, commission, 7);
          if (rewards && rewards.length > 0) {
            // Convert from lamports to XNT (divide by 1e9)
            const totalRewardsXNT = rewards.reduce((sum, r) => sum + r.amount, 0) / 1e9;
            const avgDailyRewardsXNT = totalRewardsXNT / rewards.length;
            const realAPY = stake > 0 ? (avgDailyRewardsXNT * 365 / stake) * 100 : 0;
            
            breakevenRealRewardsData = {
              avgDaily: avgDailyRewardsXNT,
              realAPY: realAPY,
              epochs: rewards.length
            };
          } else {
            breakevenRealRewardsData = null;
          }
        } catch (err) {
          console.error('Failed to fetch real rewards:', err);
          breakevenRealRewardsData = null;
        }
        
        renderBreakevenResults();
      } else {
        hintEl.textContent = 'Select a validator to see profitability';
        breakevenValidatorStake = 0;
        breakevenRealRewardsData = null;
        renderBreakevenResults();
      }
    }
    
    function toggleBreakevenView(mode, button) {
      breakevenViewMode = mode;
      
      document.querySelectorAll('#breakevenToggle .calc-toggle-btn').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      
      renderBreakevenResults();
    }
    
    function calculateBreakeven() {
      renderBreakevenResults();
    }
    
    function renderBreakevenResults() {
      const validatorSelect = document.getElementById('breakevenValidator');
      const resultsContent = document.getElementById('breakevenResultsContent');
      
      // If no validator selected, show empty state
      if (!validatorSelect.value) {
        resultsContent.innerHTML = `
          <div class="calc-empty-state">
            <div class="calc-empty-icon"></div>
            <div class="calc-empty-text">Select a validator to see profitability</div>
          </div>
        `;
        return;
      }
      
      const currentStake = breakevenValidatorStake;
      
      const cost = parseFloat(document.getElementById('breakevenCost').value) || 0;
      const currency = document.getElementById('breakevenCurrency').value;
      const costPeriod = document.getElementById('breakevenPeriod').value;
      const price = parseFloat(document.getElementById('breakevenPrice').value) || 1.00;
      
      // Show/hide price input based on currency
      document.getElementById('breakevenPriceGroup').style.display = currency === 'usd' ? 'block' : 'none';
      
      // Convert cost to XNT
      let annualCostXNT;
      if (currency === 'usd') {
        const costInXNT = price > 0 ? cost / price : 0;
        annualCostXNT = costPeriod === 'monthly' ? costInXNT * 12 : costInXNT;
      } else {
        annualCostXNT = costPeriod === 'monthly' ? cost * 12 : cost;
      }
      
      const monthlyCostXNT = annualCostXNT / 12;
      const isMonthly = breakevenViewMode === 'monthly';
      const periodLabel = isMonthly ? 'Monthly' : 'Yearly';
      const displayCost = isMonthly ? monthlyCostXNT : annualCostXNT;
      
      // Show actual data
      if (breakevenRealRewardsData) {
        const avgDaily = breakevenRealRewardsData.avgDaily;
        const avgMonthly = avgDaily * 30;
        const avgAnnual = avgDaily * 365;
        const displayRewards = isMonthly ? avgMonthly : avgAnnual;
        const profit = displayRewards - displayCost;
        
        const profitClass = profit >= 0 ? 'positive' : 'negative';
        const profitSign = profit >= 0 ? '+' : '';
        const statusText = profit >= 0 ? ' Currently Profitable' : ' Currently Operating at Loss';
        const statusClass = profit >= 0 ? 'profit-status-positive' : 'profit-status-negative';
        
        // Calculate break-even XNT price
        // Get annual USD costs
        let annualUsdCost;
        if (currency === 'usd') {
          annualUsdCost = costPeriod === 'monthly' ? cost * 12 : cost;
        } else {
          // Costs in XNT - convert to USD using current price
          const annualXntCost = costPeriod === 'monthly' ? cost * 12 : cost;
          annualUsdCost = annualXntCost * price;
        }
        
        // Break-even price = annual USD cost / annual XNT rewards
        const breakevenPrice = avgAnnual > 0 ? annualUsdCost / avgAnnual : 0;
        const displayUsdCost = isMonthly ? annualUsdCost / 12 : annualUsdCost;
        const currentUsdValue = displayRewards * price;
        const priceNeededText = breakevenPrice > 0 ? `$${breakevenPrice.toFixed(4)}` : 'N/A';
        const isProfitable = profit >= 0;
        const breakevenLabel = isProfitable 
          ? 'Profitable down to:' 
          : 'Price needed to break even:';
        const breakevenHeader = isProfitable
          ? ' Break-Even Floor'
          : ' Break-Even XNT Price';
        
        resultsContent.innerHTML = `
          <div class="calc-section-header actual">
            <span> Break-Even Analysis</span>
            <span class="calc-section-badge">Last ${breakevenRealRewardsData.epochs} epochs</span>
          </div>
          <div class="calc-result-grid">
            <div class="calc-result-item">
              <div class="calc-result-value">${formatNumber(currentStake, 0)} XNT</div>
              <div class="calc-result-label">Current Stake</div>
            </div>
            <div class="calc-result-item">
              <div class="calc-result-value">${formatNumber(displayCost, 2)} XNT</div>
              <div class="calc-result-label">${periodLabel} Costs</div>
            </div>
            <div class="calc-result-item">
              <div class="calc-result-value">${formatNumber(displayRewards, 2)} XNT</div>
              <div class="calc-result-label">${periodLabel} Rewards</div>
            </div>
            <div class="calc-result-item highlight">
              <div class="calc-result-value ${profitClass}">${profitSign}${formatNumber(profit, 2)} XNT</div>
              <div class="calc-result-label">${periodLabel} Profit</div>
            </div>
          </div>
          <div class="breakeven-status ${statusClass}">
            ${statusText}  Earning ${formatNumber(avgDaily, 2)} XNT/day
          </div>
          <div class="breakeven-price-box">
            <div class="breakeven-price-header">${breakevenHeader}</div>
            <div class="breakeven-price-content">
              <div class="breakeven-price-item">
                <span class="breakeven-price-label">${breakevenLabel}</span>
                <span class="breakeven-price-value highlight">${priceNeededText}</span>
              </div>
              <div class="breakeven-price-item">
                <span class="breakeven-price-label">Current XNT price (input):</span>
                <span class="breakeven-price-value">$${price.toFixed(2)}</span>
              </div>
              <div class="breakeven-price-divider"></div>
              <div class="breakeven-price-item">
                <span class="breakeven-price-label">${periodLabel} costs:</span>
                <span class="breakeven-price-value">$${formatNumber(displayUsdCost, 2)}</span>
              </div>
              <div class="breakeven-price-item">
                <span class="breakeven-price-label">${periodLabel} rewards value:</span>
                <span class="breakeven-price-value ${currentUsdValue >= displayUsdCost ? 'positive' : 'negative'}">$${formatNumber(currentUsdValue, 2)}</span>
              </div>
            </div>
          </div>
          <div class="calc-actual-note">
            Earnings include self-stake rewards + commission on delegations
          </div>
        `;
      } else {
        resultsContent.innerHTML = `
          <div class="calc-empty-state">
            <div class="calc-empty-icon"></div>
            <div class="calc-empty-text">Unable to fetch reward data</div>
          </div>
        `;
      }
    }

    // =========================================
    // Go to home page (X1 Network tab)
    function goToHome() {
      // Close any open modals
      document.getElementById('manageValidatorModal').style.display = 'none';
      document.getElementById('validatorModal').style.display = 'none';
      
      // Switch to the map tab
      switchTab('map');
    }

    // Validator list modal
    let validatorListMode = 'search'; // 'search' or 'compare'
    let currentValidatorList = []; // The current filtered/full list
    let validatorListDisplayed = 0; // How many are currently shown
    const VALIDATORS_PER_PAGE = 100;

    async function openValidatorList(mode = 'search') {
      validatorListMode = mode;
      const modal = document.getElementById('validatorModal');
      const body = document.getElementById('validatorListBody');
      
      // Reset search
      document.getElementById('validatorSearchInput').value = '';
      
      modal.style.display = 'flex';

      if (allValidators.length === 0) {
        body.innerHTML = '<div class="loading-validators">Loading validators...</div>';
        document.getElementById('validatorListCount').textContent = 'Loading...';
        await loadNetworkStats();
      }
      
      // Reset and render
      currentValidatorList = allValidators;
      validatorListDisplayed = 0;
      renderValidatorList(false);
    }

    function renderValidatorList(append = false) {
      const body = document.getElementById('validatorListBody');
      const countEl = document.getElementById('validatorListCount');
      const loadMoreEl = document.getElementById('validatorLoadMore');
      
      if (currentValidatorList.length === 0) {
        body.innerHTML = '<div class="loading-validators">No validators found</div>';
        countEl.textContent = 'No validators found';
        loadMoreEl.style.display = 'none';
        return;
      }

      // Get next batch
      const startIdx = append ? validatorListDisplayed : 0;
      const endIdx = startIdx + VALIDATORS_PER_PAGE;
      const batch = currentValidatorList.slice(startIdx, endIdx);
      
      const batchHtml = batch.map(v => {
        const isInPortfolio = myPortfolio.includes(v.votePubkey);
        const isInCompare = compareValidators.some(cv => cv.votePubkey === v.votePubkey);
        const tierBadge = getTierBadge(v.rank, v.totalValidators);
        
        // Different button based on mode
        let actionButton;
        if (validatorListMode === 'compare') {
          actionButton = `
            <button class="validator-list-item-add ${isInCompare ? 'added' : ''}" 
                    onclick="${isInCompare ? '' : `addToComparisonFromList('${v.votePubkey}')`}"
                    ${isInCompare ? 'disabled' : ''}>
              ${isInCompare ? 'Added' : '+ Compare'}
            </button>
          `;
        } else {
          actionButton = `
            <button class="validator-list-item-add ${isInPortfolio ? 'added' : ''}" 
                    onclick="${isInPortfolio ? '' : `addToPortfolioFromList('${v.votePubkey}')`}"
                    ${isInPortfolio ? 'disabled' : ''}>
              ${isInPortfolio ? 'Added' : '+ Add'}
            </button>
          `;
        }
        
        // Generate logo HTML
        const initial = v.name ? v.name.charAt(0).toUpperCase() : 'V';
        let logoHtml;
        if (v.iconUrl) {
          logoHtml = `<img src="${v.iconUrl}" alt="${initial}" onerror="this.style.display='none';this.parentElement.textContent='${initial}';">`;
        } else {
          logoHtml = initial;
        }
        
        return `
          <div class="validator-list-item">
            <div class="validator-list-item-logo">${logoHtml}</div>
            <div class="validator-list-item-info" onclick="selectValidatorForSearch('${v.votePubkey}')">
              <div class="validator-list-item-name">#${v.rank} - ${v.name}${tierBadge}</div>
              <div class="validator-list-item-address">${v.votePubkey}</div>
            </div>
            ${actionButton}
          </div>
        `;
      }).join('');

      if (append) {
        body.innerHTML += batchHtml;
      } else {
        body.innerHTML = batchHtml;
      }
      
      // Update count
      validatorListDisplayed = Math.min(endIdx, currentValidatorList.length);
      countEl.textContent = `Showing ${validatorListDisplayed} of ${currentValidatorList.length} validators`;
      
      // Show/hide Load More button
      if (validatorListDisplayed < currentValidatorList.length) {
        loadMoreEl.style.display = 'block';
      } else {
        loadMoreEl.style.display = 'none';
      }
    }

    function loadMoreValidators() {
      renderValidatorList(true);
    }

    function filterValidatorList() {
      const search = document.getElementById('validatorSearchInput').value.toLowerCase();
      
      if (search.trim() === '') {
        currentValidatorList = allValidators;
      } else {
        currentValidatorList = allValidators.filter(v => 
          v.name.toLowerCase().includes(search) || 
          v.votePubkey.toLowerCase().includes(search) ||
          v.nodePubkey.toLowerCase().includes(search)
        );
      }
      
      validatorListDisplayed = 0;
      renderValidatorList(false);
    }

    function selectValidatorForSearch(votePubkey) {
      if (validatorListMode === 'compare') {
        addToComparisonFromList(votePubkey);
      } else {
        document.getElementById('searchInput').value = votePubkey;
        closeValidatorList();
        switchTab('lookup');
        performSearch();
      }
    }

    async function addToComparisonFromList(votePubkey) {
      await addToComparison(votePubkey);
      // Re-render the list to update button states
      filterValidatorList();
    }

    function addToPortfolioFromList(voteAccount) {
      if (!myPortfolio.includes(voteAccount)) {
        myPortfolio.push(voteAccount);
        savePortfolio();
        renderValidatorList(allValidators.filter(v => {
          const search = document.getElementById('validatorSearchInput').value.toLowerCase();
          return v.name.toLowerCase().includes(search) || 
                 v.votePubkey.toLowerCase().includes(search) ||
                 v.nodePubkey.toLowerCase().includes(search);
        }));
      }
    }

    function closeValidatorList() {
      document.getElementById('validatorModal').style.display = 'none';
    }

    // Manage Validator Functions
    let currentManageValidator = null;
    let selectedAccountType = 'vote';
    let stakeAccounts = [];

    function openManageValidator(voteAccount, name, rewardsBalance, commission, identityPubkey, iconUrl) {
      currentManageValidator = {
        voteAccount,
        name,
        rewardsBalance,
        commission,
        identityPubkey,
        iconUrl
      };
      
      // Set validator info in header
      const logoEl = document.getElementById('manageValidatorLogo');
      const firstLetter = name.charAt(0).toUpperCase();
      if (iconUrl) {
        logoEl.innerHTML = `<img src="${iconUrl}" alt="${name}" style="width:100%;height:100%;border-radius:10px;" onerror="this.parentElement.textContent='${firstLetter}'">`;
      } else {
        logoEl.textContent = firstLetter;
      }
      document.getElementById('manageValidatorName').textContent = name;
      document.getElementById('manageValidatorFullAddress').textContent = voteAccount;
      
      // Set vote account address in account list
      document.getElementById('voteAccountAddress').textContent = shortenAddress(voteAccount);
      document.getElementById('voteAccountCopyBtn').innerHTML = getCopyButtonHtml(voteAccount);
      
      // Reset stake accounts container
      document.getElementById('stakeAccountsContainer').innerHTML = '<div class="loading-text">Loading stake accounts...</div>';
      
      // Update wallet status display
      updateManageWalletDisplay();
      
      // Show modal
      document.getElementById('manageValidatorModal').style.display = 'flex';
      
      // Select vote account by default
      selectAccount('vote');
      
      // Fetch additional data
      fetchManageValidatorData(voteAccount);
      fetchStakeAccounts(voteAccount);
    }

    function updateManageWalletDisplay() {
      const indicator = document.getElementById('walletStatusIndicator');
      const statusText = document.getElementById('walletStatusText');
      const authorityBadge = document.getElementById('authorityBadge');
      
      if (walletPublicKey) {
        indicator.classList.add('connected');
        statusText.textContent = shortenAddress(walletPublicKey);
        statusText.classList.add('connected');
        document.getElementById('connectWalletBtn').style.display = 'none';
        document.getElementById('disconnectWalletBtn').style.display = 'block';
        
        // Check if stake account is selected - only then check withdraw authority
        if (selectedAccountType && selectedAccountType.startsWith('stake-')) {
          document.getElementById('selectedWithdrawAuthority').textContent = 'Checking...';
          authorityBadge.className = 'authority-badge';
          authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">Checking authority...</span>';
          checkWithdrawAuthority();
        } else if (selectedAccountType === 'vote') {
          // Vote account selected - check if wallet has withdraw authority for the vote account
          document.getElementById('selectedWithdrawAuthority').textContent = 'Checking...';
          authorityBadge.className = 'authority-badge';
          authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">Checking authority...</span>';
          checkWithdrawAuthority();
          // Also refresh the authority badges in the Select Account list
          fetchVoteAccountAuthoritiesForDisplay();
        }
        // If no account selected (selectedAccountType is null), badges are already hidden
      } else {
        indicator.classList.remove('connected');
        statusText.textContent = 'No wallet connected';
        statusText.classList.remove('connected');
        document.getElementById('connectWalletBtn').style.display = 'block';
        document.getElementById('disconnectWalletBtn').style.display = 'none';
        document.getElementById('selectedWithdrawAuthority').textContent = 'Connect wallet to view';
        
        // Set badge to no wallet state (clickable)
        authorityBadge.className = 'authority-badge clickable';
        authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">No wallet connected</span>';
      }
    }

    // Handle authority badge click
    function onAuthorityBadgeClick() {
      if (!walletPublicKey) {
        connectWallet();
      }
    }

    // Copy validator address to clipboard
    async function copyValidatorAddress() {
      if (!currentManageValidator) return;
      
      const address = currentManageValidator.voteAccount;
      const btn = document.querySelector('.copy-address-btn');
      
      try {
        await navigator.clipboard.writeText(address);
        
        // Show copied state
        btn.classList.add('copied');
        btn.innerHTML = `
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20 6 9 17 4 12"></polyline>
          </svg>
        `;
        
        // Reset after 2 seconds
        setTimeout(() => {
          btn.classList.remove('copied');
          btn.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          `;
        }, 2000);
      } catch (e) {
        console.error('Failed to copy:', e);
        alert('Failed to copy address');
      }
    }

    function closeManageValidator() {
      document.getElementById('manageValidatorModal').style.display = 'none';
      currentManageValidator = null;
      stakeAccounts = [];
    }

    // Performance Explainer Modal functions
    function openPerfExplainerModal(event, voteAccount) {
      event.stopPropagation();
      
      // Get validator info and calculate breakdown
      let breakdown = null;
      let validatorName = 'Validator';
      let validatorIcon = '';
      let totalScore = 0;
      
      if (voteAccount) {
        // Check cache first
        const cached = validatorInfoCache[voteAccount];
        if (cached) {
          breakdown = calculatePerformanceBreakdown(cached);
          validatorName = cached.name;
          validatorIcon = cached.iconUrl || '';
          totalScore = breakdown.totalScore;
        } else {
          // Try allValidators
          const validator = allValidators.find(v => v.votePubkey === voteAccount);
          if (validator) {
            const normalizedValidator = {
              ...validator,
              epochCreditsHistory: validator.epochCredits || [],
              isDelinquent: validator.delinquent
            };
            breakdown = calculatePerformanceBreakdown(normalizedValidator);
            validatorName = validator.name;
            validatorIcon = validator.iconUrl || '';
            totalScore = breakdown.totalScore;
          }
        }
      }
      
      // Generate logo HTML
      const firstLetter = validatorName.charAt(0).toUpperCase();
      const logoHtml = validatorIcon 
        ? `<img class="perf-breakdown-logo" src="${validatorIcon}" alt="${validatorName}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
           <div class="perf-breakdown-logo-placeholder" style="display:none;">${firstLetter}</div>`
        : `<div class="perf-breakdown-logo-placeholder">${firstLetter}</div>`;
      
      // Update the modal with validator-specific scores
      const breakdownSection = document.getElementById('perfBreakdownSection');
      if (breakdown) {
        breakdownSection.innerHTML = `
          <div class="perf-breakdown-header">
            <div class="perf-breakdown-identity">
              ${logoHtml}
              <h4>${validatorName}</h4>
            </div>
            <div class="perf-breakdown-total">Score: <span class="${getScoreColorClass(totalScore)}">${totalScore.toFixed(2)}</span></div>
          </div>
          <div class="perf-breakdown-grid">
            <div class="perf-breakdown-item">
              <span class="perf-breakdown-label">Vote Efficiency (30%)</span>
              <span class="perf-breakdown-score ${getScoreColorClass(breakdown.voteEfficiency.score)}">${breakdown.voteEfficiency.score.toFixed(0)}</span>
              <span class="perf-breakdown-detail">${breakdown.voteEfficiency.details}</span>
            </div>
            <div class="perf-breakdown-item">
              <span class="perf-breakdown-label">Skip Rate (25%)</span>
              <span class="perf-breakdown-score ${getScoreColorClass(breakdown.skipRate.score)}">${breakdown.skipRate.score.toFixed(0)}</span>
              <span class="perf-breakdown-detail">${breakdown.skipRate.details}</span>
            </div>
            <div class="perf-breakdown-item">
              <span class="perf-breakdown-label">Consistency (20%)</span>
              <span class="perf-breakdown-score ${getScoreColorClass(breakdown.consistency.score)}">${breakdown.consistency.score.toFixed(0)}</span>
              <span class="perf-breakdown-detail">${breakdown.consistency.details}</span>
            </div>
            <div class="perf-breakdown-item">
              <span class="perf-breakdown-label">Commission (5%)</span>
              <span class="perf-breakdown-score ${getScoreColorClass(breakdown.commission.score)}">${breakdown.commission.score.toFixed(0)}</span>
              <span class="perf-breakdown-detail">${breakdown.commission.details}</span>
            </div>
            <div class="perf-breakdown-item">
              <span class="perf-breakdown-label">Longevity (5%)</span>
              <span class="perf-breakdown-score ${getScoreColorClass(breakdown.longevity.score)}">${breakdown.longevity.score.toFixed(0)}</span>
              <span class="perf-breakdown-detail">${breakdown.longevity.details}</span>
            </div>
            <div class="perf-breakdown-item">
              <span class="perf-breakdown-label">Software (5%)</span>
              <span class="perf-breakdown-score ${getScoreColorClass(breakdown.softwareVersion.score)}">${breakdown.softwareVersion.score.toFixed(0)}</span>
              <span class="perf-breakdown-detail">${breakdown.softwareVersion.details}</span>
            </div>
            <div class="perf-breakdown-item">
              <span class="perf-breakdown-label">Reliability (10%)</span>
              <span class="perf-breakdown-score ${getScoreColorClass(breakdown.reliability.score)}">${breakdown.reliability.score.toFixed(0)}</span>
              <span class="perf-breakdown-detail">${breakdown.reliability.details}</span>
            </div>
          </div>
          <div class="ask-claude-divider"><span>Need Help?</span></div>
          <button class="ask-claude-btn" onclick="askClaudeForHelp('${voteAccount}', '${validatorName.replace(/'/g, "\\'")}', ${totalScore.toFixed(2)}, '${breakdown.skipRate.details.replace(/'/g, "\\'")}')">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
            Ask Claude to Help Optimize My Validator
          </button>
        `;
        breakdownSection.style.display = 'block';
      } else {
        breakdownSection.style.display = 'none';
      }
      
      document.getElementById('perfExplainerModal').style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }
    
    function closePerfExplainerModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('perfExplainerModal').style.display = 'none';
      document.body.style.overflow = '';
    }

    // Ask Claude for Help - opens Claude.ai with pre-filled validator info
    function askClaudeForHelp(voteAccount, validatorName, score, skipRateDetails) {
      // Get more validator details if available
      const validator = allValidators.find(v => v.votePubkey === voteAccount);
      let nodePubkey = '';
      let stake = '';
      let commission = '';
      
      if (validator) {
        nodePubkey = validator.nodePubkey || '';
        stake = validator.activatedStake ? (validator.activatedStake / 1e9).toFixed(0) + ' XN' : '';
        commission = validator.commission !== undefined ? validator.commission + '%' : '';
      }
      
      // Build the pre-filled message
      const message = `Help me optimize my X1 validator performance.

**My Validator Info:**
- Name: ${validatorName}
- Vote Account: ${voteAccount}
${nodePubkey ? '- Node Pubkey: ' + nodePubkey : ''}
- Performance Score: ${score}/100
- Skip Rate: ${skipRateDetails}
${stake ? '- Stake: ' + stake : ''}
${commission ? '- Commission: ' + commission : ''}

Please give me the diagnostic commands to run on my server so you can help me identify issues and optimize my setup. I want to reduce my skip rate and improve my performance score.`;

      // URL encode the message
      const encodedMessage = encodeURIComponent(message);
      
      // Open Claude.ai with the pre-filled message
      window.open(`https://claude.ai/new?q=${encodedMessage}`, '_blank');
    }

    // ===== STAKE BREAKDOWN MODAL =====
    let stakeBreakdownCache = {}; // Cache stake breakdown data
    
    async function openStakeBreakdown(voteAccount, validatorName, totalStake, commission) {
      const modal = document.getElementById('stakeBreakdownModal');
      const body = document.getElementById('stakeBreakdownBody');
      
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      
      // Show loading
      body.innerHTML = `
        <div class="stake-breakdown-loading">
          <div class="loading-spinner-small"></div>
          <span>Analyzing stake accounts...</span>
          <span style="font-size: 0.75rem; color: var(--text-dim);">Checking reward distribution patterns</span>
        </div>
      `;
      
      // Check cache first (5 minute cache)
      const cacheKey = voteAccount;
      const cached = stakeBreakdownCache[cacheKey];
      if (cached && cached.timestamp > Date.now() - 300000) {
        renderStakeBreakdown(cached.data, validatorName, totalStake, commission, voteAccount);
        return;
      }
      
      try {
        // Fetch all stake accounts delegated to this validator
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getProgramAccounts',
            params: [
              'Stake11111111111111111111111111111111111111',
              {
                encoding: 'jsonParsed',
                filters: [
                  {
                    memcmp: {
                      offset: 124,
                      bytes: voteAccount
                    }
                  }
                ]
              }
            ]
          })
        });
        
        const data = await response.json();
        
        if (!data.result || data.result.length === 0) {
          body.innerHTML = `
            <div class="stake-breakdown-loading">
              <span>No stake accounts found for this validator</span>
            </div>
          `;
          return;
        }
        
        // Always get fresh epoch info to ensure we use the last COMPLETED epoch
        const epochInfo = await rpcCall('getEpochInfo');
        currentEpochNumber = epochInfo.epoch;
        
        // Fetch inflation rewards for stake accounts (last completed epoch)
        const stakeAccountPubkeys = data.result.map(acc => acc.pubkey);
        let rewards = [];
        
        try {
          const rewardsResponse = await fetch(RPC_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'getInflationReward',
              params: [stakeAccountPubkeys, { epoch: currentEpochNumber - 1 }]
            })
          });
          
          const rewardsData = await rewardsResponse.json();
          rewards = rewardsData.result || [];
        } catch (e) {
          console.warn('Could not fetch epoch-1 rewards:', e);
        }
        
        // If no rewards from epoch-1, try epoch-2
        const hasRewards = rewards.some(r => r && r.amount > 0);
        if (!hasRewards && currentEpochNumber > 2) {
          try {
            const rewards2Response = await fetch(RPC_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: '2.0',
                id: 1,
                method: 'getInflationReward',
                params: [stakeAccountPubkeys, { epoch: currentEpochNumber - 2 }]
              })
            });
            
            const rewards2Data = await rewards2Response.json();
            if (rewards2Data.result) {
              rewards = rewards2Data.result;
              console.log('Using epoch-2 rewards for stake detection');
            }
          } catch (e) {
            console.warn('Could not fetch epoch-2 rewards:', e);
          }
        }
        
        // Build account list with rates and withdrawer info
        const accountsWithRates = [];
        for (let i = 0; i < data.result.length; i++) {
          const acc = data.result[i];
          const stakeInfo = acc.account.data.parsed?.info;
          const stakeLamports = acc.account.lamports;
          const stakeXNT = stakeLamports / 1e9;
          const reward = rewards[i];
          const meta = stakeInfo?.meta;
          const staker = meta?.authorized?.staker || acc.pubkey;
          const withdrawer = meta?.authorized?.withdrawer || null;
          
          let rewardRate = 0;
          if (reward && reward.amount > 0 && stakeXNT > 0) {
            rewardRate = (reward.amount / 1e9) / stakeXNT;
          }
          
          accountsWithRates.push({
            pubkey: acc.pubkey,
            stakeXNT,
            rewardRate,
            staker,
            withdrawer,
            hasReward: reward && reward.amount > 0
          });
        }
        
        // Classify accounts - prioritize user selections, then withdrawer matching
        let selfStake = 0;
        let delegatedStake = 0;
        const delegators = [];
        const selfStakeAccounts = [];
        let detectionMethod = 'withdrawer-match';
        
        // Check for user selections first
        const userSelections = getSelfStakeSelections(voteAccount);
        
        if (userSelections && userSelections.pubkeys && userSelections.pubkeys.length > 0) {
          detectionMethod = 'user-selected';
          const selectedPubkeys = new Set(userSelections.pubkeys);
          
          for (const acc of accountsWithRates) {
            if (selectedPubkeys.has(acc.pubkey)) {
              selfStake += acc.stakeXNT;
              selfStakeAccounts.push({ pubkey: acc.pubkey, amount: acc.stakeXNT });
            } else {
              delegatedStake += acc.stakeXNT;
              delegators.push({ address: acc.staker, amount: acc.stakeXNT, pubkey: acc.pubkey });
            }
          }
        } else {
          // Auto-detect using withdrawer matching
          // Get vote account's authorized withdrawer
          let voteAccountWithdrawer = null;
          
          try {
            const voteAcctResponse = await fetch(RPC_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: '2.0',
                id: 1,
                method: 'getAccountInfo',
                params: [voteAccount, { encoding: 'jsonParsed' }]
              })
            });
            
            const voteAcctData = await voteAcctResponse.json();
            if (voteAcctData.result?.value?.data?.parsed?.info) {
              voteAccountWithdrawer = voteAcctData.result.value.data.parsed.info.authorizedWithdrawer;
            }
          } catch (e) {
            console.warn('Could not fetch vote account withdrawer:', e);
          }
          
          if (voteAccountWithdrawer) {
            for (const acc of accountsWithRates) {
              if (acc.withdrawer === voteAccountWithdrawer) {
                selfStake += acc.stakeXNT;
                selfStakeAccounts.push({ pubkey: acc.pubkey, amount: acc.stakeXNT });
              } else {
                delegatedStake += acc.stakeXNT;
                delegators.push({ address: acc.staker, amount: acc.stakeXNT, pubkey: acc.pubkey });
              }
            }
          } else {
            detectionMethod = 'not-configured';
            for (const acc of accountsWithRates) {
              delegatedStake += acc.stakeXNT;
              delegators.push({ address: acc.staker, amount: acc.stakeXNT, pubkey: acc.pubkey });
            }
          }
        }
        
        // Sort delegators by amount (largest first)
        delegators.sort((a, b) => b.amount - a.amount);
        
        // Fetch validator's inflation rewards to calculate derived baseAPY
        let derivedBaseAPY = 8; // Default fallback
        try {
          const validatorRewards = await fetchTotalValidatorRewards(voteAccount, commission, 7);
          if (validatorRewards && validatorRewards.length > 0) {
            const totalRewardsXNT = validatorRewards.reduce((sum, r) => sum + r.amount, 0) / 1e9;
            const avgDailyRewardsXNT = totalRewardsXNT / validatorRewards.length;
            const totalAnnualRewards = avgDailyRewardsXNT * 365;
            
            // Derive baseAPY: totalRewards = baseAPY * (selfStake + delegatedStake * commission%)
            const divisor = selfStake + (delegatedStake * commission / 100);
            if (divisor > 0) {
              derivedBaseAPY = (totalAnnualRewards / divisor) * 100;
            }
          }
        } catch (e) {
          console.warn('Could not fetch validator rewards for APY calculation:', e);
        }
        
        const breakdownData = {
          selfStake,
          delegatedStake,
          totalStake: selfStake + delegatedStake,
          delegators,
          selfStakeAccounts,
          accountCount: data.result.length,
          detectionMethod: detectionMethod,
          derivedBaseAPY: derivedBaseAPY
        };
        
        // Cache the result
        stakeBreakdownCache[cacheKey] = {
          timestamp: Date.now(),
          data: breakdownData
        };
        
        renderStakeBreakdown(breakdownData, validatorName, totalStake, commission, voteAccount);
        
      } catch (err) {
        console.error('Error fetching stake breakdown:', err);
        body.innerHTML = `
          <div class="stake-breakdown-loading">
            <span style="color: var(--danger);">Error loading stake breakdown</span>
            <span style="font-size: 0.75rem; color: var(--text-dim);">${err.message}</span>
          </div>
        `;
      }
    }
    
    function closeStakeBreakdown() {
      document.getElementById('stakeBreakdownModal').style.display = 'none';
      document.body.style.overflow = '';
    }
    
    // Stake Selection Modal Functions
    let currentStakeSelectionData = null;
    let currentStakeSelectionVote = null;
    
    async function openStakeSelection(voteAccount, validatorName) {
      const modal = document.getElementById('stakeSelectionModal');
      const body = document.getElementById('stakeSelectionBody');
      
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      currentStakeSelectionVote = voteAccount;
      
      body.innerHTML = `
        <div class="stake-selection-loading">
          <div class="loading-spinner-small"></div>
          <span>Loading stake accounts for ${validatorName}...</span>
        </div>
      `;
      
      try {
        // Fetch all stake accounts for this validator
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getProgramAccounts',
            params: [
              'Stake11111111111111111111111111111111111111',
              {
                encoding: 'jsonParsed',
                filters: [{ memcmp: { offset: 124, bytes: voteAccount } }]
              }
            ]
          })
        });
        
        const data = await response.json();
        
        if (!data.result || data.result.length === 0) {
          body.innerHTML = `
            <div class="stake-selection-loading">
              <span>No stake accounts found for this validator</span>
            </div>
          `;
          return;
        }
        
        // Parse stake accounts
        const stakeAccounts = data.result.map(acc => {
          const stakeInfo = acc.account.data.parsed?.info;
          const meta = stakeInfo?.meta;
          return {
            pubkey: acc.pubkey,
            stakeXNT: acc.account.lamports / 1e9,
            withdrawer: meta?.authorized?.withdrawer || 'Unknown',
            staker: meta?.authorized?.staker || 'Unknown'
          };
        }).sort((a, b) => b.stakeXNT - a.stakeXNT);
        
        currentStakeSelectionData = stakeAccounts;
        
        // Load existing selections
        const existingSelections = getSelfStakeSelections(voteAccount);
        const selectedPubkeys = existingSelections ? new Set(existingSelections.pubkeys) : new Set();
        
        renderStakeSelection(body, stakeAccounts, selectedPubkeys, validatorName, voteAccount);
        
      } catch (err) {
        console.error('Error loading stake accounts:', err);
        body.innerHTML = `
          <div class="stake-selection-loading">
            <span style="color: var(--danger);">Error loading stake accounts</span>
          </div>
        `;
      }
    }
    
    function renderStakeSelection(body, stakeAccounts, selectedPubkeys, validatorName, voteAccount) {
      // Calculate totals
      let selfStake = 0;
      let delegatedStake = 0;
      
      stakeAccounts.forEach(acc => {
        if (selectedPubkeys.has(acc.pubkey)) {
          selfStake += acc.stakeXNT;
        } else {
          delegatedStake += acc.stakeXNT;
        }
      });
      
      // Group by withdrawer for easier identification
      const withdrawerGroups = {};
      stakeAccounts.forEach(acc => {
        if (!withdrawerGroups[acc.withdrawer]) {
          withdrawerGroups[acc.withdrawer] = [];
        }
        withdrawerGroups[acc.withdrawer].push(acc);
      });
      
      const uniqueWithdrawers = Object.keys(withdrawerGroups).length;
      
      body.innerHTML = `
        <div class="stake-selection-intro">
          <strong>Select your self-stake accounts</strong><br>
          Check the boxes next to stake accounts that belong to YOU (your self-stake). 
          Unchecked accounts will be counted as delegated stake from others.
          ${uniqueWithdrawers > 1 ? `<br><br> Found ${uniqueWithdrawers} different withdrawer addresses - accounts with the same withdrawer are likely from the same wallet.` : ''}
        </div>
        
        <div class="stake-selection-summary">
          <div class="stake-selection-summary-item">
            <div class="stake-selection-summary-value self">${formatNumber(selfStake, 2)}</div>
            <div class="stake-selection-summary-label">Self-Stake (XNT)</div>
          </div>
          <div class="stake-selection-summary-item">
            <div class="stake-selection-summary-value delegated">${formatNumber(delegatedStake, 2)}</div>
            <div class="stake-selection-summary-label">Delegated (XNT)</div>
          </div>
        </div>
        
        <div class="stake-selection-list">
          ${stakeAccounts.map(acc => `
            <div class="stake-selection-item ${selectedPubkeys.has(acc.pubkey) ? 'selected' : ''}" 
                 onclick="toggleStakeSelectionItem(this, '${acc.pubkey}')"
                 data-pubkey="${acc.pubkey}">
              <div class="stake-selection-checkbox">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                  <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
              </div>
              <div class="stake-selection-info">
                <div class="stake-selection-address">${acc.pubkey.slice(0, 8)}...${acc.pubkey.slice(-8)}</div>
                <div class="stake-selection-details">Withdrawer: ${acc.withdrawer.slice(0, 8)}...${acc.withdrawer.slice(-4)}</div>
              </div>
              <div class="stake-selection-amount">${formatNumber(acc.stakeXNT, 2)} XNT</div>
            </div>
          `).join('')}
        </div>
        
        <div class="stake-selection-actions">
          <button class="stake-selection-btn secondary" onclick="closeStakeSelection()">Cancel</button>
          <button class="stake-selection-btn primary" onclick="saveStakeSelections('${voteAccount}')">Save Selection</button>
        </div>
      `;
    }
    
    function toggleStakeSelectionItem(element, pubkey) {
      element.classList.toggle('selected');
      
      // Recalculate totals
      const items = document.querySelectorAll('.stake-selection-item');
      const selectedPubkeys = new Set();
      
      items.forEach(item => {
        if (item.classList.contains('selected')) {
          selectedPubkeys.add(item.dataset.pubkey);
        }
      });
      
      // Update summary
      let selfStake = 0;
      let delegatedStake = 0;
      
      currentStakeSelectionData.forEach(acc => {
        if (selectedPubkeys.has(acc.pubkey)) {
          selfStake += acc.stakeXNT;
        } else {
          delegatedStake += acc.stakeXNT;
        }
      });
      
      const summaryItems = document.querySelectorAll('.stake-selection-summary-value');
      if (summaryItems.length >= 2) {
        summaryItems[0].textContent = formatNumber(selfStake, 2);
        summaryItems[1].textContent = formatNumber(delegatedStake, 2);
      }
    }
    
    function saveStakeSelections(voteAccount) {
      const items = document.querySelectorAll('.stake-selection-item');
      const selectedPubkeys = [];
      
      items.forEach(item => {
        if (item.classList.contains('selected')) {
          selectedPubkeys.push(item.dataset.pubkey);
        }
      });
      
      // Save to localStorage
      setSelfStakeSelections(voteAccount, selectedPubkeys);
      
      // Clear the stake breakdown cache for this validator so it recalculates
      if (stakeBreakdownCache[voteAccount]) {
        delete stakeBreakdownCache[voteAccount];
      }
      
      // Also clear any inline stake details that may be open
      const section = document.querySelector(`[data-stake-section="${voteAccount}"]`);
      if (section) {
        section.dataset.loaded = 'false';
      }
      
      closeStakeSelection();
      
      // Show confirmation
      showToast('Stake classification saved! Stake details will now use your selections.');
    }
    
    function closeStakeSelection() {
      document.getElementById('stakeSelectionModal').style.display = 'none';
      document.body.style.overflow = '';
      currentStakeSelectionData = null;
      currentStakeSelectionVote = null;
    }
    
    // Simple toast notification
    function showToast(message) {
      const existing = document.querySelector('.toast-notification');
      if (existing) existing.remove();
      
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        background: var(--accent-cyan);
        color: var(--bg-primary);
        padding: 1rem 1.5rem;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideUp 0.3s ease;
      `;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }
    
    // Show wallet required popup
    function showWalletRequired(action = 'perform this action') {
      const existing = document.querySelector('.wallet-required-popup');
      if (existing) existing.remove();
      
      const popup = document.createElement('div');
      popup.className = 'wallet-required-popup';
      popup.innerHTML = `
        <div class="wallet-required-content">
          <div class="wallet-required-icon"></div>
          <div class="wallet-required-title">Wallet Required</div>
          <div class="wallet-required-message">Please connect your wallet to ${action}.</div>
          <div class="wallet-required-buttons">
            <button class="wallet-required-btn connect" onclick="this.closest('.wallet-required-popup').remove(); connectWallet();">Connect Wallet</button>
            <button class="wallet-required-btn cancel" onclick="this.closest('.wallet-required-popup').remove();">Cancel</button>
          </div>
        </div>
      `;
      popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10001;
        animation: fadeIn 0.2s ease;
      `;
      
      const content = popup.querySelector('.wallet-required-content');
      content.style.cssText = `
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 2rem;
        text-align: center;
        max-width: 360px;
        width: 90%;
        animation: slideUp 0.3s ease;
      `;
      
      const icon = popup.querySelector('.wallet-required-icon');
      icon.style.cssText = `
        font-size: 3rem;
        margin-bottom: 1rem;
      `;
      
      const title = popup.querySelector('.wallet-required-title');
      title.style.cssText = `
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.5rem;
      `;
      
      const message = popup.querySelector('.wallet-required-message');
      message.style.cssText = `
        color: var(--text-secondary);
        margin-bottom: 1.5rem;
        line-height: 1.5;
      `;
      
      const buttons = popup.querySelector('.wallet-required-buttons');
      buttons.style.cssText = `
        display: flex;
        gap: 0.75rem;
        justify-content: center;
      `;
      
      popup.querySelectorAll('.wallet-required-btn').forEach(btn => {
        btn.style.cssText = `
          padding: 0.75rem 1.5rem;
          border-radius: 8px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s;
          border: none;
          font-size: 0.95rem;
        `;
        if (btn.classList.contains('connect')) {
          btn.style.background = 'var(--accent-gradient)';
          btn.style.color = 'var(--bg-primary)';
        } else {
          btn.style.background = 'var(--bg-secondary)';
          btn.style.color = 'var(--text-secondary)';
          btn.style.border = '1px solid var(--border)';
        }
      });
      
      // Close on background click
      popup.addEventListener('click', (e) => {
        if (e.target === popup) popup.remove();
      });
      
      document.body.appendChild(popup);
    }
    
    function renderStakeBreakdown(data, validatorName, totalStake, commission, voteAccount) {
      const body = document.getElementById('stakeBreakdownBody');
      // Safely extract with defaults
      if (!data) data = {};
      const selfStake = data.selfStake || 0;
      const delegatedStake = data.delegatedStake || 0;
      const delegators = Array.isArray(data.delegators) ? data.delegators : [];
      const accountCount = data.accountCount || 0;
      const detectionMethod = data.detectionMethod || 'unknown';
      
      const total = selfStake + delegatedStake;
      const selfPercent = total > 0 ? (selfStake / total) * 100 : 0;
      const delegatedPercent = total > 0 ? (delegatedStake / total) * 100 : 0;
      
      // Get validator icon and name
      let iconHtml = '';
      let displayName = validatorName;
      if (validatorInfoCache[voteAccount]) {
        displayName = validatorInfoCache[voteAccount].name || validatorName;
      }
      const firstLetter = (displayName || 'V').charAt(0).toUpperCase();
      if (validatorInfoCache[voteAccount] && validatorInfoCache[voteAccount].iconUrl) {
        iconHtml = `<img class="stake-breakdown-header-logo" src="${validatorInfoCache[voteAccount].iconUrl}" alt="${displayName}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
                    <div class="stake-breakdown-header-placeholder" style="display:none;">${firstLetter}</div>`;
      } else {
        iconHtml = `<div class="stake-breakdown-header-placeholder">${firstLetter}</div>`;
      }
      
      // Calculate SVG pie chart with minimum visual threshold
      const circumference = 2 * Math.PI * 100; // radius = 100
      const MIN_VISUAL_PERCENT = 12; // Minimum 12% visual display for visibility
      
      // Calculate visual percentages (for display only - labels show real values)
      let selfVisual = selfPercent;
      let delegatedVisual = delegatedPercent;
      
      // If both have values, ensure minimum visibility
      if (selfPercent > 0 && delegatedPercent > 0) {
        if (selfPercent < MIN_VISUAL_PERCENT) {
          selfVisual = MIN_VISUAL_PERCENT;
          delegatedVisual = 100 - MIN_VISUAL_PERCENT;
        } else if (delegatedPercent < MIN_VISUAL_PERCENT) {
          delegatedVisual = MIN_VISUAL_PERCENT;
          selfVisual = 100 - MIN_VISUAL_PERCENT;
        }
      }
      
      const selfDash = (selfVisual / 100) * circumference;
      const delegatedDash = (delegatedVisual / 100) * circumference;
      
      // Calculate true APYs - use derived baseAPY if available
      const baseAPY = data.derivedBaseAPY || 8; // Network base APY
      const selfStakeAPY = baseAPY; // Self-stake gets full rewards
      const delegatorAPY = baseAPY * (1 - commission / 100); // Delegators get minus commission
      
      // Calculate validator's earnings breakdown
      const selfStakeEarnings = selfStake * (baseAPY / 100);
      const commissionEarnings = delegatedStake * (baseAPY / 100) * (commission / 100);
      const totalValidatorEarnings = selfStakeEarnings + commissionEarnings;
      
      // Calculate validator's effective APY (return on their self-stake investment)
      const validatorAPY = selfStake > 0 ? (totalValidatorEarnings / selfStake) * 100 : baseAPY;
      
      // Detection method note
      const detectionNote = 
        detectionMethod === 'user-selected' ? 'Based on your manual selections' :
        detectionMethod === 'withdrawer-match' ? 'Auto-detected by matching withdrawer addresses' :
        detectionMethod === 'not-configured' ? 'Not configured - click Active Stake to set up' :
        detectionMethod === 'reward-analysis' ? 'Detected by analyzing reward distribution patterns' :
        detectionMethod === 'cached' ? 'Using cached detection from previous analysis' :
        detectionMethod === 'heuristic-0pct' ? 'Estimated using stake size heuristics (0% commission)' :
        'Estimated using stake size heuristics';
      
      body.innerHTML = `
        <div class="stake-breakdown-header">
          ${iconHtml}
          <div class="stake-breakdown-header-info">
            <h3>${displayName || voteAccount.slice(0,8) + '...'}</h3>
            <p>${formatNumber(total, 0)} XNT total  ${accountCount} stake accounts</p>
          </div>
        </div>
        
        ${commission === 0 ? `
        <div class="stake-zero-commission-warning">
          <div class="stake-warning-icon"></div>
          <div class="stake-warning-text">
            <strong>0% Commission Validator</strong><br>
            <span>With 0% commission, self-stake and delegations earn identical rewards, making it impossible to distinguish between them by analyzing reward patterns. The breakdown below is an estimate based on stake size heuristics.</span>
          </div>
        </div>
        ` : ''}
        
        <div class="stake-pie-container">
          <div class="stake-pie-chart">
            <svg width="240" height="240" viewBox="0 0 240 240">
              <circle cx="120" cy="120" r="100" fill="none" stroke="var(--bg-secondary)" stroke-width="14"/>
              <circle cx="120" cy="120" r="100" fill="none" stroke="var(--accent-cyan)" stroke-width="14"
                stroke-dasharray="${selfDash} ${circumference}" stroke-linecap="round"/>
              <circle cx="120" cy="120" r="100" fill="none" stroke="var(--accent-gold)" stroke-width="14"
                stroke-dasharray="${delegatedDash} ${circumference}" stroke-dashoffset="-${selfDash}" stroke-linecap="round"/>
            </svg>
            <div class="stake-pie-center">
              <div class="stake-pie-center-value">${formatNumber(total, 0)}</div>
              <div class="stake-pie-center-label">Total XNT</div>
            </div>
          </div>
        </div>
        
        <div class="stake-breakdown-stats">
          <div class="stake-stat-card self-stake">
            <div class="stake-stat-icon"></div>
            <div class="stake-stat-value">${formatNumber(selfStake, 0)}</div>
            <div class="stake-stat-label">Self-Stake</div>
            <div class="stake-stat-percent">${formatNumber(selfPercent, 1)}% of total</div>
          </div>
          <div class="stake-stat-card delegated">
            <div class="stake-stat-icon"></div>
            <div class="stake-stat-value">${formatNumber(delegatedStake, 0)}</div>
            <div class="stake-stat-label">Delegated</div>
            <div class="stake-stat-percent">${formatNumber(delegatedPercent, 1)}%  ${delegators.length} delegators</div>
          </div>
        </div>
        
        <div class="stake-apy-section">
          <div class="stake-apy-title">
             Earnings Breakdown (Estimated Annual)
            <span style="margin-left: 0.5rem; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700; font-size: 1.1rem;">${formatNumber(validatorAPY, 2)}% APY</span>
            <span style="font-size: 0.7rem; color: var(--text-dim); margin-left: 0.25rem;">(7-day avg)</span>
          </div>
          <div class="stake-apy-grid">
            <div class="stake-apy-item">
              <div class="stake-apy-value">${formatNumber(selfStakeEarnings, 0)} XNT</div>
              <div class="stake-apy-label">From Self-Stake (${selfStakeAPY}% base)</div>
            </div>
            <div class="stake-apy-item">
              <div class="stake-apy-value">${formatNumber(commissionEarnings, 0)} XNT</div>
              <div class="stake-apy-label">From ${commission}% Commission</div>
            </div>
          </div>
          <div style="text-align: center; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(0,255,163,0.2);">
            <span style="font-size: 0.8rem; color: var(--text-secondary);">Total Validator Earnings: </span>
            <span style="font-size: 1.1rem; font-weight: 600; color: var(--success);">${formatNumber(totalValidatorEarnings, 0)} XNT/year</span>
          </div>
        </div>
        
        ${delegators.length > 0 ? `
        <div class="stake-delegators-section">
          <div class="stake-delegators-header">
            <h4> Top Delegators</h4>
            <span class="stake-delegators-count">${delegators.length} total</span>
          </div>
          <div class="stake-delegators-list">
            ${delegators.slice(0, 10).map(d => `
              <div class="stake-delegator-item">
                <span class="stake-delegator-address">${d.address.slice(0, 8)}...${d.address.slice(-6)}</span>
                <span class="stake-delegator-amount">${formatNumber(d.amount, 0)} XNT</span>
              </div>
            `).join('')}
            ${delegators.length > 10 ? `
              <div style="text-align: center; padding: 0.5rem; color: var(--text-dim); font-size: 0.75rem;">
                + ${delegators.length - 10} more delegators
              </div>
            ` : ''}
          </div>
        </div>
        ` : ''}
        
        <div class="stake-cache-note">
          ${detectionNote}<br>
          Data cached for 5 minutes  Click "Stake Details" again to refresh
        </div>
      `;
      
      // Store the breakdown data for use in calculators
      if (!window.stakeBreakdownData) window.stakeBreakdownData = {};
      window.stakeBreakdownData[voteAccount] = {
        selfStake,
        delegatedStake,
        total,
        commission,
        delegatorCount: delegators.length
      };
    }

    async function fetchManageValidatorData(voteAccount) {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getVoteAccounts',
            params: []
          })
        });
        
        const data = await response.json();
        if (data.result) {
          const allValidators = [...data.result.current, ...data.result.delinquent];
          const validator = allValidators.find(v => v.votePubkey === voteAccount);
          
          if (validator) {
            const epochCredits = validator.epochCredits || [];
            if (epochCredits.length > 0) {
              const lastCredits = epochCredits[epochCredits.length - 1];
              document.getElementById('selectedCredits').textContent = formatNumber(lastCredits[1], 0);
            }
          }
        }
      } catch (e) {
        console.error('Error fetching validator data:', e);
      }
    }

    async function fetchStakeAccounts(voteAccount) {
      try {
        // Fetch current epoch first
        const epochInfo = await rpcCall('getEpochInfo');
        const currentEpoch = epochInfo.epoch;
        
        // Fetch stake accounts delegated to this validator
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getProgramAccounts',
            params: [
              'Stake11111111111111111111111111111111111111',
              {
                encoding: 'jsonParsed',
                filters: [
                  {
                    memcmp: {
                      offset: 124,
                      bytes: voteAccount
                    }
                  }
                ]
              }
            ]
          })
        });
        
        const data = await response.json();
        stakeAccounts = [];
        
        if (data.result && data.result.length > 0) {
          stakeAccounts = data.result.map(acc => {
            const info = acc.account.data.parsed?.info || {};
            const stake = info.stake || {};
            const delegation = stake.delegation || {};
            
            // Determine stake state
            const activationEpoch = parseInt(delegation.activationEpoch) || 0;
            const deactivationEpoch = delegation.deactivationEpoch;
            // MAX_U64 means not deactivating
            const isDeactivating = deactivationEpoch && deactivationEpoch !== '18446744073709551615';
            const deactivationEpochNum = isDeactivating ? parseInt(deactivationEpoch) : null;
            
            let state = 'active';
            if (isDeactivating) {
              if (deactivationEpochNum >= currentEpoch) {
                state = 'deactivating';
              } else {
                state = 'inactive';
              }
            } else if (activationEpoch >= currentEpoch) {
              state = 'activating';
            }
            
            return {
              pubkey: acc.pubkey,
              lamports: acc.account.lamports,
              data: info,
              state: state,
              activationEpoch: activationEpoch,
              deactivationEpoch: deactivationEpochNum,
              staker: info.meta?.authorized?.staker || null,
              withdrawer: info.meta?.authorized?.withdrawer || null
            };
          }).sort((a, b) => b.lamports - a.lamports);
          
          renderStakeAccounts();
        } else {
          document.getElementById('stakeAccountsContainer').innerHTML = 
            '<div class="loading-text">No stake accounts found</div>';
        }
      } catch (e) {
        console.error('Error fetching stake accounts:', e);
        document.getElementById('stakeAccountsContainer').innerHTML = 
          '<div class="loading-text">Error loading stake accounts</div>';
      }
    }

    function renderStakeAccounts() {
      const container = document.getElementById('stakeAccountsContainer');
      
      if (stakeAccounts.length === 0) {
        container.innerHTML = '<div class="loading-text">No stake accounts found</div>';
        return;
      }
      
      // Define state priority for sorting (lower = higher priority)
      const statePriority = {
        'active': 1,
        'activating': 2,
        'deactivating': 3,
        'inactive': 4
      };
      
      // Create sorted array with original indices preserved
      const sortedStakes = stakeAccounts
        .map((stake, index) => ({ stake, originalIndex: index }))
        .sort((a, b) => {
          // First sort by state priority
          const priorityA = statePriority[a.stake.state] || 1;
          const priorityB = statePriority[b.stake.state] || 1;
          
          if (priorityA !== priorityB) {
            return priorityA - priorityB;
          }
          
          // Then sort by balance (highest first)
          return b.stake.lamports - a.stake.lamports;
        });
      
      container.innerHTML = sortedStakes.map(({ stake, originalIndex }) => {
        // Determine badge text and class based on state
        let badgeText = 'STAKE';
        let badgeClass = 'stake';
        
        switch (stake.state) {
          case 'activating':
            badgeText = 'ACTIVATING';
            badgeClass = 'stake activating';
            break;
          case 'deactivating':
            badgeText = 'DEACTIVATING';
            badgeClass = 'stake deactivating';
            break;
          case 'inactive':
            badgeText = 'INACTIVE';
            badgeClass = 'stake inactive';
            break;
          default:
            badgeText = 'STAKE';
            badgeClass = 'stake active';
        }
        
        // Check if connected wallet has authority
        const hasStakeAuth = walletPublicKey && stake.staker === walletPublicKey;
        const hasWithdrawAuth = walletPublicKey && stake.withdrawer === walletPublicKey;
        
        return `
          <div class="account-row ${selectedAccountType === 'stake-${originalIndex}' ? 'selected' : ''}" onclick="selectAccount('stake-${originalIndex}')">
            <div class="account-row-left">
              <span class="account-type-badge ${badgeClass}">${badgeText}</span>
              <span class="account-address">${shortenAddress(stake.pubkey)}</span>
              ${getCopyButtonHtml(stake.pubkey)}
              <span style="color: var(--text-dim); font-size: 0.75rem; margin-left: 0.5rem;">
                ${formatNumber(lamportsToXNT(stake.lamports), 2)} XNT
              </span>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <div class="authority-badges">
                <span class="auth-badge ${hasStakeAuth ? 'has-auth' : 'no-auth'}">Stake</span>
                <span class="auth-badge ${hasWithdrawAuth ? 'has-auth' : 'no-auth'}">Withdraw</span>
              </div>
              <button class="account-select-btn ${selectedAccountType === 'stake-${originalIndex}' ? 'selected' : ''}" id="stakeSelectBtn-${originalIndex}">
                ${selectedAccountType === 'stake-${originalIndex}' ? ' Selected' : 'Select'}
              </button>
            </div>
          </div>
        `;
      }).join('');
    }

    function toggleAuthorityLegend() {
      const legend = document.getElementById('authorityLegend');
      legend.classList.toggle('show');
    }

    function refreshStakeAccounts() {
      if (!currentManageValidator || !currentManageValidator.voteAccount) {
        showToast('No validator selected');
        return;
      }
      
      // Remember the currently selected account
      const currentSelection = selectedAccountType;
      
      // Show loading state
      document.getElementById('stakeAccountsContainer').innerHTML = 
        '<div class="loading-text">Refreshing stake accounts...</div>';
      
      // Fetch stake accounts and re-select after
      fetchStakeAccounts(currentManageValidator.voteAccount).then(() => {
        // Re-select the current account to refresh details
        if (currentSelection && currentSelection.startsWith('stake-')) {
          // Wait a bit for the stake accounts to render
          setTimeout(() => {
            selectAccount(currentSelection);
          }, 100);
        }
      });
      
      showToast('Stake accounts refreshed');
    }

    function selectAccount(accountType) {
      selectedAccountType = accountType;
      const authorityBadge = document.getElementById('authorityBadge');
      
      // Update UI for all rows
      document.querySelectorAll('.account-row').forEach(row => row.classList.remove('selected'));
      document.querySelectorAll('.account-select-btn').forEach(btn => {
        btn.classList.remove('selected');
        btn.textContent = 'Select';
      });
      
      if (accountType === 'vote') {
        document.getElementById('voteAccountRow').classList.add('selected');
        document.getElementById('voteSelectBtn').classList.add('selected');
        document.getElementById('voteSelectBtn').textContent = ' Selected';
        
        // Show vote account details
        document.getElementById('selectedAccountTitle').textContent = 'Vote Account Details';
        document.getElementById('selectedBalance').textContent = formatNumber(currentManageValidator.rewardsBalance, 4);
        document.getElementById('selectedCommission').textContent = currentManageValidator.commission + '%';
        
        // Show vote-specific boxes, hide stake-specific boxes
        document.getElementById('balanceBox').style.display = 'block';
        document.getElementById('stakedBalanceBox').style.display = 'none';
        document.getElementById('liquidBalanceBox').style.display = 'none';
        document.getElementById('stakeAuthorityBox').style.display = 'none';
        document.getElementById('withdrawAuthorityBox').style.display = 'none';
        document.getElementById('voteAuthorityBox').style.display = 'block';
        document.getElementById('voteWithdrawAuthorityBox').style.display = 'block';
        document.getElementById('validatorIdBalanceBox').style.display = 'block';
        document.getElementById('walletBalanceBox').style.display = 'none';
        document.getElementById('creditsBox').style.display = 'block';
        document.getElementById('commissionBox').style.display = 'block';
        
        // Fetch validator ID balance
        document.getElementById('selectedValidatorIdBalance').textContent = 'Loading...';
        fetchValidatorIdBalance();
        
        // Fetch vote account authorities
        fetchVoteAccountAuthoritiesForDisplay();
        
        // Show vote account actions
        updateActionsForVote();
        
        // Re-fetch credits
        fetchManageValidatorData(currentManageValidator.voteAccount);
        
        // Update authority badge - check if wallet has withdraw authority
        document.getElementById('authorityBadge').style.display = 'flex';
        document.getElementById('authorityBadgePair').style.display = 'none';
        
        if (walletPublicKey) {
          // Show loading state while checking authority
          authorityBadge.className = 'authority-badge';
          authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">Checking authority...</span>';
          checkWithdrawAuthority();
        } else {
          authorityBadge.className = 'authority-badge clickable';
          authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">No wallet connected</span>';
        }
        
      } else if (accountType.startsWith('stake-')) {
        const index = parseInt(accountType.split('-')[1]);
        const stake = stakeAccounts[index];
        
        const stakeRow = document.querySelector(`[onclick="selectAccount('stake-${index}')"]`);
        if (stakeRow) stakeRow.classList.add('selected');
        
        const stakeBtn = document.getElementById(`stakeSelectBtn-${index}`);
        if (stakeBtn) {
          stakeBtn.classList.add('selected');
          stakeBtn.textContent = ' Selected';
        }
        
        // Show stake account details
        document.getElementById('selectedAccountTitle').textContent = 'Stake Account Details';
        
        // Calculate staked vs liquid balance
        // For inactive stakes, all funds are liquid (withdrawable)
        const totalLamports = stake.lamports;
        let stakedLamports, liquidLamports;
        
        if (stake.state === 'inactive') {
          // Inactive stakes have no active delegation - all funds are liquid
          stakedLamports = 0;
          liquidLamports = totalLamports;
        } else {
          // Active, activating, or deactivating stakes have delegated funds
          stakedLamports = stake.data.stake?.delegation?.stake ? parseInt(stake.data.stake.delegation.stake) : 0;
          liquidLamports = totalLamports - stakedLamports;
        }
        
        document.getElementById('selectedStakedBalance').textContent = formatNumber(lamportsToXNT(stakedLamports), 4);
        document.getElementById('selectedLiquidBalance').textContent = formatNumber(lamportsToXNT(liquidLamports), 4);
        
        // Show stake-specific boxes, hide vote-specific boxes
        document.getElementById('balanceBox').style.display = 'none';
        document.getElementById('stakedBalanceBox').style.display = 'block';
        document.getElementById('liquidBalanceBox').style.display = 'block';
        document.getElementById('withdrawAuthorityBox').style.display = 'block';
        document.getElementById('stakeAuthorityBox').style.display = 'block';
        document.getElementById('voteAuthorityBox').style.display = 'none';
        document.getElementById('voteWithdrawAuthorityBox').style.display = 'none';
        document.getElementById('validatorIdBalanceBox').style.display = 'none';
        document.getElementById('walletBalanceBox').style.display = 'none';
        document.getElementById('creditsBox').style.display = 'none';
        document.getElementById('commissionBox').style.display = 'none';
        
        // Show stake account actions
        updateActionsForStake(stake.state);
        
        // Update stake authority for stake account
        const staker = stake.data.meta?.authorized?.staker;
        const stakeAuthorityIndicator = document.getElementById('stakeAuthorityIndicator');
        if (staker) {
          document.getElementById('selectedStakeAuthority').textContent = shortenAddress(staker);
          document.getElementById('stakeAuthorityCopyBtn').innerHTML = getCopyButtonHtml(staker);
          
          if (walletPublicKey && staker === walletPublicKey) {
            stakeAuthorityIndicator.textContent = '';
            stakeAuthorityIndicator.className = 'authority-indicator yours';
          } else if (walletPublicKey) {
            stakeAuthorityIndicator.textContent = '';
            stakeAuthorityIndicator.className = 'authority-indicator';
          } else {
            stakeAuthorityIndicator.textContent = '';
            stakeAuthorityIndicator.className = 'authority-indicator';
          }
        } else {
          document.getElementById('selectedStakeAuthority').textContent = 'Unknown';
          document.getElementById('stakeAuthorityCopyBtn').innerHTML = '';
          stakeAuthorityIndicator.textContent = '';
          stakeAuthorityIndicator.className = 'authority-indicator';
        }
        
        // Update withdraw authority for stake account
        const withdrawer = stake.data.meta?.authorized?.withdrawer;
        const withdrawAuthorityIndicator = document.getElementById('withdrawAuthorityIndicator');
        if (withdrawer) {
          document.getElementById('selectedWithdrawAuthority').textContent = shortenAddress(withdrawer);
          document.getElementById('withdrawAuthorityCopyBtn').innerHTML = getCopyButtonHtml(withdrawer);
          
          if (walletPublicKey && withdrawer === walletPublicKey) {
            withdrawAuthorityIndicator.textContent = '';
            withdrawAuthorityIndicator.className = 'authority-indicator yours';
          } else if (walletPublicKey) {
            withdrawAuthorityIndicator.textContent = '';
            withdrawAuthorityIndicator.className = 'authority-indicator';
          } else {
            withdrawAuthorityIndicator.textContent = '';
            withdrawAuthorityIndicator.className = 'authority-indicator';
          }
        } else {
          document.getElementById('selectedWithdrawAuthority').textContent = 'Unknown';
          document.getElementById('withdrawAuthorityCopyBtn').innerHTML = '';
          withdrawAuthorityIndicator.textContent = '';
          withdrawAuthorityIndicator.className = 'authority-indicator';
        }
        
        // Update authority badges - show the pair, hide the single badge
        document.getElementById('authorityBadge').style.display = 'none';
        document.getElementById('authorityBadgePair').style.display = 'flex';
        
        const stakeAuthorityBadge = document.getElementById('stakeAuthorityBadge');
        const withdrawAuthorityBadge = document.getElementById('withdrawAuthorityBadge');
        
        if (walletPublicKey) {
          const hasStakeAuthority = staker === walletPublicKey;
          const hasWithdrawAuthority = withdrawer === walletPublicKey;
          
          // Stake authority badge
          if (hasStakeAuthority) {
            stakeAuthorityBadge.className = 'authority-badge has-authority';
            stakeAuthorityBadge.innerHTML = '<span class="authority-badge-text">Stake Authority </span>';
          } else {
            stakeAuthorityBadge.className = 'authority-badge no-authority';
            stakeAuthorityBadge.innerHTML = '<span class="authority-badge-text">Stake Authority </span>';
          }
          
          // Withdraw authority badge
          if (hasWithdrawAuthority) {
            withdrawAuthorityBadge.className = 'authority-badge has-authority';
            withdrawAuthorityBadge.innerHTML = '<span class="authority-badge-text">Withdraw Authority </span>';
          } else {
            withdrawAuthorityBadge.className = 'authority-badge no-authority';
            withdrawAuthorityBadge.innerHTML = '<span class="authority-badge-text">Withdraw Authority </span>';
          }
        } else {
          // No wallet connected - show both as gray/neutral
          stakeAuthorityBadge.className = 'authority-badge';
          stakeAuthorityBadge.innerHTML = '<span class="authority-badge-text">Stake Authority</span>';
          withdrawAuthorityBadge.className = 'authority-badge';
          withdrawAuthorityBadge.innerHTML = '<span class="authority-badge-text">Withdraw Authority</span>';
        }
      }
    }

    // Fetch validator identity account balance
    async function fetchValidatorIdBalance() {
      if (!currentManageValidator || !currentManageValidator.identityPubkey) {
        document.getElementById('selectedValidatorIdBalance').textContent = '-';
        return;
      }
      
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBalance',
            params: [currentManageValidator.identityPubkey]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value !== undefined) {
          document.getElementById('selectedValidatorIdBalance').textContent = formatNumber(lamportsToXNT(data.result.value), 4);
        } else {
          document.getElementById('selectedValidatorIdBalance').textContent = '-';
        }
      } catch (e) {
        console.error('Error fetching validator ID balance:', e);
        document.getElementById('selectedValidatorIdBalance').textContent = '-';
      }
    }

    // Fetch vote account authorities for display on manage page
    async function fetchVoteAccountAuthoritiesForDisplay() {
      if (!currentManageValidator || !currentManageValidator.voteAccount) {
        return;
      }
      
      // Set loading state
      document.getElementById('selectedVoteAuthority').textContent = 'Loading...';
      document.getElementById('selectedVoteWithdrawAuthority').textContent = 'Loading...';
      document.getElementById('voteAuthorityCopyBtn').innerHTML = '';
      document.getElementById('voteWithdrawAuthorityCopyBtn').innerHTML = '';
      
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAccountInfo',
            params: [currentManageValidator.voteAccount, { encoding: 'jsonParsed' }]
          })
        });
        
        const data = await response.json();
        
        if (data.result && data.result.value) {
          const voteData = data.result.value.data.parsed.info;
          
          // Get vote authority - may be in authorizedVoters array or authorizedVoter field
          const voteAuthority = voteData.authorizedVoters?.[0]?.authorizedVoter || voteData.authorizedVoter;
          const withdrawAuthority = voteData.authorizedWithdrawer;
          
          // Display Vote Authority
          const voteAuthorityIndicator = document.getElementById('voteAuthorityIndicator');
          if (voteAuthority) {
            document.getElementById('selectedVoteAuthority').textContent = shortenAddress(voteAuthority);
            document.getElementById('voteAuthorityCopyBtn').innerHTML = getCopyButtonHtml(voteAuthority);
            
            if (walletPublicKey && voteAuthority === walletPublicKey) {
              voteAuthorityIndicator.textContent = '';
              voteAuthorityIndicator.className = 'authority-indicator yours';
            } else {
              voteAuthorityIndicator.textContent = '';
              voteAuthorityIndicator.className = 'authority-indicator';
            }
          } else {
            document.getElementById('selectedVoteAuthority').textContent = 'Unknown';
            voteAuthorityIndicator.textContent = '';
            voteAuthorityIndicator.className = 'authority-indicator';
          }
          
          // Display Withdraw Authority
          const withdrawIndicator = document.getElementById('voteWithdrawAuthorityIndicator');
          if (withdrawAuthority) {
            document.getElementById('selectedVoteWithdrawAuthority').textContent = shortenAddress(withdrawAuthority);
            document.getElementById('voteWithdrawAuthorityCopyBtn').innerHTML = getCopyButtonHtml(withdrawAuthority);
            
            if (walletPublicKey && withdrawAuthority === walletPublicKey) {
              withdrawIndicator.textContent = '';
              withdrawIndicator.className = 'authority-indicator yours';
            } else {
              withdrawIndicator.textContent = '';
              withdrawIndicator.className = 'authority-indicator';
            }
          } else {
            document.getElementById('selectedVoteWithdrawAuthority').textContent = 'Unknown';
            withdrawIndicator.textContent = '';
            withdrawIndicator.className = 'authority-indicator';
          }
          
          // Update vote authority badges in account list
          const voteAuthorityBadges = document.getElementById('voteAuthorityBadges');
          if (voteAuthorityBadges) {
            const hasVoteAuth = walletPublicKey && voteAuthority === walletPublicKey;
            const hasWithdrawAuth = walletPublicKey && withdrawAuthority === walletPublicKey;
            voteAuthorityBadges.innerHTML = `
              <span class="auth-badge ${hasVoteAuth ? 'has-auth' : 'no-auth'}">Vote</span>
              <span class="auth-badge ${hasWithdrawAuth ? 'has-auth' : 'no-auth'}">Withdraw</span>
            `;
          }
        } else {
          document.getElementById('selectedVoteAuthority').textContent = 'Unable to fetch';
          document.getElementById('selectedVoteWithdrawAuthority').textContent = 'Unable to fetch';
        }
      } catch (e) {
        console.error('Error fetching vote account authorities:', e);
        document.getElementById('selectedVoteAuthority').textContent = 'Error';
        document.getElementById('selectedVoteWithdrawAuthority').textContent = 'Error';
      }
    }

    // Fetch connected wallet balance
    async function fetchConnectedWalletBalance() {
      if (!walletPublicKey) {
        document.getElementById('selectedWalletBalance').textContent = '-';
        return;
      }
      
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBalance',
            params: [walletPublicKey]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value !== undefined) {
          document.getElementById('selectedWalletBalance').textContent = formatNumber(lamportsToXNT(data.result.value), 4);
        } else {
          document.getElementById('selectedWalletBalance').textContent = '-';
        }
      } catch (e) {
        console.error('Error fetching wallet balance:', e);
        document.getElementById('selectedWalletBalance').textContent = '-';
      }
    }

    // Update actions grid for vote account
    function updateActionsForVote() {
      const actionsGrid = document.querySelector('.manage-actions-grid');
      if (!actionsGrid) {
        console.error('Actions grid not found');
        return;
      }
      actionsGrid.innerHTML = `
        <button class="manage-action-btn" onclick="initiateCreateStake()">
          <span class="action-icon" style="color: #ffc107; font-weight: bold; font-size: 1.8rem;">+</span>
          <span class="action-text">
            <span class="action-title">Create & Delegate Stake</span>
            <span class="action-desc">Create new stake account</span>
          </span>
        </button>
        
        <button class="manage-action-btn" onclick="initiateWithdraw()">
          <span class="action-icon"></span>
          <span class="action-text">
            <span class="action-title">Withdraw XNT</span>
            <span class="action-desc">Withdraw rewards to your wallet</span>
          </span>
        </button>
        
        <button class="manage-action-btn" onclick="initiateSendToIdentity()">
          <span class="action-icon"></span>
          <span class="action-text">
            <span class="action-title">Send XNT to ID Wallet</span>
            <span class="action-desc">Transfer to validator identity wallet</span>
          </span>
        </button>
        
        <button class="manage-action-btn" onclick="initiateChangeCommission()">
          <span class="action-icon"></span>
          <span class="action-text">
            <span class="action-title">Change Commission</span>
            <span class="action-desc">Update validator commission rate</span>
          </span>
        </button>
        
        <button class="manage-action-btn" onclick="initiateUpdateIdentity()">
          <span class="action-icon"></span>
          <span class="action-text">
            <span class="action-title">Update Identity</span>
            <span class="action-desc">Change on-chain validator info</span>
          </span>
        </button>
        
        <button class="manage-action-btn" onclick="initiateChangeAuthority()">
          <span class="action-icon"></span>
          <span class="action-text">
            <span class="action-title">Change Authority</span>
            <span class="action-desc">Transfer withdraw authority</span>
          </span>
        </button>
      `;
    }

    // Update actions grid for stake account based on state
    function updateActionsForStake(stakeState = 'active') {
      const actionsGrid = document.querySelector('.manage-actions-grid');
      if (!actionsGrid) {
        console.error('Actions grid not found');
        return;
      }
      
      // Define which actions are enabled for each state
      const actionAvailability = {
        'createDelegate': true, // Always available
        'sendToId': true, // Always available - transfers from wallet
        'delegate': stakeState === 'inactive',
        'undelegate': stakeState === 'active' || stakeState === 'activating',
        'split': stakeState === 'active',
        'merge': stakeState === 'active' || stakeState === 'inactive',
        'withdraw': stakeState === 'inactive',
        'close': stakeState === 'inactive',
        'setStakeAuth': true, // Always available
        'setWithdrawAuth': true // Always available
      };
      
      // Helper to create button HTML
      const createBtn = (id, icon, title, desc, onclick, iconStyle = '') => {
        const isEnabled = actionAvailability[id];
        const disabledClass = isEnabled ? '' : 'disabled';
        const clickHandler = isEnabled ? onclick : `showActionExplainer('${id}', '${stakeState}')`;
        const lockIcon = isEnabled ? '' : '<span class="action-lock"></span>';
        
        return `
          <button class="manage-action-btn ${disabledClass}" onclick="${clickHandler}">
            <span class="action-icon" ${iconStyle}>${icon}</span>
            <span class="action-text">
              <span class="action-title">${title}${lockIcon}</span>
              <span class="action-desc">${desc}</span>
            </span>
          </button>
        `;
      };
      
      // Buttons ordered by category: Stake Management  Restructure  Exit  Admin
      actionsGrid.innerHTML = 
        createBtn('createDelegate', '+', 'Create & Delegate Stake', 'Create new stake account', 'initiateCreateStake()', 'style="color: #ffc107; font-weight: bold; font-size: 1.8rem;"') +
        createBtn('sendToId', '', 'Send XNT to ID Wallet', 'Transfer to validator identity', 'initiateSendToIdentity()') +
        createBtn('delegate', '', 'Delegate Stake', 'Delegate to a validator', 'initiateRedelegate()') +
        createBtn('undelegate', '', 'Undelegate Stake', 'Begin deactivation process', 'initiateUndelegate()') +
        createBtn('split', '', 'Split Stake', 'Divide into two accounts', 'initiateSplitStake()') +
        createBtn('merge', '', 'Merge Stakes', 'Combine multiple stake accounts', 'initiateMergeStakes()') +
        createBtn('withdraw', '', 'Withdraw from Stake', 'Withdraw XNT to wallet', 'initiateWithdrawStake()') +
        createBtn('close', '', 'Close Stake Account', 'Withdraw all & close account', 'initiateCloseStakeAccount()') +
        createBtn('setStakeAuth', '', 'Set Stake Authority', 'Change who can delegate', 'initiateSetStakeAuthority()') +
        createBtn('setWithdrawAuth', '', 'Set Withdraw Authority', 'Change who can withdraw', 'initiateSetWithdrawAuthority()');
    }
    
    // Show explainer for disabled actions
    function showActionExplainer(action, stakeState) {
      const explainers = {
        delegate: {
          active: {
            title: 'Cannot Delegate Active Stake',
            message: 'Your stake is currently active with a validator. To switch validators, you need to:',
            steps: ['1. Undelegate your stake (begins deactivation)', '2. Wait ~2 epochs for deactivation to complete', '3. Delegate to your new validator'],
            action: { text: 'Undelegate Now', onclick: 'initiateUndelegate()' }
          },
          activating: {
            title: 'Stake Still Activating',
            message: 'Your stake is still activating with the current validator. Please wait for activation to complete before making changes.',
            steps: ['Wait for activation to complete', 'Then undelegate if you want to switch validators'],
            action: null
          },
          deactivating: {
            title: 'Stake is Deactivating',
            message: 'Your stake is currently deactivating. Once complete, you\'ll be able to delegate to a new validator.',
            steps: ['Wait for deactivation to complete (~2 epochs)', 'Then delegate to your chosen validator'],
            action: null
          },
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires an inactive stake account to delegate.',
            steps: ['1. Create a new stake account', '2. Or select an existing inactive stake from the list'],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        },
        undelegate: {
          deactivating: {
            title: 'Already Deactivating',
            message: 'This stake is already in the deactivation process. No further action needed.',
            steps: ['Wait for deactivation to complete', 'Then withdraw or delegate to a new validator'],
            action: null
          },
          inactive: {
            title: 'Stake is Inactive',
            message: 'This stake is already inactive (not delegated). You can delegate it to a validator or withdraw the funds.',
            steps: [],
            action: { text: 'Delegate Stake', onclick: 'initiateRedelegate()' }
          },
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires an active stake account to undelegate.',
            steps: ['1. Create a new stake account', '2. Or select an existing active stake from the list'],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        },
        merge: {
          activating: {
            title: 'Cannot Merge Activating Stakes',
            message: 'Stakes can only be merged when they are in the same state (both active or both inactive).',
            steps: ['Wait for activation to complete', 'Then merge with other active stakes'],
            action: null
          },
          deactivating: {
            title: 'Cannot Merge Deactivating Stakes',
            message: 'Stakes can only be merged when they are in the same state (both active or both inactive).',
            steps: ['Wait for deactivation to complete', 'Then merge with other inactive stakes'],
            action: null
          },
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires stake accounts to merge together.',
            steps: ['1. Create a new stake account', '2. Or select an existing stake from the list'],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        },
        split: {
          activating: {
            title: 'Cannot Split Activating Stake',
            message: 'Stakes can only be split when fully active.',
            steps: ['Wait for activation to complete', 'Then split if needed'],
            action: null
          },
          deactivating: {
            title: 'Cannot Split Deactivating Stake',
            message: 'Stakes can only be split when fully active.',
            steps: ['This stake is deactivating and cannot be split'],
            action: null
          },
          inactive: {
            title: 'Cannot Split Inactive Stake',
            message: 'Inactive stakes cannot be split. You can delegate it first or withdraw the funds.',
            steps: [],
            action: { text: 'Delegate Stake', onclick: 'initiateRedelegate()' }
          },
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires an active stake account to split.',
            steps: ['1. Create a new stake account', '2. Or select an existing active stake from the list'],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        },
        withdraw: {
          active: {
            title: 'Cannot Withdraw Active Stake',
            message: 'You can only withdraw from inactive stakes. To access these funds:',
            steps: ['1. Undelegate your stake', '2. Wait ~2 epochs for deactivation', '3. Withdraw your XNT'],
            action: { text: 'Undelegate Now', onclick: 'initiateUndelegate()' }
          },
          activating: {
            title: 'Cannot Withdraw Activating Stake',
            message: 'Your stake is still activating. You\'ll need to undelegate first.',
            steps: ['1. Undelegate to cancel activation', '2. Wait for deactivation to complete', '3. Withdraw your XNT'],
            action: { text: 'Undelegate Now', onclick: 'initiateUndelegate()' }
          },
          deactivating: {
            title: 'Stake is Deactivating',
            message: 'Your stake is deactivating. Once complete, you\'ll be able to withdraw.',
            steps: ['Wait ~2 epochs for deactivation to complete', 'Then withdraw your XNT'],
            action: null
          },
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires an inactive stake account to withdraw from.',
            steps: ['1. Create a new stake account', '2. Or select an existing inactive stake from the list'],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        },
        close: {
          active: {
            title: 'Cannot Close Active Stake',
            message: 'You can only close inactive stake accounts. To close this account:',
            steps: ['1. Undelegate your stake', '2. Wait ~2 epochs for deactivation', '3. Close the account'],
            action: { text: 'Undelegate Now', onclick: 'initiateUndelegate()' }
          },
          activating: {
            title: 'Cannot Close Activating Stake',
            message: 'Your stake is still activating. You\'ll need to undelegate first.',
            steps: ['1. Undelegate to cancel activation', '2. Wait for deactivation to complete', '3. Close the account'],
            action: { text: 'Undelegate Now', onclick: 'initiateUndelegate()' }
          },
          deactivating: {
            title: 'Stake is Deactivating',
            message: 'Your stake is deactivating. Once complete, you\'ll be able to close the account.',
            steps: ['Wait ~2 epochs for deactivation to complete', 'Then close the account'],
            action: null
          },
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires a stake account. Create a new stake account first.',
            steps: [],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        },
        setStakeAuth: {
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires a stake account to change its stake authority.',
            steps: ['1. Create a new stake account', '2. Or select an existing stake from the list'],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        },
        setWithdrawAuth: {
          new: {
            title: 'No Stake Account Selected',
            message: 'This action requires a stake account to change its withdraw authority.',
            steps: ['1. Create a new stake account', '2. Or select an existing stake from the list'],
            action: { text: 'Create & Delegate Stake', onclick: 'initiateCreateStake()' }
          }
        }
      };
      
      const info = explainers[action]?.[stakeState];
      if (!info) {
        showToast('This action is not available for the current stake state');
        return;
      }
      
      // Build modal content
      let stepsHtml = '';
      if (info.steps.length > 0) {
        stepsHtml = `<ul class="explainer-steps">${info.steps.map(s => `<li>${s}</li>`).join('')}</ul>`;
      }
      
      let actionBtn = '';
      if (info.action) {
        actionBtn = `<button class="explainer-action-btn" onclick="${info.action.onclick}; closeActionExplainerModal()">${info.action.text}</button>`;
      }
      
      const modal = document.getElementById('actionExplainerModal');
      document.getElementById('actionExplainerTitle').textContent = info.title;
      document.getElementById('actionExplainerContent').innerHTML = `
        <p>${info.message}</p>
        ${stepsHtml}
        <div class="explainer-actions">
          ${actionBtn}
          <button class="explainer-close-btn" onclick="closeActionExplainerModal()">Got it</button>
        </div>
      `;
      
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }
    
    function closeActionExplainerModal() {
      document.getElementById('actionExplainerModal').style.display = 'none';
      document.body.style.overflow = '';
    }

    // =========================================
    // MERGE STAKES MODAL
    // =========================================
    
    let mergeStakesSelected = []; // Array of selected stake pubkeys
    
    function initiateMergeStakes() {
      if (!walletPublicKey) {
        showWalletRequired('merge stake accounts');
        return;
      }
      
      if (!currentManageValidator) {
        alert('Validator data not available.');
        return;
      }
      
      if (stakeAccounts.length < 2) {
        alert('You need at least 2 stake accounts to merge.');
        return;
      }
      
      // Reset selection
      mergeStakesSelected = [];
      
      // Populate modal
      document.getElementById('mergeStakesValidatorName').textContent = currentManageValidator.name;
      const msgEl = document.getElementById('mergeStakesMessage');
      msgEl.style.display = 'none';
      msgEl.textContent = '';
      msgEl.className = 'send-message';
      document.getElementById('mergeStakesSummarySection').style.display = 'none';
      document.getElementById('mergeStakesConfirmBtn').disabled = true;
      document.getElementById('mergeStakesConfirmBtn').textContent = 'Merge Selected Stakes';
      document.getElementById('mergeStakesConfirmBtn').onclick = confirmMergeStakes;
      document.getElementById('mergeStakesCancelBtn').textContent = 'Cancel';
      
      // Analyze and render stakes
      renderMergeStakesList();
      
      // Show modal
      document.getElementById('mergeStakesModal').style.display = 'flex';
    }
    
    function closeMergeStakesModal() {
      document.getElementById('mergeStakesModal').style.display = 'none';
      mergeStakesSelected = [];
    }
    
    function renderMergeStakesList() {
      const container = document.getElementById('mergeStakesList');
      
      if (stakeAccounts.length === 0) {
        container.innerHTML = '<div class="loading-text">No stake accounts found</div>';
        return;
      }
      
      // Analyze each stake for merge eligibility
      const analyzedStakes = stakeAccounts.map(stake => {
        const staker = stake.data.meta?.authorized?.staker;
        const withdrawer = stake.data.meta?.authorized?.withdrawer;
        const delegation = stake.data.stake?.delegation;
        const voter = delegation?.voter;
        
        // Check eligibility
        let eligible = true;
        let reason = '';
        
        // Must be delegated to the current validator
        if (voter !== currentManageValidator.voteAccount) {
          eligible = false;
          reason = 'Different validator';
        }
        
        // Connected wallet must be the stake authority
        if (staker !== walletPublicKey) {
          eligible = false;
          reason = 'Not stake authority';
        }
        
        return {
          ...stake,
          staker,
          withdrawer,
          voter,
          eligible,
          reason
        };
      });
      
      // Find the "base" stake (first eligible one that others will merge into)
      // All mergeable stakes must share the same staker AND withdrawer
      const eligibleStakes = analyzedStakes.filter(s => s.eligible);
      
      // Group by staker+withdrawer combination
      const groups = {};
      eligibleStakes.forEach(stake => {
        const key = `${stake.staker}_${stake.withdrawer}`;
        if (!groups[key]) {
          groups[key] = [];
        }
        groups[key].push(stake);
      });
      
      // Mark stakes as mergeable only if they have matching authorities with at least one other stake
      analyzedStakes.forEach(stake => {
        if (stake.eligible) {
          const key = `${stake.staker}_${stake.withdrawer}`;
          if (groups[key] && groups[key].length < 2) {
            stake.eligible = false;
            stake.reason = 'No matching stakes';
          }
        }
      });
      
      container.innerHTML = analyzedStakes.map(stake => `
        <div class="merge-stake-item ${stake.eligible ? '' : 'disabled'}" 
             onclick="${stake.eligible ? `toggleMergeStakeSelection('${stake.pubkey}')` : ''}">
          <input type="checkbox" 
                 class="merge-stake-checkbox" 
                 id="merge-${stake.pubkey}" 
                 ${stake.eligible ? '' : 'disabled'}
                 ${mergeStakesSelected.includes(stake.pubkey) ? 'checked' : ''}
                 onclick="event.stopPropagation(); toggleMergeStakeSelection('${stake.pubkey}')">
          <div class="merge-stake-info">
            <div class="merge-stake-address">${shortenAddress(stake.pubkey)}</div>
            <div class="merge-stake-details">
              <span>Staker: ${shortenAddress(stake.staker || '-')}</span>
              <span>Withdrawer: ${shortenAddress(stake.withdrawer || '-')}</span>
            </div>
          </div>
          <div class="merge-stake-amount">${formatNumber(lamportsToXNT(stake.lamports), 2)} XNT</div>
          <span class="merge-stake-status ${stake.eligible ? 'eligible' : 'ineligible'}">
            ${stake.eligible ? ' Eligible' : stake.reason}
          </span>
        </div>
      `).join('');
    }
    
    function toggleMergeStakeSelection(pubkey) {
      const index = mergeStakesSelected.indexOf(pubkey);
      if (index > -1) {
        mergeStakesSelected.splice(index, 1);
      } else {
        mergeStakesSelected.push(pubkey);
      }
      
      // Update checkbox state
      const checkbox = document.getElementById(`merge-${pubkey}`);
      if (checkbox) {
        checkbox.checked = mergeStakesSelected.includes(pubkey);
      }
      
      // Update item selection state
      const item = checkbox?.closest('.merge-stake-item');
      if (item) {
        item.classList.toggle('selected', mergeStakesSelected.includes(pubkey));
      }
      
      // Update summary and button state
      updateMergeStakesSummary();
    }
    
    function updateMergeStakesSummary() {
      const summarySection = document.getElementById('mergeStakesSummarySection');
      const confirmBtn = document.getElementById('mergeStakesConfirmBtn');
      
      if (mergeStakesSelected.length < 2) {
        summarySection.style.display = 'none';
        confirmBtn.disabled = true;
        return;
      }
      
      // Calculate totals
      const selectedStakes = stakeAccounts.filter(s => mergeStakesSelected.includes(s.pubkey));
      const totalLamports = selectedStakes.reduce((sum, s) => sum + s.lamports, 0);
      
      // Destination is the first selected stake (largest)
      const destination = mergeStakesSelected[0];
      
      document.getElementById('mergeStakesCount').textContent = mergeStakesSelected.length;
      document.getElementById('mergeStakesTotal').textContent = formatNumber(lamportsToXNT(totalLamports), 4) + ' XNT';
      document.getElementById('mergeStakesDestination').textContent = shortenAddress(destination);
      
      summarySection.style.display = 'block';
      confirmBtn.disabled = false;
    }
    
    function showMergeStakesMessage(message, type) {
      const msgEl = document.getElementById('mergeStakesMessage');
      msgEl.textContent = message;
      msgEl.className = 'send-message ' + type;
      msgEl.style.display = 'block';
    }
    
    async function confirmMergeStakes() {
      if (mergeStakesSelected.length < 2) {
        showMergeStakesMessage('Please select at least 2 stakes to merge.', 'error');
        return;
      }
      
      const btn = document.getElementById('mergeStakesConfirmBtn');
      btn.disabled = true;
      btn.textContent = 'Merging Stakes...';
      
      try {
        // The destination stake (first selected) will receive all other stakes
        const destinationPubkey = mergeStakesSelected[0];
        const sourcePubkeys = mergeStakesSelected.slice(1);
        
        // Get Solana web3 classes
        const { PublicKey, Transaction, TransactionInstruction, Connection, SYSVAR_CLOCK_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY } = solanaWeb3;
        
        // Stake program ID
        const STAKE_PROGRAM_ID = new PublicKey('Stake11111111111111111111111111111111111111');
        
        // Create connection
        const connection = new Connection(RPC_URL, 'confirmed');
        
        // Get recent blockhash
        const { blockhash } = await connection.getLatestBlockhash('confirmed');
        
        const fromPubkey = new PublicKey(walletPublicKey);
        const destinationStakePubkey = new PublicKey(destinationPubkey);
        
        // Create a transaction with merge instructions for each source stake
        const transaction = new Transaction();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = fromPubkey;
        
        for (const sourcePubkey of sourcePubkeys) {
          const sourceStakePubkey = new PublicKey(sourcePubkey);
          
          // Create merge instruction manually
          // Merge instruction index is 7 in the Stake program
          const mergeInstructionData = new Uint8Array([7, 0, 0, 0]); // 7 = Merge instruction
          
          const mergeInstruction = new TransactionInstruction({
            keys: [
              { pubkey: destinationStakePubkey, isSigner: false, isWritable: true },
              { pubkey: sourceStakePubkey, isSigner: false, isWritable: true },
              { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
              { pubkey: SYSVAR_STAKE_HISTORY_PUBKEY, isSigner: false, isWritable: false },
              { pubkey: fromPubkey, isSigner: true, isWritable: false }, // stake authority
            ],
            programId: STAKE_PROGRAM_ID,
            data: mergeInstructionData
          });
          
          transaction.add(mergeInstruction);
        }
        
        // Sign and send
        let signature;
        try {
          const result = await connectedWallet.provider.signAndSendTransaction(transaction);
          signature = result.signature || result;
        } catch (signError) {
          // Try fallback signing method
          if (connectedWallet.provider.signTransaction) {
            const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
            const rawTransaction = signedTransaction.serialize();
            signature = await connection.sendRawTransaction(rawTransaction, {
              skipPreflight: false,
              preflightCommitment: 'confirmed'
            });
          } else {
            throw signError;
          }
        }
        
        // Handle signature being an object or string
        let sigString = 'unknown';
        if (signature) {
          if (typeof signature === 'string') {
            sigString = signature;
          } else if (signature.signature) {
            sigString = signature.signature;
          } else {
            sigString = String(signature);
          }
        }
        showMergeStakesMessage(`Stakes merged successfully! Signature: ${sigString.slice(0, 20)}...`, 'success');
        btn.textContent = 'Merge Complete!';
        btn.onclick = closeMergeStakesModal;
        btn.disabled = false;
        document.getElementById('mergeStakesCancelBtn').textContent = 'Close';
        
        // Refresh stake accounts after delay (but don't auto-close modal)
        setTimeout(() => {
          if (currentManageValidator && currentManageValidator.voteAccount) {
            fetchStakeAccounts(currentManageValidator.voteAccount);
          }
        }, 2000);
        
      } catch (e) {
        console.error('Merge stakes error:', e);
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showMergeStakesMessage('Transaction cancelled by user.', 'error');
        } else if (e.message?.includes('Plugin Closed')) {
          showMergeStakesMessage('Wallet closed unexpectedly. Please try again.', 'error');
        } else {
          showMergeStakesMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
        
        btn.disabled = false;
        btn.textContent = 'Merge Selected Stakes';
      }
    }

    // =========================================
    // SPLIT STAKE MODAL
    // =========================================
    
    let splitStakeAccount = null; // Currently selected stake to split
    let splitStakeBalanceLamports = 0;
    const STAKE_RENT_EXEMPT_MIN = 2282880; // ~0.00228 XNT minimum for stake account
    
    function initiateSplitStake() {
      if (!walletPublicKey) {
        showWalletRequired('split stake');
        return;
      }
      
      if (!currentManageValidator) {
        alert('Validator data not available.');
        return;
      }
      
      // Get currently selected stake account
      if (!selectedAccountType || !selectedAccountType.startsWith('stake-')) {
        alert('Please select a stake account to split.');
        return;
      }
      
      const index = parseInt(selectedAccountType.split('-')[1]);
      const stake = stakeAccounts[index];
      
      if (!stake) {
        alert('Stake account not found.');
        return;
      }
      
      // Check if user has authority
      const staker = stake.data.meta?.authorized?.staker;
      if (staker !== walletPublicKey) {
        alert('You must be the stake authority to split this stake.');
        return;
      }
      
      splitStakeAccount = stake;
      splitStakeBalanceLamports = stake.lamports;
      
      // Populate modal
      document.getElementById('splitStakeValidatorName').textContent = currentManageValidator.name;
      document.getElementById('splitStakeAddress').textContent = shortenAddress(stake.pubkey);
      document.getElementById('splitStakeBalance').textContent = formatNumber(lamportsToXNT(stake.lamports), 4);
      document.getElementById('splitStakeAmountInput').value = '';
      document.getElementById('splitStakeRemaining').textContent = formatNumber(lamportsToXNT(stake.lamports), 4) + ' XNT';
      document.getElementById('splitStakeNew').textContent = '0.0000 XNT';
      document.getElementById('splitStakeMessage').style.display = 'none';
      document.getElementById('splitStakeConfirmBtn').disabled = false;
      document.getElementById('splitStakeConfirmBtn').textContent = 'Split Stake';
      document.getElementById('splitStakeConfirmBtn').onclick = confirmSplitStake;
      document.getElementById('splitStakeCancelBtn').textContent = 'Cancel';
      
      // Show modal
      document.getElementById('splitStakeModal').style.display = 'flex';
    }
    
    function closeSplitStakeModal() {
      document.getElementById('splitStakeModal').style.display = 'none';
      splitStakeAccount = null;
      splitStakeBalanceLamports = 0;
    }
    
    function setSplitStakeAmount(percentage) {
      if (splitStakeBalanceLamports <= 0) return;
      
      // Calculate available amount (leaving minimum rent in original)
      const availableLamports = splitStakeBalanceLamports - STAKE_RENT_EXEMPT_MIN - 10000; // Leave rent + small buffer
      const amountLamports = Math.floor(availableLamports * (percentage / 100));
      const amount = lamportsToXNT(amountLamports);
      
      document.getElementById('splitStakeAmountInput').value = amount.toFixed(4);
      updateSplitStakeSummary();
    }
    
    function updateSplitStakeSummary() {
      const input = document.getElementById('splitStakeAmountInput');
      const amount = parseFloat(input.value) || 0;
      const amountLamports = Math.floor(amount * 1e9);
      
      const remainingLamports = splitStakeBalanceLamports - amountLamports;
      
      document.getElementById('splitStakeRemaining').textContent = formatNumber(lamportsToXNT(remainingLamports), 4) + ' XNT';
      document.getElementById('splitStakeNew').textContent = formatNumber(amount, 4) + ' XNT';
      
      // Validate
      const btn = document.getElementById('splitStakeConfirmBtn');
      const msgEl = document.getElementById('splitStakeMessage');
      
      if (amountLamports < STAKE_RENT_EXEMPT_MIN) {
        msgEl.textContent = 'Split amount must be at least ~0.003 XNT for rent-exempt minimum.';
        msgEl.className = 'send-message error';
        msgEl.style.display = 'block';
        btn.disabled = true;
      } else if (remainingLamports < STAKE_RENT_EXEMPT_MIN) {
        msgEl.textContent = 'Original stake must retain at least ~0.003 XNT for rent-exempt minimum.';
        msgEl.className = 'send-message error';
        msgEl.style.display = 'block';
        btn.disabled = true;
      } else {
        msgEl.style.display = 'none';
        btn.disabled = false;
      }
    }
    
    function showSplitStakeMessage(message, type) {
      const msgEl = document.getElementById('splitStakeMessage');
      msgEl.textContent = message;
      msgEl.className = 'send-message ' + type;
      msgEl.style.display = 'block';
    }
    
    async function confirmSplitStake() {
      const amount = parseFloat(document.getElementById('splitStakeAmountInput').value) || 0;
      const amountLamports = Math.floor(amount * 1e9);
      
      if (amountLamports < STAKE_RENT_EXEMPT_MIN) {
        showSplitStakeMessage('Split amount too small.', 'error');
        return;
      }
      
      if (splitStakeBalanceLamports - amountLamports < STAKE_RENT_EXEMPT_MIN) {
        showSplitStakeMessage('Original stake would be too small.', 'error');
        return;
      }
      
      const btn = document.getElementById('splitStakeConfirmBtn');
      btn.disabled = true;
      btn.textContent = 'Splitting Stake...';
      
      try {
        const { PublicKey, Transaction, TransactionInstruction, Keypair, SystemProgram, Connection, StakeProgram } = solanaWeb3;
        
        const STAKE_PROGRAM_ID = new PublicKey('Stake11111111111111111111111111111111111111');
        
        const connection = new Connection(RPC_URL, 'confirmed');
        
        // Use StakeProgram.space (should be 200)
        const stakeAccountSize = StakeProgram.space;
        console.log('StakeProgram.space:', stakeAccountSize);
        
        // Get rent-exempt minimum for a stake account
        const rentExemptMinimum = await connection.getMinimumBalanceForRentExemption(stakeAccountSize);
        console.log('Rent exempt minimum:', rentExemptMinimum);
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
        
        const fromPubkey = new PublicKey(walletPublicKey);
        const stakeAccountPubkey = new PublicKey(splitStakeAccount.pubkey);
        
        // Generate new stake account keypair
        const newStakeKeypair = Keypair.generate();
        
        // Build transaction
        const transaction = new Transaction();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = fromPubkey;
        
        // Instruction 1: Create the new stake account with rent from wallet
        // This does: transfer lamports + allocate space + assign to program - all in one
        const createAccountIx = SystemProgram.createAccount({
          fromPubkey: fromPubkey,
          newAccountPubkey: newStakeKeypair.publicKey,
          lamports: rentExemptMinimum,  // Rent comes from wallet
          space: stakeAccountSize,
          programId: STAKE_PROGRAM_ID
        });
        transaction.add(createAccountIx);
        
        // Instruction 2: Split - transfers stake lamports from source to destination
        // Split instruction format: [3, 0, 0, 0] + u64 lamports (little-endian)
        const splitData = new Uint8Array(12);
        const view = new DataView(splitData.buffer);
        view.setUint32(0, 3, true); // instruction index 3 = Split
        // Write u64 lamports as two u32s (little-endian)
        view.setUint32(4, amountLamports >>> 0, true); // low 32 bits
        view.setUint32(8, Math.floor(amountLamports / 0x100000000), true); // high 32 bits
        
        const splitIx = new TransactionInstruction({
          keys: [
            { pubkey: stakeAccountPubkey, isSigner: false, isWritable: true },
            { pubkey: newStakeKeypair.publicKey, isSigner: false, isWritable: true },
            { pubkey: fromPubkey, isSigner: true, isWritable: false }
          ],
          programId: STAKE_PROGRAM_ID,
          data: splitData
        });
        transaction.add(splitIx);
        
        // Sign with new stake account keypair (required for createAccount)
        transaction.partialSign(newStakeKeypair);
        
        // Sign and send with wallet
        let signature;
        try {
          const result = await connectedWallet.provider.signAndSendTransaction(transaction);
          signature = result.signature || result;
        } catch (signError) {
          // Try fallback signing method
          if (connectedWallet.provider.signTransaction) {
            const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
            const rawTransaction = signedTransaction.serialize();
            signature = await connection.sendRawTransaction(rawTransaction, {
              skipPreflight: false,
              preflightCommitment: 'confirmed'
            });
          } else {
            throw signError;
          }
        }
        
        showSplitStakeMessage(`Stake split successfully! New account: ${shortenAddress(newStakeKeypair.publicKey.toString())}`, 'success');
        btn.textContent = 'Split Complete!';
        btn.onclick = closeSplitStakeModal;
        btn.disabled = false;
        document.getElementById('splitStakeCancelBtn').textContent = 'Close';
        
        // Refresh stake accounts after delay (but don't auto-close modal)
        setTimeout(() => {
          if (currentManageValidator && currentManageValidator.voteAccount) {
            fetchStakeAccounts(currentManageValidator.voteAccount);
          }
        }, 2000);
        
      } catch (e) {
        console.error('Split stake error:', e);
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showSplitStakeMessage('Transaction cancelled by user.', 'error');
        } else if (e.message?.includes('Plugin Closed')) {
          showSplitStakeMessage('Wallet closed unexpectedly. Please try again.', 'error');
        } else {
          showSplitStakeMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
        
        btn.disabled = false;
        btn.textContent = 'Split Stake';
      }
    }

    // Stake account action stubs
    // Undelegate Stake state
    let undelegateStakeData = null;

    function initiateUndelegate() {
      if (!walletPublicKey) {
        showWalletRequired('undelegate stake');
        return;
      }
      
      // Get the selected stake account
      if (!selectedAccountType || !selectedAccountType.startsWith('stake-')) {
        alert('Please select a stake account first.');
        return;
      }
      
      const stakeIndex = parseInt(selectedAccountType.replace('stake-', ''));
      const stake = stakeAccounts[stakeIndex];
      
      if (!stake) {
        alert('Stake account not found.');
        return;
      }
      
      undelegateStakeData = stake;
      
      // Get stake authority
      const staker = stake.data.meta?.authorized?.staker;
      const hasStakeAuthority = staker && staker === walletPublicKey;
      
      // Get staked amount
      const stakedLamports = stake.data.stake?.delegation?.stake ? parseInt(stake.data.stake.delegation.stake) : 0;
      
      // Populate modal
      document.getElementById('undelegateStakeAddress').textContent = shortenAddress(stake.pubkey);
      document.getElementById('undelegateStakeAddressCopyBtn').innerHTML = getCopyButtonHtml(stake.pubkey);
      document.getElementById('undelegateValidatorName').textContent = currentManageValidator?.name || 'Unknown';
      document.getElementById('undelegateVoteAccount').textContent = shortenAddress(currentManageValidator?.voteAccount || '');
      document.getElementById('undelegateStakeAmount').textContent = formatNumber(stakedLamports / 1e9, 4);
      
      // Check authority and state
      const authorityWarning = document.getElementById('undelegateAuthorityWarning');
      const alreadyWarning = document.getElementById('undelegateAlreadyWarning');
      const confirmBtn = document.getElementById('undelegateConfirmBtn');
      
      // Hide all warnings initially
      authorityWarning.style.display = 'none';
      alreadyWarning.style.display = 'none';
      
      // Check if already deactivating or inactive
      const isActive = stake.state === 'active' || stake.state === 'activating';
      
      if (!hasStakeAuthority) {
        authorityWarning.style.display = 'flex';
        confirmBtn.disabled = true;
      } else if (!isActive) {
        alreadyWarning.style.display = 'flex';
        confirmBtn.disabled = true;
      } else {
        confirmBtn.disabled = false;
      }
      
      // Reset message
      document.getElementById('undelegateMessage').style.display = 'none';
      confirmBtn.textContent = 'Undelegate Stake';
      confirmBtn.onclick = confirmUndelegateStake;
      document.getElementById('undelegateCancelBtn').textContent = 'Cancel';
      
      // Show modal
      document.getElementById('undelegateStakeModal').style.display = 'flex';
    }

    function closeUndelegateStakeModal() {
      document.getElementById('undelegateStakeModal').style.display = 'none';
      undelegateStakeData = null;
    }

    function showUndelegateMessage(message, type) {
      const msgEl = document.getElementById('undelegateMessage');
      msgEl.textContent = message;
      msgEl.className = 'send-message ' + type;
      msgEl.style.display = 'block';
    }

    async function confirmUndelegateStake() {
      if (!undelegateStakeData || !walletPublicKey) return;
      
      const btn = document.getElementById('undelegateConfirmBtn');
      btn.disabled = true;
      btn.textContent = 'Processing...';
      
      try {
        const { PublicKey, StakeProgram, Transaction, Connection } = solanaWeb3;
        const connection = new Connection(RPC_URL, 'confirmed');
        
        const stakePubkey = new PublicKey(undelegateStakeData.pubkey);
        const authorizedPubkey = new PublicKey(walletPublicKey);
        
        // Create deactivate instruction
        const deactivateInstruction = StakeProgram.deactivate({
          stakePubkey: stakePubkey,
          authorizedPubkey: authorizedPubkey
        });
        
        const transaction = new Transaction().add(deactivateInstruction);
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = authorizedPubkey;
        
        btn.textContent = 'Sign Transaction...';
        showUndelegateMessage('Please approve the transaction in your wallet...', 'info');
        
        // Sign and send
        let signature;
        try {
          const signed = await connectedWallet.provider.signTransaction(transaction);
          signature = await connection.sendRawTransaction(signed.serialize(), {
            skipPreflight: false,
            preflightCommitment: 'confirmed'
          });
        } catch (signError) {
          if (signError.message?.includes('User rejected')) {
            throw new Error('Transaction cancelled by user.');
          }
          // Try alternative signing
          if (connectedWallet.provider.signAndSendTransaction) {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } else {
            throw signError;
          }
        }
        
        btn.textContent = 'Confirming...';
        showUndelegateMessage('Transaction sent! Waiting for confirmation...', 'info');
        
        const confirmation = await connection.confirmTransaction({
          signature,
          blockhash,
          lastValidBlockHeight
        }, 'confirmed');
        
        if (confirmation.value.err) {
          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
        }
        
        btn.textContent = 'Success!';
        btn.onclick = closeUndelegateStakeModal;
        btn.disabled = false;
        document.getElementById('undelegateCancelBtn').textContent = 'Close';
        showUndelegateMessage(`Stake undelegated! It will enter "Deactivating" state. Signature: ${signature.slice(0, 20)}...`, 'success');
        
        // Remember current selection
        const currentSelection = selectedAccountType;
        
        // Refresh stake accounts and re-select (but don't auto-close modal)
        setTimeout(async () => {
          if (currentManageValidator && currentManageValidator.voteAccount) {
            await fetchStakeAccounts(currentManageValidator.voteAccount);
            setTimeout(() => {
              if (currentSelection && currentSelection.startsWith('stake-')) {
                selectAccount(currentSelection);
              }
            }, 200);
          }
        }, 2000);
        
      } catch (e) {
        console.error('Undelegate stake error:', e);
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showUndelegateMessage('Transaction cancelled by user.', 'error');
        } else if (e.message?.includes('already deactivated')) {
          showUndelegateMessage('This stake is already deactivated.', 'error');
        } else {
          showUndelegateMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
        
        btn.disabled = false;
        btn.textContent = 'Undelegate Stake';
      }
    }

    // Redelegate Stake state
    let redelegateStakeData = null;
    let redelegateNewVoteAccount = null;
    let redelegateNewValidatorName = null;
    let allValidatorsForRedelegate = [];

    async function initiateRedelegate() {
      if (!walletPublicKey) {
        showWalletRequired('delegate stake');
        return;
      }
      
      // Get the selected stake account
      if (!selectedAccountType || !selectedAccountType.startsWith('stake-')) {
        alert('Please select a stake account first.');
        return;
      }
      
      const stakeIndex = parseInt(selectedAccountType.replace('stake-', ''));
      const stake = stakeAccounts[stakeIndex];
      
      if (!stake) {
        alert('Stake account not found.');
        return;
      }
      
      redelegateStakeData = stake;
      redelegateNewVoteAccount = null;
      redelegateNewValidatorName = null;
      
      // Get stake authority
      const staker = stake.data.meta?.authorized?.staker;
      const hasStakeAuthority = staker && staker === walletPublicKey;
      
      // Get staked amount
      const stakedLamports = stake.data.stake?.delegation?.stake ? parseInt(stake.data.stake.delegation.stake) : 0;
      
      // Populate modal
      document.getElementById('redelegateStakeAddress').textContent = shortenAddress(stake.pubkey);
      document.getElementById('redelegateStakeAddressCopyBtn').innerHTML = getCopyButtonHtml(stake.pubkey);
      document.getElementById('redelegateCurrentValidator').textContent = currentManageValidator?.name || 'Unknown';
      document.getElementById('redelegateCurrentVoteAccount').textContent = shortenAddress(currentManageValidator?.voteAccount || '');
      document.getElementById('redelegateStakeAmount').textContent = formatNumber(stakedLamports / 1e9, 4);
      
      // Reset search and selection
      document.getElementById('redelegateValidatorSearch').value = '';
      document.getElementById('redelegateSearchResults').style.display = 'none';
      document.getElementById('redelegateNewValidatorBox').style.display = 'none';
      
      // Check authority and state
      const authorityWarning = document.getElementById('redelegateAuthorityWarning');
      const notActiveWarning = document.getElementById('redelegateNotActiveWarning');
      const confirmBtn = document.getElementById('redelegateConfirmBtn');
      
      // Hide all warnings initially
      authorityWarning.style.display = 'none';
      notActiveWarning.style.display = 'none';
      
      // Check if active
      const isActive = stake.state === 'active';
      const isInactive = stake.state === 'inactive';
      const isTransitioning = stake.state === 'activating' || stake.state === 'deactivating';
      
      if (!hasStakeAuthority) {
        authorityWarning.style.display = 'flex';
        confirmBtn.disabled = true;
      } else if (isTransitioning) {
        // Activating or deactivating - can't redelegate
        notActiveWarning.style.display = 'flex';
        document.querySelector('#redelegateNotActiveWarning .warning-text p').textContent = 
          `This stake account is currently "${stake.state}". Wait for it to become active or inactive before redelegating.`;
        confirmBtn.disabled = true;
      } else if (!isInactive) {
        // Active (or any non-inactive state) - show warning that undelegate is needed
        confirmBtn.disabled = true; // Will enable when validator selected
      } else {
        // Inactive stake - can redelegate directly
        confirmBtn.disabled = true; // Will enable when validator selected
      }
      
      // Update "What happens" section based on stake state
      const timeline = document.getElementById('redelegateTimeline');
      const note = document.getElementById('redelegateNote');
      
      if (!isInactive) {
        // Any non-inactive stake - requires manual process
        timeline.innerHTML = `
          <div class="timeline-step">
            <div class="timeline-icon">1</div>
            <div class="timeline-text">
              <strong>First:</strong> Undelegate from current validator (this action)
            </div>
          </div>
          <div class="timeline-step">
            <div class="timeline-icon">2</div>
            <div class="timeline-text">
              <strong>Wait:</strong> Cooldown period (~1 epoch)
            </div>
          </div>
          <div class="timeline-step">
            <div class="timeline-icon">3</div>
            <div class="timeline-text">
              <strong>Then:</strong> Delegate to new validator
            </div>
          </div>
        `;
        note.innerHTML = ' Active stakes cannot be directly redelegated. You must undelegate first.';
        note.style.color = '#ff9800';
      } else if (isInactive) {
        // Inactive stake - can redelegate directly
        timeline.innerHTML = `
          <div class="timeline-step">
            <div class="timeline-icon">1</div>
            <div class="timeline-text">
              <strong>Immediately:</strong> Stake delegation changes to new validator
            </div>
          </div>
          <div class="timeline-step">
            <div class="timeline-icon">2</div>
            <div class="timeline-text">
              <strong>End of epoch:</strong> Stake becomes active on new validator
            </div>
          </div>
        `;
        note.innerHTML = ' This stake is inactive and can be directly delegated to a new validator.';
        note.style.color = 'var(--success)';
      }
      
      // Reset message
      document.getElementById('redelegateMessage').style.display = 'none';
      
      // Set appropriate button text based on stake state
      if (!isInactive) {
        confirmBtn.textContent = 'Undelegate First...';
      } else {
        confirmBtn.textContent = 'Redelegate Stake';
      }
      
      // Restore onclick handler (might have been changed)
      confirmBtn.onclick = confirmRedelegateStake;
      document.getElementById('redelegateCancelBtn').textContent = 'Cancel';
      
      // Show modal first with loading state
      document.getElementById('redelegateStakeModal').style.display = 'flex';
      
      // Load validators list for search (await to ensure it's ready)
      await loadValidatorsForRedelegate();
    }

    function closeRedelegateStakeModal() {
      document.getElementById('redelegateStakeModal').style.display = 'none';
      redelegateStakeData = null;
      redelegateNewVoteAccount = null;
      redelegateNewValidatorName = null;
    }

    async function loadValidatorsForRedelegate() {
      // Use existing allValidators if available and has data
      if (allValidators && allValidators.length > 0) {
        allValidatorsForRedelegate = allValidators
          .filter(v => v.votePubkey && v.votePubkey !== currentManageValidator?.voteAccount) // Exclude current validator and invalid entries
          .map(v => ({
            voteAccount: v.votePubkey, // Note: allValidators uses votePubkey
            nodePubkey: v.nodePubkey,
            activatedStake: v.activatedStake / 1e9, // Convert from lamports
            commission: v.commission,
            name: v.name || shortenAddress(v.votePubkey),
            isDelinquent: v.delinquent
          }));
        return;
      }
      
      // Fetch fresh validators
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getVoteAccounts',
            params: [{ commitment: 'confirmed' }]
          })
        });
        
        const data = await response.json();
        
        if (data.result) {
          // Also try to get validator names from existing identities
          const identities = await fetchValidatorIdentitiesForRedelegate([
            ...data.result.current.map(v => v.nodePubkey),
            ...data.result.delinquent.map(v => v.nodePubkey)
          ].slice(0, 100)); // Limit to first 100 for performance
          
          allValidatorsForRedelegate = [
            ...data.result.current.filter(v => v.votePubkey).map(v => ({
              voteAccount: v.votePubkey,
              nodePubkey: v.nodePubkey,
              activatedStake: v.activatedStake / 1e9,
              commission: v.commission,
              name: identities[v.nodePubkey] || identities[v.votePubkey] || shortenAddress(v.votePubkey)
            })),
            ...data.result.delinquent.filter(v => v.votePubkey).map(v => ({
              voteAccount: v.votePubkey,
              nodePubkey: v.nodePubkey,
              activatedStake: v.activatedStake / 1e9,
              commission: v.commission,
              name: identities[v.nodePubkey] || identities[v.votePubkey] || shortenAddress(v.votePubkey),
              isDelinquent: true
            }))
          ].filter(v => v.voteAccount && v.voteAccount !== currentManageValidator?.voteAccount);
        }
      } catch (e) {
        console.error('Error loading validators for redelegate:', e);
      }
    }
    
    async function fetchValidatorIdentitiesForRedelegate(nodePubkeys) {
      const identities = {};
      try {
        // Try to get from localStorage cache first
        const cached = localStorage.getItem('validatorIdentitiesCache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          // Use cache if less than 1 hour old
          if (Date.now() - timestamp < 3600000) {
            return data;
          }
        }
      } catch (e) {
        console.warn('Could not load identities cache');
      }
      return identities;
    }

    function handleRedelegateSearch() {
      const searchInput = document.getElementById('redelegateValidatorSearch');
      const resultsContainer = document.getElementById('redelegateSearchResults');
      const query = searchInput.value.trim().toLowerCase();
      
      if (query.length < 2) {
        resultsContainer.style.display = 'none';
        return;
      }
      
      const matches = allValidatorsForRedelegate.filter(v => 
        v.voteAccount && // Must have valid voteAccount
        (
          (v.name && v.name.toLowerCase().includes(query)) || 
          v.voteAccount.toLowerCase().includes(query) ||
          (v.nodePubkey && v.nodePubkey.toLowerCase().includes(query))
        )
      ).slice(0, 10); // Limit to 10 results
      
      if (matches.length === 0) {
        resultsContainer.innerHTML = '<div class="redelegate-no-results">No validators found</div>';
        resultsContainer.style.display = 'block';
        return;
      }
      
      resultsContainer.innerHTML = matches.map(v => `
        <div class="redelegate-search-item" onclick="selectRedelegateValidator('${v.voteAccount}', '${(v.name || shortenAddress(v.voteAccount)).replace(/'/g, "\\'")}')">
          <div>
            <div class="redelegate-search-item-name">${v.name || shortenAddress(v.voteAccount)}${v.isDelinquent ? ' ' : ''}</div>
            <div class="redelegate-search-item-address">${shortenAddress(v.voteAccount)}</div>
          </div>
          <div class="redelegate-search-item-stake">${formatCompact(v.activatedStake)} XNT</div>
        </div>
      `).join('');
      
      resultsContainer.style.display = 'block';
    }

    function selectRedelegateValidator(voteAccount, name) {
      // Validate voteAccount
      if (!voteAccount || voteAccount === 'undefined') {
        showRedelegateMessage('Invalid validator selected. Please try another.', 'error');
        return;
      }
      
      redelegateNewVoteAccount = voteAccount;
      redelegateNewValidatorName = name;
      
      // Hide search, show selection
      document.getElementById('redelegateValidatorSearch').value = '';
      document.getElementById('redelegateSearchResults').style.display = 'none';
      document.getElementById('redelegateNewValidatorBox').style.display = 'block';
      document.getElementById('redelegateNewValidator').textContent = name;
      document.getElementById('redelegateNewVoteAccount').textContent = shortenAddress(voteAccount);
      
      // Enable confirm button only for inactive stakes with authority
      // Active stakes will redirect to undelegate when clicked
      const staker = redelegateStakeData?.data.meta?.authorized?.staker;
      const hasStakeAuthority = staker && staker === walletPublicKey;
      const isInactive = redelegateStakeData?.state === 'inactive';
      const canProceed = redelegateStakeData?.state && !['activating', 'deactivating'].includes(redelegateStakeData.state);
      
      document.getElementById('redelegateConfirmBtn').disabled = !(hasStakeAuthority && canProceed && voteAccount);
    }

    function clearRedelegateSelection() {
      redelegateNewVoteAccount = null;
      redelegateNewValidatorName = null;
      
      document.getElementById('redelegateNewValidatorBox').style.display = 'none';
      document.getElementById('redelegateConfirmBtn').disabled = true;
    }

    function showRedelegateMessage(message, type) {
      const msgEl = document.getElementById('redelegateMessage');
      msgEl.textContent = message;
      msgEl.className = 'send-message ' + type;
      msgEl.style.display = 'block';
    }

    async function confirmRedelegateStake() {
      if (!redelegateStakeData || !walletPublicKey || !redelegateNewVoteAccount) return;
      
      const btn = document.getElementById('redelegateConfirmBtn');
      
      // If stake is NOT inactive (meaning it's active, activating, or deactivating), redirect to undelegate
      // Only inactive stakes can be directly redelegated
      const stakeState = redelegateStakeData.state;
      
      if (stakeState !== 'inactive') {
        closeRedelegateStakeModal();
        initiateUndelegate();
        return;
      }
      
      btn.disabled = true;
      btn.textContent = 'Processing...';
      
      try {
        const { PublicKey, StakeProgram, Transaction, Connection, Keypair } = solanaWeb3;
        const connection = new Connection(RPC_URL, 'confirmed');
        
        const stakePubkey = new PublicKey(redelegateStakeData.pubkey);
        const authorizedPubkey = new PublicKey(walletPublicKey);
        const newVotePubkey = new PublicKey(redelegateNewVoteAccount);
        
        // Stake is inactive, we can delegate directly
        const delegateInstruction = StakeProgram.delegate({
          stakePubkey: stakePubkey,
          authorizedPubkey: authorizedPubkey,
          votePubkey: newVotePubkey
        });
        
        const transaction = new Transaction().add(delegateInstruction);
        
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = authorizedPubkey;
        
        btn.textContent = 'Sign Transaction...';
        showRedelegateMessage('Please approve the transaction in your wallet...', 'info');
        
        let signature;
        try {
          const signed = await connectedWallet.provider.signTransaction(transaction);
          signature = await connection.sendRawTransaction(signed.serialize(), {
            skipPreflight: false,
            preflightCommitment: 'confirmed'
          });
        } catch (signError) {
          if (signError.message?.includes('User rejected')) {
            throw new Error('Transaction cancelled by user.');
          }
          if (connectedWallet.provider.signAndSendTransaction) {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } else {
            throw signError;
          }
        }
        
        btn.textContent = 'Confirming...';
        showRedelegateMessage('Transaction sent! Waiting for confirmation...', 'info');
        
        const confirmation = await connection.confirmTransaction({
          signature,
          blockhash,
          lastValidBlockHeight
        }, 'confirmed');
        
        if (confirmation.value.err) {
          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
        }
        
        btn.textContent = 'Success!';
        btn.onclick = closeRedelegateStakeModal;
        btn.disabled = false;
        document.getElementById('redelegateCancelBtn').textContent = 'Close';
        showRedelegateMessage(`Stake delegated to ${redelegateNewValidatorName}! Signature: ${signature.slice(0, 20)}...`, 'success');
        
        // Refresh stake accounts in background (but don't auto-close modal)
        setTimeout(async () => {
          if (currentManageValidator && currentManageValidator.voteAccount) {
            await fetchStakeAccounts(currentManageValidator.voteAccount);
          }
        }, 2000);
        
      } catch (e) {
        console.error('Redelegate stake error:', e);
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showRedelegateMessage('Transaction cancelled by user.', 'error');
        } else {
          showRedelegateMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
        
        btn.disabled = false;
        btn.textContent = 'Redelegate Stake';
      }
    }

    // Withdraw from Stake state
    let withdrawStakeData = null;
    let withdrawStakeAvailableLamports = 0;

    function initiateWithdrawStake() {
      if (!walletPublicKey) {
        showWalletRequired('withdraw from stake');
        return;
      }
      
      // Get the selected stake account
      if (!selectedAccountType || !selectedAccountType.startsWith('stake-')) {
        alert('Please select a stake account first.');
        return;
      }
      
      const stakeIndex = parseInt(selectedAccountType.replace('stake-', ''));
      const stake = stakeAccounts[stakeIndex];
      
      if (!stake) {
        alert('Stake account not found.');
        return;
      }
      
      withdrawStakeData = stake;
      
      // Get balances
      // For inactive stakes, all funds are liquid (withdrawable)
      const totalLamports = stake.lamports;
      let stakedLamports, liquidLamports;
      
      if (stake.state === 'inactive') {
        // Inactive stakes have no active delegation - all funds are liquid
        stakedLamports = 0;
        liquidLamports = totalLamports;
      } else {
        // Active, activating, or deactivating stakes have delegated funds
        stakedLamports = stake.data.stake?.delegation?.stake ? parseInt(stake.data.stake.delegation.stake) : 0;
        liquidLamports = totalLamports - stakedLamports;
      }
      
      // Account for rent-exempt minimum (~0.00228 SOL for stake accounts)
      const rentExemptLamports = 2282880;
      const actualAvailable = Math.max(0, liquidLamports - rentExemptLamports);
      withdrawStakeAvailableLamports = actualAvailable;
      
      // Populate modal
      document.getElementById('withdrawStakeAddress').textContent = shortenAddress(stake.pubkey);
      document.getElementById('withdrawStakeAddressCopyBtn').innerHTML = getCopyButtonHtml(stake.pubkey);
      
      // Status badge
      const statusBadge = document.getElementById('withdrawStakeStatus');
      const statusNote = document.getElementById('withdrawStakeStatusNote');
      statusBadge.textContent = stake.state.charAt(0).toUpperCase() + stake.state.slice(1);
      statusBadge.className = 'status-badge';
      
      if (stake.state === 'active') {
        statusBadge.classList.add('status-active');
        statusNote.textContent = '- Stake is delegated and earning rewards';
      } else if (stake.state === 'deactivating') {
        statusBadge.classList.add('status-delinquent');
        statusNote.textContent = '- Stake is deactivating, wait for cooldown';
      } else if (stake.state === 'inactive') {
        statusBadge.classList.add('status-active');
        statusBadge.style.background = 'rgba(0, 230, 118, 0.15)';
        statusNote.textContent = '- Fully deactivated, ready to withdraw';
      } else if (stake.state === 'activating') {
        statusBadge.style.background = 'rgba(0, 229, 255, 0.15)';
        statusBadge.style.color = 'var(--accent-cyan)';
        statusNote.textContent = '- Stake is activating';
      }
      
      // Balance breakdown
      document.getElementById('withdrawStakeTotalBalance').textContent = formatNumber(totalLamports / 1e9, 4) + ' XNT';
      document.getElementById('withdrawStakeLockedBalance').textContent = formatNumber(stakedLamports / 1e9, 4) + ' XNT';
      document.getElementById('withdrawStakeAvailableBalance').textContent = formatNumber(actualAvailable / 1e9, 4) + ' XNT';
      
      // Get withdraw authority
      const withdrawer = stake.data.meta?.authorized?.withdrawer;
      const hasWithdrawAuthority = withdrawer && withdrawer === walletPublicKey;
      
      // Set default destination to withdraw authority
      document.getElementById('withdrawStakeDestInput').value = withdrawer || '';
      
      // Check authority
      const authorityWarning = document.getElementById('withdrawStakeAuthorityWarning');
      const noBalanceWarning = document.getElementById('withdrawStakeNoBalanceWarning');
      const amountSection = document.getElementById('withdrawStakeAmountSection');
      const destSection = document.getElementById('withdrawStakeDestSection');
      const summarySection = document.getElementById('withdrawStakeSummarySection');
      const confirmBtn = document.getElementById('withdrawStakeConfirmBtn');
      
      // Hide all warnings initially
      authorityWarning.style.display = 'none';
      noBalanceWarning.style.display = 'none';
      
      if (!hasWithdrawAuthority) {
        authorityWarning.style.display = 'flex';
        amountSection.style.opacity = '0.5';
        destSection.style.opacity = '0.5';
        summarySection.style.opacity = '0.5';
        confirmBtn.disabled = true;
      } else if (actualAvailable <= 0) {
        noBalanceWarning.style.display = 'flex';
        amountSection.style.opacity = '0.5';
        destSection.style.opacity = '0.5';
        summarySection.style.opacity = '0.5';
        confirmBtn.disabled = true;
      } else {
        amountSection.style.opacity = '1';
        destSection.style.opacity = '1';
        summarySection.style.opacity = '1';
        confirmBtn.disabled = false;
      }
      
      // Reset form
      document.getElementById('withdrawStakeAmountInput').value = '';
      document.getElementById('withdrawStakeSummaryAmount').textContent = '0.0000 XNT';
      document.getElementById('withdrawStakeSummaryTotal').textContent = '0.0000 XNT';
      document.getElementById('withdrawStakeMessage').style.display = 'none';
      confirmBtn.textContent = 'Withdraw XNT';
      confirmBtn.onclick = confirmWithdrawFromStake;
      document.getElementById('withdrawStakeCancelBtn').textContent = 'Cancel';
      
      // Show close account option only for inactive stakes with authority
      const closeSection = document.getElementById('withdrawStakeCloseSection');
      const closeCheckbox = document.getElementById('withdrawStakeCloseCheckbox');
      closeCheckbox.checked = false;
      
      if (stake.state === 'inactive' && hasWithdrawAuthority) {
        closeSection.style.display = 'block';
      } else {
        closeSection.style.display = 'none';
      }
      
      // Add input listener
      const amountInput = document.getElementById('withdrawStakeAmountInput');
      amountInput.oninput = updateWithdrawStakeSummary;
      
      // Show modal
      document.getElementById('withdrawStakeModal').style.display = 'flex';
    }

    function closeWithdrawStakeModal() {
      document.getElementById('withdrawStakeModal').style.display = 'none';
      withdrawStakeData = null;
    }

    function setWithdrawStakeAmount(percent) {
      // Don't change amount if closing account
      if (document.getElementById('withdrawStakeCloseCheckbox')?.checked) return;
      
      const maxXnt = withdrawStakeAvailableLamports / 1e9;
      const amount = (maxXnt * percent / 100).toFixed(4);
      document.getElementById('withdrawStakeAmountInput').value = amount;
      updateWithdrawStakeSummary();
    }

    function updateWithdrawStakeSummary() {
      // Don't update if closing account (handled by toggle function)
      if (document.getElementById('withdrawStakeCloseCheckbox')?.checked) return;
      
      const amount = parseFloat(document.getElementById('withdrawStakeAmountInput').value) || 0;
      const maxXnt = withdrawStakeAvailableLamports / 1e9;
      
      // Clamp to max
      const finalAmount = Math.min(amount, maxXnt);
      
      document.getElementById('withdrawStakeSummaryAmount').textContent = formatNumber(finalAmount, 4) + ' XNT';
      document.getElementById('withdrawStakeSummaryTotal').textContent = formatNumber(finalAmount - 0.000005, 4) + ' XNT';
      
      // Enable/disable button based on amount
      const btn = document.getElementById('withdrawStakeConfirmBtn');
      const hasAuthority = withdrawStakeData?.data?.meta?.authorized?.withdrawer === walletPublicKey;
      btn.disabled = !hasAuthority || finalAmount <= 0 || withdrawStakeAvailableLamports <= 0;
    }

    function showWithdrawStakeMessage(message, type) {
      const msgEl = document.getElementById('withdrawStakeMessage');
      msgEl.textContent = message;
      msgEl.className = 'send-message ' + type;
      msgEl.style.display = 'block';
    }

    async function confirmWithdrawFromStake() {
      if (!withdrawStakeData || !walletPublicKey) return;
      
      const btn = document.getElementById('withdrawStakeConfirmBtn');
      btn.disabled = true;
      btn.textContent = 'Processing...';
      
      // Check if closing account
      const isClosingAccount = document.getElementById('withdrawStakeCloseCheckbox')?.checked;
      
      try {
        let amountLamports;
        let amountXnt;
        
        if (isClosingAccount) {
          // Withdraw full balance including rent to close the account
          amountLamports = withdrawStakeData.lamports;
          amountXnt = amountLamports / 1e9;
        } else {
          amountXnt = parseFloat(document.getElementById('withdrawStakeAmountInput').value) || 0;
          
          if (amountXnt <= 0) {
            throw new Error('Please enter an amount to withdraw.');
          }
          
          amountLamports = Math.floor(amountXnt * 1e9);
          
          if (amountLamports > withdrawStakeAvailableLamports) {
            throw new Error('Amount exceeds available balance.');
          }
        }
        
        const destination = document.getElementById('withdrawStakeDestInput').value.trim();
        
        if (!destination || destination.length < 32) {
          throw new Error('Please enter a valid destination address.');
        }
        
        const { PublicKey, StakeProgram, Transaction, Connection } = solanaWeb3;
        const connection = new Connection(RPC_URL, 'confirmed');
        
        const stakePubkey = new PublicKey(withdrawStakeData.pubkey);
        const authorizedPubkey = new PublicKey(walletPublicKey);
        const toPubkey = new PublicKey(destination);
        
        // Create withdraw instruction
        const withdrawInstruction = StakeProgram.withdraw({
          stakePubkey: stakePubkey,
          authorizedPubkey: authorizedPubkey,
          toPubkey: toPubkey,
          lamports: amountLamports
        });
        
        const transaction = new Transaction().add(withdrawInstruction);
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = authorizedPubkey;
        
        btn.textContent = 'Sign Transaction...';
        showWithdrawStakeMessage('Please approve the transaction in your wallet...', 'info');
        
        // Sign and send
        let signature;
        try {
          const signed = await connectedWallet.provider.signTransaction(transaction);
          signature = await connection.sendRawTransaction(signed.serialize(), {
            skipPreflight: false,
            preflightCommitment: 'confirmed'
          });
        } catch (signError) {
          if (signError.message?.includes('User rejected')) {
            throw new Error('Transaction cancelled by user.');
          }
          // Try alternative signing
          if (connectedWallet.provider.signAndSendTransaction) {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } else {
            throw signError;
          }
        }
        
        btn.textContent = 'Confirming...';
        showWithdrawStakeMessage('Transaction sent! Waiting for confirmation...', 'info');
        
        const confirmation = await connection.confirmTransaction({
          signature,
          blockhash,
          lastValidBlockHeight
        }, 'confirmed');
        
        if (confirmation.value.err) {
          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
        }
        
        btn.textContent = 'Success!';
        btn.onclick = closeWithdrawStakeModal;
        btn.disabled = false;
        document.getElementById('withdrawStakeCancelBtn').textContent = 'Close';
        if (isClosingAccount) {
          showWithdrawStakeMessage(`Account closed! Withdrew ${formatNumber(amountXnt, 4)} XNT. Signature: ${signature.slice(0, 20)}...`, 'success');
        } else {
          showWithdrawStakeMessage(`Withdrew ${formatNumber(amountXnt, 4)} XNT! Signature: ${signature.slice(0, 20)}...`, 'success');
        }
        
        // Remember current selection
        const currentSelection = selectedAccountType;
        
        // Refresh stake accounts and re-select (but don't auto-close modal)
        setTimeout(async () => {
          if (currentManageValidator && currentManageValidator.voteAccount) {
            await fetchStakeAccounts(currentManageValidator.voteAccount);
            setTimeout(() => {
              // If we closed the account, select vote account instead
              if (isClosingAccount) {
                selectAccount('vote');
              } else if (currentSelection && currentSelection.startsWith('stake-')) {
                selectAccount(currentSelection);
              }
            }, 200);
          }
        }, 2000);
        
      } catch (e) {
        console.error('Withdraw from stake error:', e);
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showWithdrawStakeMessage('Transaction cancelled by user.', 'error');
        } else if (e.message?.includes('insufficient')) {
          showWithdrawStakeMessage('Insufficient balance for this withdrawal.', 'error');
        } else {
          showWithdrawStakeMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
        
        btn.disabled = false;
        btn.textContent = isClosingAccount ? 'Close & Withdraw All' : 'Withdraw XNT';
      }
    }

    // Toggle close account checkbox behavior
    function toggleCloseStakeAccount() {
      const isClosing = document.getElementById('withdrawStakeCloseCheckbox').checked;
      const amountSection = document.getElementById('withdrawStakeAmountSection');
      const amountInput = document.getElementById('withdrawStakeAmountInput');
      const btn = document.getElementById('withdrawStakeConfirmBtn');
      
      if (isClosing) {
        // Disable amount input, auto-fill with full balance
        amountSection.style.opacity = '0.5';
        amountInput.disabled = true;
        const fullAmount = withdrawStakeData.lamports / 1e9;
        amountInput.value = formatNumber(fullAmount, 4);
        document.getElementById('withdrawStakeSummaryAmount').textContent = formatNumber(fullAmount, 4) + ' XNT';
        document.getElementById('withdrawStakeSummaryTotal').textContent = formatNumber(fullAmount - 0.000005, 4) + ' XNT';
        btn.textContent = 'Close & Withdraw All';
        btn.disabled = false;
      } else {
        // Re-enable amount input
        amountSection.style.opacity = '1';
        amountInput.disabled = false;
        amountInput.value = '';
        document.getElementById('withdrawStakeSummaryAmount').textContent = '0.0000 XNT';
        document.getElementById('withdrawStakeSummaryTotal').textContent = '0.0000 XNT';
        btn.textContent = 'Withdraw XNT';
        btn.disabled = true; // Will enable when they enter an amount
      }
    }

    // Direct close stake account action
    function initiateCloseStakeAccount() {
      if (!walletPublicKey) {
        showWalletRequired('close stake account');
        return;
      }
      
      // Get the selected stake account
      if (!selectedAccountType || !selectedAccountType.startsWith('stake-')) {
        alert('Please select a stake account first.');
        return;
      }
      
      const stakeIndex = parseInt(selectedAccountType.replace('stake-', ''));
      const stake = stakeAccounts[stakeIndex];
      
      if (!stake) {
        alert('Stake account not found.');
        return;
      }
      
      // Check if stake is inactive
      if (stake.state !== 'inactive') {
        alert(`This stake account is "${stake.state}". You can only close inactive stake accounts.\n\nPlease undelegate first and wait for the cooldown period to complete.`);
        return;
      }
      
      // Check authority
      const withdrawer = stake.data.meta?.authorized?.withdrawer;
      if (withdrawer !== walletPublicKey) {
        alert('You do not have withdraw authority for this stake account.');
        return;
      }
      
      // Open withdraw modal with close checkbox pre-checked
      initiateWithdrawStake();
      
      // Pre-check the close checkbox after a brief delay for modal to render
      setTimeout(() => {
        const closeCheckbox = document.getElementById('withdrawStakeCloseCheckbox');
        if (closeCheckbox && !closeCheckbox.checked) {
          closeCheckbox.checked = true;
          toggleCloseStakeAccount();
        }
      }, 100);
    }

    // Send XNT to Identity Modal State
    let sendWalletBalanceLamports = 0;

    function initiateSendToIdentity() {
      if (!walletPublicKey) {
        showWalletRequired('send XNT');
        return;
      }
      
      if (!currentManageValidator || !currentManageValidator.identityPubkey) {
        alert('Validator identity address not available.');
        return;
      }
      
      // Populate modal with validator info
      document.getElementById('sendDestinationName').textContent = currentManageValidator.name;
      document.getElementById('sendDestinationAddress').textContent = currentManageValidator.identityPubkey;
      document.getElementById('sendDestinationCopyBtn').innerHTML = getCopyButtonHtml(currentManageValidator.identityPubkey);
      
      // Reset form
      document.getElementById('sendAmountInput').value = '';
      document.getElementById('sendSummaryAmount').textContent = '0.0000 XNT';
      document.getElementById('sendSummaryTotal').textContent = '0.0000 XNT';
      document.getElementById('sendWalletBalance').textContent = 'Loading...';
      document.getElementById('sendIdWalletBalance').textContent = 'Loading...';
      document.getElementById('sendMessage').style.display = 'none';
      document.getElementById('sendConfirmBtn').disabled = false;
      document.getElementById('sendConfirmBtn').textContent = 'Send XNT';
      document.getElementById('sendConfirmBtn').onclick = confirmSendXnt;
      document.getElementById('sendXntCancelBtn').textContent = 'Cancel';
      
      // Fetch wallet balance and ID wallet balance
      fetchSendWalletBalance();
      fetchIdWalletBalance();
      
      // Show modal
      document.getElementById('sendXntModal').style.display = 'flex';
    }

    function closeSendXntModal() {
      document.getElementById('sendXntModal').style.display = 'none';
    }

    async function fetchSendWalletBalance() {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBalance',
            params: [walletPublicKey]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value !== undefined) {
          sendWalletBalanceLamports = data.result.value;
          const balance = lamportsToXNT(sendWalletBalanceLamports);
          document.getElementById('sendWalletBalance').textContent = formatNumber(balance, 4);
        } else {
          document.getElementById('sendWalletBalance').textContent = '0.0000';
          sendWalletBalanceLamports = 0;
        }
      } catch (e) {
        console.error('Error fetching wallet balance:', e);
        document.getElementById('sendWalletBalance').textContent = 'Error';
        sendWalletBalanceLamports = 0;
      }
    }

    async function fetchIdWalletBalance() {
      try {
        if (!currentManageValidator || !currentManageValidator.identityPubkey) {
          document.getElementById('sendIdWalletBalance').textContent = 'N/A';
          return;
        }
        
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBalance',
            params: [currentManageValidator.identityPubkey]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value !== undefined) {
          const balance = lamportsToXNT(data.result.value);
          document.getElementById('sendIdWalletBalance').textContent = formatNumber(balance, 4);
        } else {
          document.getElementById('sendIdWalletBalance').textContent = '0.0000';
        }
      } catch (e) {
        console.error('Error fetching ID wallet balance:', e);
        document.getElementById('sendIdWalletBalance').textContent = 'Error';
      }
    }

    function setSendAmount(percentage) {
      if (sendWalletBalanceLamports <= 0) return;
      
      // Reserve 0.01 XNT for fees if MAX
      const reserveForFees = percentage === 100 ? 10000000 : 0; // 0.01 XNT in lamports
      const availableLamports = Math.max(0, sendWalletBalanceLamports - reserveForFees);
      const amountLamports = Math.floor(availableLamports * (percentage / 100));
      const amount = lamportsToXNT(amountLamports);
      
      document.getElementById('sendAmountInput').value = amount.toFixed(4);
      updateSendSummary();
    }

    function updateSendSummary() {
      const input = document.getElementById('sendAmountInput');
      const amount = parseFloat(input.value) || 0;
      const fee = 0.000005; // Estimated network fee
      const total = amount + fee;
      
      document.getElementById('sendSummaryAmount').textContent = formatNumber(amount, 4) + ' XNT';
      document.getElementById('sendSummaryTotal').textContent = formatNumber(total, 6) + ' XNT';
    }

    async function confirmSendXnt() {
      const amountInput = document.getElementById('sendAmountInput');
      const amount = parseFloat(amountInput.value);
      
      if (!amount || amount <= 0) {
        showSendMessage('Please enter a valid amount.', 'error');
        return;
      }
      
      const amountLamports = Math.floor(amount * 1000000000); // Convert to lamports
      
      if (amountLamports > sendWalletBalanceLamports) {
        showSendMessage('Insufficient balance.', 'error');
        return;
      }
      
      const destinationAddress = currentManageValidator.identityPubkey;
      
      try {
        // Disable button and show loading state
        const btn = document.getElementById('sendConfirmBtn');
        btn.disabled = true;
        btn.textContent = 'Preparing Transaction...';
        
        showSendMessage('Preparing transaction...', 'info');
        
        // Use Solana web3.js to create the transaction
        const { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } = solanaWeb3;
        
        const connection = new Connection(RPC_URL, 'confirmed');
        const fromPubkey = new PublicKey(walletPublicKey);
        const toPubkey = new PublicKey(destinationAddress);
        
        // Create transfer instruction
        const transferInstruction = SystemProgram.transfer({
          fromPubkey: fromPubkey,
          toPubkey: toPubkey,
          lamports: amountLamports
        });
        
        // Create transaction
        const transaction = new Transaction().add(transferInstruction);
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = fromPubkey;
        
        btn.textContent = 'Awaiting Wallet Approval...';
        showSendMessage('Please approve the transaction in your wallet...', 'info');
        
        // Sign and send using the connected wallet
        if (connectedWallet && connectedWallet.provider) {
          let signature;
          
          // Try signAndSendTransaction first
          try {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } catch (signError) {
            console.log('signAndSendTransaction failed, trying alternative method:', signError);
            
            // If that fails, try signing then sending separately
            if (connectedWallet.provider.signTransaction) {
              const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
              const rawTransaction = signedTransaction.serialize();
              signature = await connection.sendRawTransaction(rawTransaction, {
                skipPreflight: false,
                preflightCommitment: 'confirmed'
              });
            } else {
              throw signError;
            }
          }
          
          btn.textContent = 'Confirming...';
          showSendMessage('Transaction sent! Waiting for confirmation...', 'info');
          
          // Wait for confirmation
          const confirmation = await connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'confirmed');
          
          if (confirmation.value.err) {
            throw new Error('Transaction failed to confirm: ' + JSON.stringify(confirmation.value.err));
          }
          
          btn.textContent = 'Success!';
          btn.onclick = closeSendXntModal;
          btn.disabled = false;
          document.getElementById('sendXntCancelBtn').textContent = 'Close';
          showSendMessage(`Transaction confirmed! Signature: ${signature.slice(0, 16)}...`, 'success');
          
          // Refresh balances after a delay (but don't auto-close modal)
          setTimeout(() => {
            fetchValidatorIdBalance();
            fetchSendWalletBalance();
          }, 2000);
          
        } else {
          throw new Error('Wallet not connected properly');
        }
        
      } catch (e) {
        console.error('Transaction error:', e);
        
        const btn = document.getElementById('sendConfirmBtn');
        btn.disabled = false;
        btn.textContent = 'Send XNT';
        
        if (e.message && (e.message.includes('User rejected') || e.message.includes('rejected'))) {
          showSendMessage('Transaction cancelled by user.', 'error');
        } else if (e.message && e.message.includes('Plugin Closed')) {
          showSendMessage('Wallet closed unexpectedly. Please try again.', 'error');
        } else {
          showSendMessage(`Transaction failed: ${e.message || 'Unknown error'}`, 'error');
        }
      }
    }

    function showSendMessage(message, type) {
      const el = document.getElementById('sendMessage');
      el.textContent = message;
      el.className = 'send-message ' + type;
      el.style.display = 'block';
    }

    // Add event listeners for form inputs
    document.addEventListener('DOMContentLoaded', function() {
      const sendAmountInput = document.getElementById('sendAmountInput');
      if (sendAmountInput) {
        sendAmountInput.addEventListener('input', updateSendSummary);
      }
      
      const withdrawAmountInput = document.getElementById('withdrawAmountInput');
      if (withdrawAmountInput) {
        withdrawAmountInput.addEventListener('input', updateWithdrawSummary);
      }
      
      const iconInput = document.getElementById('identityIconInput');
      if (iconInput) {
        iconInput.addEventListener('blur', previewIcon);
      }
      
      const createStakeInput = document.getElementById('createStakeAmountInput');
      if (createStakeInput) {
        createStakeInput.addEventListener('input', updateCreateStakeSummary);
      }
      
      const setWithdrawAuthorityInput = document.getElementById('setWithdrawNewAuthority');
      if (setWithdrawAuthorityInput) {
        setWithdrawAuthorityInput.addEventListener('input', validateWithdrawAuthorityInput);
      }
      
      const setStakeAuthorityInput = document.getElementById('setStakerNewAuthority');
      if (setStakeAuthorityInput) {
        setStakeAuthorityInput.addEventListener('input', validateStakeAuthorityInput);
      }
    });

    // Create Stake Modal State
    let createStakeWalletBalanceLamports = 0;
    const STAKE_ACCOUNT_RENT = 2282880; // ~0.00228 XNT rent-exempt minimum for stake account

    function initiateCreateStake() {
      if (!walletPublicKey) {
        showWalletRequired('create a stake account');
        return;
      }
      
      if (!currentManageValidator) {
        alert('Validator data not available.');
        return;
      }
      
      // Populate modal
      document.getElementById('createStakeValidatorName').textContent = currentManageValidator.name;
      document.getElementById('createStakeVoteAddress').textContent = currentManageValidator.voteAccount;
      document.getElementById('createStakeVoteCopyBtn').innerHTML = getCopyButtonHtml(currentManageValidator.voteAccount);
      
      // Show authorities (will be set to connected wallet)
      document.getElementById('createStakeStakerAuthority').textContent = shortenAddress(walletPublicKey);
      document.getElementById('createStakeWithdrawAuthority').textContent = shortenAddress(walletPublicKey);
      
      // Reset form
      document.getElementById('createStakeAmountInput').value = '';
      document.getElementById('createStakeSummaryAmount').textContent = '0.0000 XNT';
      document.getElementById('createStakeSummaryTotal').textContent = '0.0000 XNT';
      document.getElementById('createStakeWalletBalance').textContent = 'Loading...';
      document.getElementById('createStakeMessage').style.display = 'none';
      document.getElementById('createStakeConfirmBtn').disabled = false;
      document.getElementById('createStakeConfirmBtn').textContent = 'Create & Delegate Stake';
      document.getElementById('createStakeConfirmBtn').onclick = confirmCreateStake;
      document.getElementById('createStakeCancelBtn').textContent = 'Cancel';
      
      // Fetch wallet balance
      fetchCreateStakeWalletBalance();
      
      // Show modal
      document.getElementById('createStakeModal').style.display = 'flex';
    }

    function closeCreateStakeModal() {
      document.getElementById('createStakeModal').style.display = 'none';
    }

    async function fetchCreateStakeWalletBalance() {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getBalance',
            params: [walletPublicKey]
          })
        });
        
        const data = await response.json();
        if (data.result && data.result.value !== undefined) {
          createStakeWalletBalanceLamports = data.result.value;
          const balance = lamportsToXNT(createStakeWalletBalanceLamports);
          document.getElementById('createStakeWalletBalance').textContent = formatNumber(balance, 4);
        } else {
          document.getElementById('createStakeWalletBalance').textContent = '0.0000';
          createStakeWalletBalanceLamports = 0;
        }
      } catch (e) {
        console.error('Error fetching wallet balance:', e);
        document.getElementById('createStakeWalletBalance').textContent = 'Error';
        createStakeWalletBalanceLamports = 0;
      }
    }

    function setCreateStakeAmount(percentage) {
      if (createStakeWalletBalanceLamports <= 0) return;
      
      // Reserve rent + fees
      const reserveForRentAndFees = STAKE_ACCOUNT_RENT + 10000000; // rent + 0.01 XNT for fees
      const availableLamports = Math.max(0, createStakeWalletBalanceLamports - reserveForRentAndFees);
      const amountLamports = Math.floor(availableLamports * (percentage / 100));
      const amount = lamportsToXNT(amountLamports);
      
      document.getElementById('createStakeAmountInput').value = amount.toFixed(4);
      updateCreateStakeSummary();
    }

    function updateCreateStakeSummary() {
      const input = document.getElementById('createStakeAmountInput');
      const amount = parseFloat(input.value) || 0;
      const rent = lamportsToXNT(STAKE_ACCOUNT_RENT);
      const fee = 0.000005;
      const total = amount + rent + fee;
      
      document.getElementById('createStakeSummaryAmount').textContent = formatNumber(amount, 4) + ' XNT';
      document.getElementById('createStakeSummaryTotal').textContent = formatNumber(total, 6) + ' XNT';
    }

    async function confirmCreateStake() {
      const amountInput = document.getElementById('createStakeAmountInput');
      const amount = parseFloat(amountInput.value);
      
      if (!amount || amount <= 0) {
        showCreateStakeMessage('Please enter a valid amount.', 'error');
        return;
      }
      
      const stakeLamports = Math.floor(amount * 1000000000);
      const totalRequired = stakeLamports + STAKE_ACCOUNT_RENT + 5000; // stake + rent + fee
      
      if (totalRequired > createStakeWalletBalanceLamports) {
        showCreateStakeMessage('Insufficient balance for stake amount plus rent and fees.', 'error');
        return;
      }
      
      const btn = document.getElementById('createStakeConfirmBtn');
      
      try {
        btn.disabled = true;
        btn.textContent = 'Preparing Transaction...';
        
        showCreateStakeMessage('Creating stake account...', 'info');
        
        const { Connection, PublicKey, Transaction, Keypair, StakeProgram } = solanaWeb3;
        
        const connection = new Connection(RPC_URL, 'confirmed');
        const fromPubkey = new PublicKey(walletPublicKey);
        const votePubkey = new PublicKey(currentManageValidator.voteAccount);
        
        // Log for debugging
        console.log('Creating stake with authorities set to:', walletPublicKey);
        console.log('fromPubkey:', fromPubkey.toString());
        console.log('votePubkey:', votePubkey.toString());
        console.log('stakeLamports:', stakeLamports);
        
        // Generate a new keypair for the stake account
        const stakeAccount = Keypair.generate();
        console.log('New stake account:', stakeAccount.publicKey.toString());
        
        // Calculate total lamports needed (stake amount + rent)
        const totalLamports = stakeLamports + STAKE_ACCOUNT_RENT;
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
        console.log('Got blockhash:', blockhash);
        
        // StakeProgram.createAccount returns a Transaction object
        const createAccountTx = StakeProgram.createAccount({
          fromPubkey: fromPubkey,
          stakePubkey: stakeAccount.publicKey,
          authorized: {
            staker: fromPubkey,
            withdrawer: fromPubkey
          },
          lockup: {
            unixTimestamp: 0,
            epoch: 0,
            custodian: fromPubkey
          },
          lamports: totalLamports
        });
        
        // Delegate stake to validator
        const delegateTx = StakeProgram.delegate({
          stakePubkey: stakeAccount.publicKey,
          authorizedPubkey: fromPubkey,
          votePubkey: votePubkey
        });
        
        // Build transaction - extract instructions from the returned transactions
        const transaction = new Transaction();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = fromPubkey;
        
        // Add instructions from createAccount (may be Transaction or have instructions array)
        if (createAccountTx.instructions) {
          createAccountTx.instructions.forEach(ix => transaction.add(ix));
        } else {
          transaction.add(createAccountTx);
        }
        
        // Add instructions from delegate
        if (delegateTx.instructions) {
          delegateTx.instructions.forEach(ix => transaction.add(ix));
        } else {
          transaction.add(delegateTx);
        }
        
        console.log('Transaction built with', transaction.instructions.length, 'instructions');
        
        // The stake account keypair needs to sign
        transaction.partialSign(stakeAccount);
        console.log('Partially signed with stake account');
        
        btn.textContent = 'Awaiting Wallet Approval...';
        showCreateStakeMessage('Please approve the transaction in your wallet...', 'info');
        
        // Sign with wallet and send
        if (connectedWallet && connectedWallet.provider) {
          let signature;
          
          try {
            console.log('Calling signAndSendTransaction...');
            // The wallet needs to sign the partially signed transaction
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature || result;
            console.log('Got signature:', signature);
          } catch (signError) {
            console.log('signAndSendTransaction failed, trying alternative:', signError);
            
            if (connectedWallet.provider.signTransaction) {
              const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
              const rawTransaction = signedTransaction.serialize();
              signature = await connection.sendRawTransaction(rawTransaction, {
                skipPreflight: false,
                preflightCommitment: 'confirmed'
              });
            } else {
              throw signError;
            }
          }
          
          btn.textContent = 'Confirming...';
          showCreateStakeMessage('Transaction sent! Waiting for confirmation...', 'info');
          
          // Wait for confirmation
          const confirmation = await connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'confirmed');
          
          if (confirmation.value.err) {
            throw new Error('Transaction failed to confirm: ' + JSON.stringify(confirmation.value.err));
          }
          
          btn.textContent = 'Success!';
          btn.onclick = closeCreateStakeModal;
          btn.disabled = false;
          document.getElementById('createStakeCancelBtn').textContent = 'Close';
          showCreateStakeMessage(`Stake created and delegated! Account: ${stakeAccount.publicKey.toString().slice(0, 12)}... Signature: ${String(signature).slice(0, 16)}...`, 'success');
          
          // Refresh balances and stake accounts after a delay (but don't auto-close modal)
          setTimeout(() => {
            fetchCreateStakeWalletBalance();
            // Refresh the stake accounts list in the Manage Validator modal
            if (currentManageValidator && currentManageValidator.voteAccount) {
              fetchStakeAccounts(currentManageValidator.voteAccount);
            }
          }, 3000);
          
        } else {
          throw new Error('Wallet not connected properly');
        }
        
      } catch (e) {
        console.error('Create stake error:', e);
        
        btn.disabled = false;
        btn.textContent = 'Create & Delegate Stake';
        
        if (e.message && (e.message.includes('User rejected') || e.message.includes('rejected'))) {
          showCreateStakeMessage('Transaction cancelled by user.', 'error');
        } else if (e.message && e.message.includes('Plugin Closed')) {
          showCreateStakeMessage('Wallet closed unexpectedly. Please try again.', 'error');
        } else {
          showCreateStakeMessage(`Transaction failed: ${e.message || 'Unknown error'}`, 'error');
        }
      }
    }

    function showCreateStakeMessage(message, type) {
      const el = document.getElementById('createStakeMessage');
      el.textContent = message;
      el.className = 'send-message ' + type;
      el.style.display = 'block';
    }

    // Track current stake for authority changes
    let currentAuthorityStake = null;

    function initiateSetWithdrawAuthority() {
      if (!walletPublicKey) {
        showWalletRequired('set withdraw authority');
        return;
      }
      
      // Get selected stake account
      const stakeIndex = parseInt(selectedAccountType.replace('stake-', ''));
      const stake = stakeAccounts[stakeIndex];
      
      if (!stake) {
        alert('Please select a stake account first.');
        return;
      }
      
      currentAuthorityStake = stake;
      const withdrawer = stake.data.meta?.authorized?.withdrawer;
      
      // Populate modal
      document.getElementById('setWithdrawStakeAddress').textContent = stake.pubkey;
      document.getElementById('setWithdrawStakeCopyBtn').innerHTML = getCopyButtonHtml(stake.pubkey);
      document.getElementById('setWithdrawCurrentAuthority').textContent = withdrawer || 'Unknown';
      if (withdrawer) {
        document.getElementById('setWithdrawCurrentCopyBtn').innerHTML = getCopyButtonHtml(withdrawer);
      }
      document.getElementById('setWithdrawNewAuthority').value = '';
      document.getElementById('setWithdrawAuthorityMessage').style.display = 'none';
      document.getElementById('setWithdrawAuthorityBtn').disabled = true;
      document.getElementById('setWithdrawAuthorityBtn').textContent = 'Set New Authority';
      document.getElementById('setWithdrawAuthorityBtn').onclick = confirmSetWithdrawAuthority;
      document.getElementById('setWithdrawAuthorityCancelBtn').textContent = 'Cancel';
      
      // Check authority
      if (withdrawer && withdrawer !== walletPublicKey) {
        document.getElementById('withdrawAuthorityWarning2').style.display = 'flex';
        document.getElementById('setWithdrawAuthorityBtn').disabled = true;
      } else {
        document.getElementById('withdrawAuthorityWarning2').style.display = 'none';
      }
      
      // Show modal
      document.getElementById('setWithdrawAuthorityModal').style.display = 'flex';
    }

    function closeSetWithdrawAuthorityModal() {
      document.getElementById('setWithdrawAuthorityModal').style.display = 'none';
      currentAuthorityStake = null;
    }

    function validateWithdrawAuthorityInput() {
      const newAuthority = document.getElementById('setWithdrawNewAuthority').value.trim();
      const btn = document.getElementById('setWithdrawAuthorityBtn');
      const withdrawer = currentAuthorityStake?.data.meta?.authorized?.withdrawer;
      
      // Validate address is 32-44 chars (base58 pubkey)
      if (newAuthority.length >= 32 && newAuthority.length <= 44 && withdrawer === walletPublicKey) {
        btn.disabled = false;
      } else {
        btn.disabled = true;
      }
    }

    async function confirmSetWithdrawAuthority() {
      const newAuthority = document.getElementById('setWithdrawNewAuthority').value.trim();
      
      if (!newAuthority || !currentAuthorityStake) {
        showSetWithdrawAuthorityMessage('Please enter a valid public key.', 'error');
        return;
      }
      
      try {
        const btn = document.getElementById('setWithdrawAuthorityBtn');
        btn.disabled = true;
        btn.textContent = 'Preparing Transaction...';
        
        showSetWithdrawAuthorityMessage('Setting new withdraw authority...', 'info');
        
        const { Connection, PublicKey, Transaction, StakeProgram } = solanaWeb3;
        
        const connection = new Connection(RPC_URL, 'confirmed');
        const stakePubkey = new PublicKey(currentAuthorityStake.pubkey);
        const authorizedPubkey = new PublicKey(walletPublicKey);
        const newAuthorizedPubkey = new PublicKey(newAuthority);
        
        // Create authorize instruction
        const authorizeInstruction = StakeProgram.authorize({
          stakePubkey: stakePubkey,
          authorizedPubkey: authorizedPubkey,
          newAuthorizedPubkey: newAuthorizedPubkey,
          stakeAuthorizationType: { index: 1 } // 1 = Withdrawer
        });
        
        const transaction = new Transaction().add(authorizeInstruction);
        
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = authorizedPubkey;
        
        btn.textContent = 'Awaiting Wallet Approval...';
        showSetWithdrawAuthorityMessage('Please approve the transaction in your wallet...', 'info');
        
        if (connectedWallet && connectedWallet.provider) {
          let signature;
          
          try {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } catch (signError) {
            if (connectedWallet.provider.signTransaction) {
              const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
              const rawTransaction = signedTransaction.serialize();
              signature = await connection.sendRawTransaction(rawTransaction);
            } else {
              throw signError;
            }
          }
          
          btn.textContent = 'Confirming...';
          showSetWithdrawAuthorityMessage('Transaction sent! Waiting for confirmation...', 'info');
          
          const confirmation = await connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'confirmed');
          
          if (confirmation.value.err) {
            throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
          }
          
          btn.textContent = 'Success!';
          btn.onclick = closeSetWithdrawAuthorityModal;
          btn.disabled = false;
          document.getElementById('setWithdrawAuthorityCancelBtn').textContent = 'Close';
          showSetWithdrawAuthorityMessage(`Withdraw authority updated! Signature: ${signature.slice(0, 20)}...`, 'success');
          
          // Remember current selection
          const currentSelection = selectedAccountType;
          
          // Refresh stake accounts and re-select to update details (but don't auto-close modal)
          setTimeout(async () => {
            if (currentManageValidator && currentManageValidator.voteAccount) {
              await fetchStakeAccounts(currentManageValidator.voteAccount);
              // Re-select the stake account to refresh the details panel
              setTimeout(() => {
                if (currentSelection && currentSelection.startsWith('stake-')) {
                  selectAccount(currentSelection);
                }
              }, 200);
            }
          }, 2000);
          
        } else {
          throw new Error('Wallet not connected');
        }
        
      } catch (e) {
        console.error('Set withdraw authority error:', e);
        const btn = document.getElementById('setWithdrawAuthorityBtn');
        btn.disabled = false;
        btn.textContent = 'Set New Authority';
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showSetWithdrawAuthorityMessage('Transaction cancelled by user.', 'error');
        } else {
          showSetWithdrawAuthorityMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
      }
    }

    function showSetWithdrawAuthorityMessage(message, type) {
      const el = document.getElementById('setWithdrawAuthorityMessage');
      el.textContent = message;
      el.className = 'send-message ' + type;
      el.style.display = 'block';
    }

    function initiateSetStakeAuthority() {
      if (!walletPublicKey) {
        showWalletRequired('set stake authority');
        return;
      }
      
      // Get selected stake account
      const stakeIndex = parseInt(selectedAccountType.replace('stake-', ''));
      const stake = stakeAccounts[stakeIndex];
      
      if (!stake) {
        alert('Please select a stake account first.');
        return;
      }
      
      currentAuthorityStake = stake;
      const staker = stake.data.meta?.authorized?.staker;
      
      // Populate modal
      document.getElementById('setStakerStakeAddress').textContent = stake.pubkey;
      document.getElementById('setStakerStakeCopyBtn').innerHTML = getCopyButtonHtml(stake.pubkey);
      document.getElementById('setStakerCurrentAuthority').textContent = staker || 'Unknown';
      if (staker) {
        document.getElementById('setStakerCurrentCopyBtn').innerHTML = getCopyButtonHtml(staker);
      }
      document.getElementById('setStakerNewAuthority').value = '';
      document.getElementById('setStakeAuthorityMessage').style.display = 'none';
      document.getElementById('setStakeAuthorityBtn').disabled = true;
      document.getElementById('setStakeAuthorityBtn').textContent = 'Set New Authority';
      document.getElementById('setStakeAuthorityBtn').onclick = confirmSetStakeAuthority;
      document.getElementById('setStakeAuthorityCancelBtn').textContent = 'Cancel';
      
      // Check authority
      if (staker && staker !== walletPublicKey) {
        document.getElementById('stakeAuthorityWarning2').style.display = 'flex';
        document.getElementById('setStakeAuthorityBtn').disabled = true;
      } else {
        document.getElementById('stakeAuthorityWarning2').style.display = 'none';
      }
      
      // Show modal
      document.getElementById('setStakeAuthorityModal').style.display = 'flex';
    }

    function closeSetStakeAuthorityModal() {
      document.getElementById('setStakeAuthorityModal').style.display = 'none';
      currentAuthorityStake = null;
    }

    function validateStakeAuthorityInput() {
      const newAuthority = document.getElementById('setStakerNewAuthority').value.trim();
      const btn = document.getElementById('setStakeAuthorityBtn');
      const staker = currentAuthorityStake?.data.meta?.authorized?.staker;
      
      if (newAuthority.length >= 32 && newAuthority.length <= 44 && staker === walletPublicKey) {
        btn.disabled = false;
      } else {
        btn.disabled = true;
      }
    }

    async function confirmSetStakeAuthority() {
      const newAuthority = document.getElementById('setStakerNewAuthority').value.trim();
      
      if (!newAuthority || !currentAuthorityStake) {
        showSetStakeAuthorityMessage('Please enter a valid public key.', 'error');
        return;
      }
      
      try {
        const btn = document.getElementById('setStakeAuthorityBtn');
        btn.disabled = true;
        btn.textContent = 'Preparing Transaction...';
        
        showSetStakeAuthorityMessage('Setting new stake authority...', 'info');
        
        const { Connection, PublicKey, Transaction, StakeProgram } = solanaWeb3;
        
        const connection = new Connection(RPC_URL, 'confirmed');
        const stakePubkey = new PublicKey(currentAuthorityStake.pubkey);
        const authorizedPubkey = new PublicKey(walletPublicKey);
        const newAuthorizedPubkey = new PublicKey(newAuthority);
        
        // Create authorize instruction
        const authorizeInstruction = StakeProgram.authorize({
          stakePubkey: stakePubkey,
          authorizedPubkey: authorizedPubkey,
          newAuthorizedPubkey: newAuthorizedPubkey,
          stakeAuthorizationType: { index: 0 } // 0 = Staker
        });
        
        const transaction = new Transaction().add(authorizeInstruction);
        
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = authorizedPubkey;
        
        btn.textContent = 'Awaiting Wallet Approval...';
        showSetStakeAuthorityMessage('Please approve the transaction in your wallet...', 'info');
        
        if (connectedWallet && connectedWallet.provider) {
          let signature;
          
          try {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } catch (signError) {
            if (connectedWallet.provider.signTransaction) {
              const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
              const rawTransaction = signedTransaction.serialize();
              signature = await connection.sendRawTransaction(rawTransaction);
            } else {
              throw signError;
            }
          }
          
          btn.textContent = 'Confirming...';
          showSetStakeAuthorityMessage('Transaction sent! Waiting for confirmation...', 'info');
          
          const confirmation = await connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'confirmed');
          
          if (confirmation.value.err) {
            throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
          }
          
          btn.textContent = 'Success!';
          btn.onclick = closeSetStakeAuthorityModal;
          btn.disabled = false;
          document.getElementById('setStakeAuthorityCancelBtn').textContent = 'Close';
          showSetStakeAuthorityMessage(`Stake authority updated! Signature: ${signature.slice(0, 20)}...`, 'success');
          
          // Remember current selection
          const currentSelection = selectedAccountType;
          
          // Refresh stake accounts and re-select to update details (but don't auto-close modal)
          setTimeout(async () => {
            if (currentManageValidator && currentManageValidator.voteAccount) {
              await fetchStakeAccounts(currentManageValidator.voteAccount);
              // Re-select the stake account to refresh the details panel
              setTimeout(() => {
                if (currentSelection && currentSelection.startsWith('stake-')) {
                  selectAccount(currentSelection);
                }
              }, 200);
            }
          }, 2000);
          
        } else {
          throw new Error('Wallet not connected');
        }
        
      } catch (e) {
        console.error('Set stake authority error:', e);
        const btn = document.getElementById('setStakeAuthorityBtn');
        btn.disabled = false;
        btn.textContent = 'Set New Authority';
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showSetStakeAuthorityMessage('Transaction cancelled by user.', 'error');
        } else {
          showSetStakeAuthorityMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
      }
    }

    function showSetStakeAuthorityMessage(message, type) {
      const el = document.getElementById('setStakeAuthorityMessage');
      el.textContent = message;
      el.className = 'send-message ' + type;
      el.style.display = 'block';
    }

    // Wallet Connection State
    let connectedWallet = null;
    let walletPublicKey = null;

    // Check for available wallets
    function getAvailableWallets() {
      const wallets = [];
      
      if (window.phantom?.solana) {
        wallets.push({ name: 'Phantom', provider: window.phantom.solana, icon: '' });
      }
      if (window.solflare) {
        wallets.push({ name: 'Solflare', provider: window.solflare, icon: '' });
      }
      if (window.backpack) {
        wallets.push({ name: 'Backpack', provider: window.backpack, icon: '' });
      }
      if (window.solana && !window.phantom) {
        wallets.push({ name: 'Solana Wallet', provider: window.solana, icon: '' });
      }
      
      return wallets;
    }

    // Connect wallet
    async function connectWallet() {
      const wallets = getAvailableWallets();
      
      if (wallets.length === 0) {
        showWalletModal();
        return;
      }
      
      if (wallets.length === 1) {
        await connectToProvider(wallets[0]);
      } else {
        showWalletSelectModal(wallets);
      }
    }

    // Show modal when no wallet is installed
    function showWalletModal() {
      const modal = document.createElement('div');
      modal.className = 'wallet-install-modal';
      modal.id = 'walletInstallModal';
      modal.innerHTML = `
        <div class="wallet-install-content">
          <h3>No Wallet Detected</h3>
          <p>Please install a Solana-compatible wallet to continue:</p>
          <div class="wallet-options">
            <a href="https://phantom.app/" target="_blank" class="wallet-option">
              <span class="wallet-option-icon"></span>
              <span>Phantom</span>
            </a>
            <a href="https://solflare.com/" target="_blank" class="wallet-option">
              <span class="wallet-option-icon"></span>
              <span>Solflare</span>
            </a>
            <a href="https://backpack.app/" target="_blank" class="wallet-option">
              <span class="wallet-option-icon"></span>
              <span>Backpack</span>
            </a>
          </div>
          <button class="wallet-modal-close" onclick="closeWalletInstallModal()">Close</button>
        </div>
      `;
      document.body.appendChild(modal);
      modal.style.display = 'flex';
    }

    function closeWalletInstallModal() {
      const modal = document.getElementById('walletInstallModal');
      if (modal) modal.remove();
    }

    // Show wallet selection modal
    function showWalletSelectModal(wallets) {
      const modal = document.createElement('div');
      modal.className = 'wallet-install-modal';
      modal.id = 'walletSelectModal';
      
      const walletButtons = wallets.map(w => `
        <button class="wallet-option" onclick="selectWallet('${w.name}')">
          <span class="wallet-option-icon">${w.icon}</span>
          <span>${w.name}</span>
        </button>
      `).join('');
      
      modal.innerHTML = `
        <div class="wallet-install-content">
          <h3>Select Wallet</h3>
          <p>Choose a wallet to connect:</p>
          <div class="wallet-options">
            ${walletButtons}
          </div>
          <button class="wallet-modal-close" onclick="closeWalletSelectModal()">Cancel</button>
        </div>
      `;
      document.body.appendChild(modal);
      modal.style.display = 'flex';
    }

    function closeWalletSelectModal() {
      const modal = document.getElementById('walletSelectModal');
      if (modal) modal.remove();
    }

    async function selectWallet(walletName) {
      closeWalletSelectModal();
      const wallets = getAvailableWallets();
      const wallet = wallets.find(w => w.name === walletName);
      if (wallet) {
        await connectToProvider(wallet);
      }
    }

    // Connect to a specific wallet provider
    async function connectToProvider(wallet) {
      try {
        updateWalletStatus('Connecting...', 'connecting');
        
        const response = await wallet.provider.connect();
        
        connectedWallet = wallet;
        walletPublicKey = response.publicKey.toString();
        
        // Update UI
        updateWalletStatus(`${wallet.icon} ${shortenAddress(walletPublicKey)}`, 'connected');
        document.getElementById('connectWalletBtn').style.display = 'none';
        document.getElementById('disconnectWalletBtn').style.display = 'block';
        
        // Update wallet status display in manage modal
        updateManageWalletDisplay();
        
        // If manage modal is open, refresh stake accounts to get fresh authority data
        if (currentManageValidator && currentManageValidator.voteAccount) {
          const currentSelection = selectedAccountType;
          fetchStakeAccounts(currentManageValidator.voteAccount).then(() => {
            if (currentSelection && currentSelection.startsWith('stake-')) {
              setTimeout(() => selectAccount(currentSelection), 100);
            }
          });
        }
        
        // Listen for disconnect
        wallet.provider.on('disconnect', handleDisconnect);
        wallet.provider.on('accountChanged', handleAccountChange);
        
        console.log('Wallet connected:', walletPublicKey);
        
      } catch (error) {
        console.error('Wallet connection error:', error);
        updateWalletStatus('Connection failed', 'error');
        setTimeout(() => {
          updateWalletStatus('No wallet connected', 'disconnected');
        }, 2000);
      }
    }

    function handleDisconnect() {
      connectedWallet = null;
      walletPublicKey = null;
      updateWalletStatus('No wallet connected', 'disconnected');
      document.getElementById('connectWalletBtn').style.display = 'block';
      document.getElementById('disconnectWalletBtn').style.display = 'none';
      
      // Update manage modal if open
      const indicator = document.getElementById('walletStatusIndicator');
      if (indicator) {
        indicator.classList.remove('connected');
        document.getElementById('walletStatusText').classList.remove('connected');
        document.getElementById('selectedWithdrawAuthority').textContent = 'Connect wallet to view';
        
        // Update authority badge (clickable)
        const authorityBadge = document.getElementById('authorityBadge');
        if (authorityBadge) {
          authorityBadge.className = 'authority-badge clickable';
          authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">No wallet connected</span>';
        }
        
        // If a stake account is selected, re-select it to update authority badges
        if (selectedAccountType && selectedAccountType.startsWith('stake-')) {
          selectAccount(selectedAccountType);
        }
      }
    }

    function handleAccountChange(newPublicKey) {
      if (newPublicKey) {
        walletPublicKey = newPublicKey.toString();
        updateWalletStatus(shortenAddress(walletPublicKey), 'connected');
        updateManageWalletDisplay();
        
        // If manage modal is open, refresh stake accounts to get fresh authority data
        if (currentManageValidator && currentManageValidator.voteAccount) {
          const currentSelection = selectedAccountType;
          fetchStakeAccounts(currentManageValidator.voteAccount).then(() => {
            // After refresh, re-select the account to update badges
            if (currentSelection && currentSelection.startsWith('stake-')) {
              setTimeout(() => selectAccount(currentSelection), 100);
            }
          });
        }
        
        console.log('Wallet account changed to:', walletPublicKey);
      } else {
        handleDisconnect();
      }
    }

    async function disconnectWallet() {
      if (connectedWallet && connectedWallet.provider) {
        try {
          await connectedWallet.provider.disconnect();
        } catch (e) {
          console.log('Disconnect error:', e);
        }
      }
      handleDisconnect();
    }

    function updateWalletStatus(text, status) {
      const statusEl = document.getElementById('walletStatusText');
      if (statusEl) {
        statusEl.textContent = text;
        if (status === 'connected') {
          statusEl.classList.add('connected');
        } else {
          statusEl.classList.remove('connected');
        }
      }
    }

    function shortenAddress(address) {
      if (!address) return '';
      return address.slice(0, 4) + '...' + address.slice(-4);
    }

    // Check if connected wallet has withdraw authority
    async function checkWithdrawAuthority() {
      if (!walletPublicKey || !currentManageValidator) return;
      
      const authorityBadge = document.getElementById('authorityBadge');
      
      try {
        // Fetch vote account info to get withdraw authority
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAccountInfo',
            params: [currentManageValidator.voteAccount, { encoding: 'jsonParsed' }]
          })
        });
        
        const data = await response.json();
        
        if (data.result && data.result.value) {
          const parsed = data.result.value.data.parsed;
          if (parsed && parsed.info) {
            const authorizedWithdrawer = parsed.info.authorizedWithdrawer;
            
            document.getElementById('selectedWithdrawAuthority').textContent = shortenAddress(authorizedWithdrawer);
            
            if (authorizedWithdrawer === walletPublicKey) {
              authorityBadge.className = 'authority-badge has-authority';
              authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">You have authority</span>';
            } else {
              authorityBadge.className = 'authority-badge no-authority';
              authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">You do not have authority</span>';
            }
          }
        }
      } catch (e) {
        console.error('Error checking withdraw authority:', e);
        authorityBadge.className = 'authority-badge';
        authorityBadge.innerHTML = '<span class="authority-badge-icon"></span><span class="authority-badge-text">Error checking authority</span>';
      }
    }

    // Withdraw XNT Modal State
    let withdrawVoteBalanceLamports = 0;
    let voteAccountWithdrawAuthority = null;
    let userHasWithdrawAuthority = false;

    function initiateWithdraw() {
      if (!currentManageValidator) return;
      if (!walletPublicKey) {
        showWalletRequired('withdraw XNT');
        return;
      }
      
      // Populate modal with validator info
      document.getElementById('withdrawSourceName').textContent = currentManageValidator.name;
      document.getElementById('withdrawSourceAddress').textContent = currentManageValidator.voteAccount;
      document.getElementById('withdrawSourceCopyBtn').innerHTML = getCopyButtonHtml(currentManageValidator.voteAccount);
      
      // Reset form
      document.getElementById('withdrawAmountInput').value = '';
      document.getElementById('withdrawDestinationInput').value = '';
      document.getElementById('withdrawSummaryAmount').textContent = '0.0000 XNT';
      document.getElementById('withdrawSummaryTotal').textContent = '0.0000 XNT';
      document.getElementById('withdrawAvailableBalance').textContent = 'Loading...';
      document.getElementById('withdrawMessage').style.display = 'none';
      document.getElementById('withdrawConfirmBtn').disabled = true;
      document.getElementById('withdrawConfirmBtn').textContent = 'Withdraw XNT';
      document.getElementById('withdrawConfirmBtn').onclick = confirmWithdrawXnt;
      document.getElementById('withdrawXntCancelBtn').textContent = 'Cancel';
      document.getElementById('withdrawAuthorityWarning').style.display = 'none';
      
      // Fetch vote account data and check authority
      fetchWithdrawModalData();
      
      // Show modal
      document.getElementById('withdrawXntModal').style.display = 'flex';
    }

    function closeWithdrawXntModal() {
      document.getElementById('withdrawXntModal').style.display = 'none';
    }

    async function fetchWithdrawModalData() {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAccountInfo',
            params: [currentManageValidator.voteAccount, { encoding: 'jsonParsed' }]
          })
        });
        
        const data = await response.json();
        
        if (data.result && data.result.value) {
          // Get balance
          withdrawVoteBalanceLamports = data.result.value.lamports;
          
          // Reserve minimum rent-exempt balance (~0.02 XNT = 20000000 lamports)
          const rentExempt = 20000000;
          const availableLamports = Math.max(0, withdrawVoteBalanceLamports - rentExempt);
          const availableXNT = lamportsToXNT(availableLamports);
          
          document.getElementById('withdrawAvailableBalance').textContent = formatNumber(availableXNT, 4);
          
          // Get withdraw authority
          const parsed = data.result.value.data.parsed;
          if (parsed && parsed.info) {
            voteAccountWithdrawAuthority = parsed.info.authorizedWithdrawer;
            
            // Auto-fill destination with withdraw authority
            document.getElementById('withdrawDestinationInput').value = voteAccountWithdrawAuthority;
            
            // Check if user has authority
            if (voteAccountWithdrawAuthority === walletPublicKey) {
              userHasWithdrawAuthority = true;
              document.getElementById('withdrawAuthorityWarning').style.display = 'none';
              document.getElementById('withdrawConfirmBtn').disabled = false;
            } else {
              userHasWithdrawAuthority = false;
              document.getElementById('withdrawAuthorityWarning').style.display = 'flex';
              document.getElementById('withdrawConfirmBtn').disabled = true;
            }
          }
        } else {
          document.getElementById('withdrawAvailableBalance').textContent = '0.0000';
          withdrawVoteBalanceLamports = 0;
        }
      } catch (e) {
        console.error('Error fetching vote account data:', e);
        document.getElementById('withdrawAvailableBalance').textContent = 'Error';
        withdrawVoteBalanceLamports = 0;
      }
    }

    function setWithdrawAmount(percentage) {
      // Reserve minimum rent-exempt balance
      const rentExempt = 20000000;
      const availableLamports = Math.max(0, withdrawVoteBalanceLamports - rentExempt);
      
      if (availableLamports <= 0) return;
      
      const amountLamports = Math.floor(availableLamports * (percentage / 100));
      const amount = lamportsToXNT(amountLamports);
      
      document.getElementById('withdrawAmountInput').value = amount.toFixed(4);
      updateWithdrawSummary();
    }

    function updateWithdrawSummary() {
      const input = document.getElementById('withdrawAmountInput');
      const amount = parseFloat(input.value) || 0;
      const fee = 0.000005; // Estimated network fee
      const received = Math.max(0, amount - fee);
      
      document.getElementById('withdrawSummaryAmount').textContent = formatNumber(amount, 4) + ' XNT';
      document.getElementById('withdrawSummaryTotal').textContent = formatNumber(received, 6) + ' XNT';
    }

    async function confirmWithdrawXnt() {
      if (!userHasWithdrawAuthority) {
        showWithdrawMessage('You do not have withdraw authority for this vote account.', 'error');
        return;
      }
      
      const amountInput = document.getElementById('withdrawAmountInput');
      const amount = parseFloat(amountInput.value);
      
      if (!amount || amount <= 0) {
        showWithdrawMessage('Please enter a valid amount.', 'error');
        return;
      }
      
      const amountLamports = Math.floor(amount * 1000000000);
      const rentExempt = 20000000;
      const availableLamports = withdrawVoteBalanceLamports - rentExempt;
      
      if (amountLamports > availableLamports) {
        showWithdrawMessage('Amount exceeds available balance (after rent reserve).', 'error');
        return;
      }
      
      const destinationAddress = document.getElementById('withdrawDestinationInput').value.trim();
      
      if (!destinationAddress || destinationAddress.length < 32) {
        showWithdrawMessage('Please enter a valid destination address.', 'error');
        return;
      }
      
      try {
        const btn = document.getElementById('withdrawConfirmBtn');
        btn.disabled = true;
        btn.textContent = 'Preparing Transaction...';
        
        showWithdrawMessage('Preparing withdraw transaction...', 'info');
        
        const { Connection, PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
        
        const connection = new Connection(RPC_URL, 'confirmed');
        const voteAccountPubkey = new PublicKey(currentManageValidator.voteAccount);
        const withdrawAuthorityPubkey = new PublicKey(walletPublicKey);
        const destinationPubkey = new PublicKey(destinationAddress);
        
        // Vote Program ID
        const VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');
        
        // Create withdraw instruction data
        // Instruction index 3 = Withdraw, followed by lamports (8 bytes LE)
        const data = new Uint8Array(12);
        const dataView = new DataView(data.buffer);
        dataView.setUint32(0, 3, true); // Withdraw instruction index
        // Write lamports as 64-bit LE
        const low = amountLamports & 0xffffffff;
        const high = Math.floor(amountLamports / 0x100000000);
        dataView.setUint32(4, low, true);
        dataView.setUint32(8, high, true);
        
        // Create the withdraw instruction
        const withdrawInstruction = new TransactionInstruction({
          keys: [
            { pubkey: voteAccountPubkey, isSigner: false, isWritable: true },
            { pubkey: destinationPubkey, isSigner: false, isWritable: true },
            { pubkey: withdrawAuthorityPubkey, isSigner: true, isWritable: false }
          ],
          programId: VOTE_PROGRAM_ID,
          data: data
        });
        
        // Create transaction
        const transaction = new Transaction().add(withdrawInstruction);
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = withdrawAuthorityPubkey;
        
        btn.textContent = 'Awaiting Wallet Approval...';
        showWithdrawMessage('Please approve the transaction in your wallet...', 'info');
        
        // Sign and send
        if (connectedWallet && connectedWallet.provider) {
          let signature;
          
          // Try signAndSendTransaction first
          try {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } catch (signError) {
            console.log('signAndSendTransaction failed, trying alternative method:', signError);
            
            // If that fails, try signing then sending separately
            if (connectedWallet.provider.signTransaction) {
              const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
              const rawTransaction = signedTransaction.serialize();
              signature = await connection.sendRawTransaction(rawTransaction, {
                skipPreflight: false,
                preflightCommitment: 'confirmed'
              });
            } else {
              throw signError;
            }
          }
          
          btn.textContent = 'Confirming...';
          showWithdrawMessage('Transaction sent! Waiting for confirmation...', 'info');
          
          // Wait for confirmation
          const confirmation = await connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'confirmed');
          
          if (confirmation.value.err) {
            throw new Error('Transaction failed to confirm: ' + JSON.stringify(confirmation.value.err));
          }
          
          btn.textContent = 'Success!';
          btn.onclick = closeWithdrawXntModal;
          btn.disabled = false;
          document.getElementById('withdrawXntCancelBtn').textContent = 'Close';
          showWithdrawMessage(`Withdrawal confirmed! Signature: ${signature.slice(0, 16)}...`, 'success');
          
          // Refresh balances (but don't auto-close modal)
          setTimeout(() => {
            fetchManageValidatorData(currentManageValidator.voteAccount);
            fetchWithdrawModalData();
          }, 2000);
          
        } else {
          throw new Error('Wallet not connected properly');
        }
        
      } catch (e) {
        console.error('Withdraw transaction error:', e);
        
        const btn = document.getElementById('withdrawConfirmBtn');
        btn.disabled = false;
        btn.textContent = 'Withdraw XNT';
        
        if (e.message && (e.message.includes('User rejected') || e.message.includes('rejected'))) {
          showWithdrawMessage('Transaction cancelled by user.', 'error');
        } else if (e.message && e.message.includes('Plugin Closed')) {
          showWithdrawMessage('Wallet closed unexpectedly. Please try again.', 'error');
        } else {
          showWithdrawMessage(`Transaction failed: ${e.message || 'Unknown error'}`, 'error');
        }
      }
    }

    function showWithdrawMessage(message, type) {
      const el = document.getElementById('withdrawMessage');
      el.textContent = message;
      el.className = 'send-message ' + type;
      el.style.display = 'block';
    }

    // Change Commission Modal State
    let currentCommission = 0;
    let userHasCommissionAuthority = false;

    function initiateChangeCommission() {
      if (!currentManageValidator) return;
      if (!walletPublicKey) {
        showWalletRequired('change commission');
        return;
      }
      
      // Populate modal
      document.getElementById('commissionValidatorName').textContent = currentManageValidator.name;
      document.getElementById('commissionVoteAddress').textContent = currentManageValidator.voteAccount;
      document.getElementById('commissionVoteCopyBtn').innerHTML = getCopyButtonHtml(currentManageValidator.voteAccount);
      document.getElementById('commissionCurrentValue').textContent = currentManageValidator.commission;
      currentCommission = currentManageValidator.commission;
      
      // Reset form
      document.getElementById('commissionNewInput').value = '';
      document.getElementById('commissionMessage').style.display = 'none';
      document.getElementById('commissionConfirmBtn').disabled = true;
      document.getElementById('commissionConfirmBtn').textContent = 'Update Commission';
      document.getElementById('commissionConfirmBtn').onclick = confirmChangeCommission;
      document.getElementById('commissionCancelBtn').textContent = 'Cancel';
      document.getElementById('commissionAuthorityWarning').style.display = 'none';
      
      // Check authority
      checkCommissionAuthority();
      
      // Show modal
      document.getElementById('commissionModal').style.display = 'flex';
    }

    function closeCommissionModal() {
      document.getElementById('commissionModal').style.display = 'none';
    }

    async function checkCommissionAuthority() {
      try {
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAccountInfo',
            params: [currentManageValidator.voteAccount, { encoding: 'jsonParsed' }]
          })
        });
        
        const data = await response.json();
        
        if (data.result && data.result.value) {
          const parsed = data.result.value.data.parsed;
          if (parsed && parsed.info) {
            // The authorized withdrawer can also change commission
            const authorizedWithdrawer = parsed.info.authorizedWithdrawer;
            
            if (authorizedWithdrawer === walletPublicKey) {
              userHasCommissionAuthority = true;
              document.getElementById('commissionAuthorityWarning').style.display = 'none';
              document.getElementById('commissionConfirmBtn').disabled = false;
            } else {
              userHasCommissionAuthority = false;
              document.getElementById('commissionAuthorityWarning').style.display = 'flex';
              document.getElementById('commissionConfirmBtn').disabled = true;
            }
          }
        }
      } catch (e) {
        console.error('Error checking commission authority:', e);
        userHasCommissionAuthority = false;
        document.getElementById('commissionConfirmBtn').disabled = true;
      }
    }

    async function confirmChangeCommission() {
      if (!userHasCommissionAuthority) {
        showCommissionMessage('You do not have authority to change commission.', 'error');
        return;
      }
      
      const newCommission = parseInt(document.getElementById('commissionNewInput').value);
      
      if (isNaN(newCommission) || newCommission < 0 || newCommission > 100) {
        showCommissionMessage('Please enter a valid commission rate (0-100).', 'error');
        return;
      }
      
      if (newCommission === currentCommission) {
        showCommissionMessage('New commission is the same as current commission.', 'error');
        return;
      }
      
      try {
        const btn = document.getElementById('commissionConfirmBtn');
        btn.disabled = true;
        btn.textContent = 'Preparing Transaction...';
        
        showCommissionMessage('Preparing commission update transaction...', 'info');
        
        const { Connection, PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
        
        const connection = new Connection(RPC_URL, 'confirmed');
        const voteAccountPubkey = new PublicKey(currentManageValidator.voteAccount);
        const authorityPubkey = new PublicKey(walletPublicKey);
        
        // Vote Program ID
        const VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');
        
        // Create update commission instruction data
        // Instruction index 5 = UpdateCommission, followed by new commission (1 byte)
        const data = new Uint8Array(5);
        const dataView = new DataView(data.buffer);
        dataView.setUint32(0, 5, true); // UpdateCommission instruction index
        data[4] = newCommission; // New commission percentage (1 byte)
        
        // Create the update commission instruction
        const updateCommissionInstruction = new TransactionInstruction({
          keys: [
            { pubkey: voteAccountPubkey, isSigner: false, isWritable: true },
            { pubkey: authorityPubkey, isSigner: true, isWritable: false }
          ],
          programId: VOTE_PROGRAM_ID,
          data: data
        });
        
        // Create transaction
        const transaction = new Transaction().add(updateCommissionInstruction);
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = authorityPubkey;
        
        btn.textContent = 'Awaiting Wallet Approval...';
        showCommissionMessage('Please approve the transaction in your wallet...', 'info');
        
        // Sign and send using wallet
        if (connectedWallet && connectedWallet.provider) {
          let signature;
          
          // Try signAndSendTransaction first
          try {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } catch (signError) {
            console.log('signAndSendTransaction failed, trying alternative method:', signError);
            
            // If that fails, try signing then sending separately
            if (connectedWallet.provider.signTransaction) {
              const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
              const rawTransaction = signedTransaction.serialize();
              signature = await connection.sendRawTransaction(rawTransaction, {
                skipPreflight: false,
                preflightCommitment: 'confirmed'
              });
            } else {
              throw signError;
            }
          }
          
          btn.textContent = 'Confirming...';
          showCommissionMessage('Transaction sent! Waiting for confirmation...', 'info');
          
          // Wait for confirmation
          const confirmation = await connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'confirmed');
          
          if (confirmation.value.err) {
            throw new Error('Transaction failed to confirm: ' + JSON.stringify(confirmation.value.err));
          }
          
          btn.textContent = 'Success!';
          btn.onclick = closeCommissionModal;
          btn.disabled = false;
          document.getElementById('commissionCancelBtn').textContent = 'Close';
          showCommissionMessage(`Commission updated to ${newCommission}%! Signature: ${signature.slice(0, 16)}...`, 'success');
          
          // Update the local state
          currentManageValidator.commission = newCommission;
          document.getElementById('selectedCommission').textContent = newCommission + '%';
          document.getElementById('commissionCurrentValue').textContent = newCommission;
          currentCommission = newCommission;
          
        } else {
          throw new Error('Wallet not connected properly');
        }
        
      } catch (e) {
        console.error('Commission update error:', e);
        
        const btn = document.getElementById('commissionConfirmBtn');
        btn.disabled = false;
        btn.textContent = 'Update Commission';
        
        if (e.message && (e.message.includes('User rejected') || e.message.includes('rejected'))) {
          showCommissionMessage('Transaction cancelled by user.', 'error');
        } else if (e.message && (e.message.includes('Plugin Closed') || e.message.includes('simulation') || e.message.includes('0x0'))) {
          showCommissionMessage('Transaction failed. Note: Commission can only be changed once per epoch. If you recently changed commission, please wait until the next epoch.', 'error');
        } else {
          showCommissionMessage(`Transaction failed: ${e.message || 'Unknown error'}. Note: Commission can only be changed once per epoch.`, 'error');
        }
      }
    }

    function showCommissionMessage(message, type) {
      const el = document.getElementById('commissionMessage');
      el.textContent = message;
      el.className = 'send-message ' + type;
      el.style.display = 'block';
    }

    // Update Identity Modal State
    let userHasIdentityAuthority = false;

    function initiateUpdateIdentity() {
      if (!currentManageValidator) return;
      if (!walletPublicKey) {
        showWalletRequired('update identity');
        return;
      }
      
      // Populate modal
      document.getElementById('identityCurrentName').textContent = currentManageValidator.name;
      document.getElementById('identityAccountAddress').textContent = currentManageValidator.identityPubkey || 'Unknown';
      if (currentManageValidator.identityPubkey) {
        document.getElementById('identityAccountCopyBtn').innerHTML = getCopyButtonHtml(currentManageValidator.identityPubkey);
      }
      
      // Pre-fill with current values if available
      document.getElementById('identityNameInput').value = currentManageValidator.name || '';
      document.getElementById('identityWebsiteInput').value = '';
      document.getElementById('identityIconInput').value = currentManageValidator.iconUrl || '';
      
      // Reset state
      document.getElementById('identityMessage').style.display = 'none';
      document.getElementById('identityConfirmBtn').disabled = true;
      document.getElementById('identityConfirmBtn').textContent = 'Update Identity';
      document.getElementById('identityConfirmBtn').onclick = confirmUpdateIdentity;
      document.getElementById('identityCancelBtn').textContent = 'Cancel';
      document.getElementById('identityAuthorityWarning').style.display = 'none';
      document.getElementById('iconPreviewSection').style.display = 'none';
      
      // Check if connected wallet is the identity
      checkIdentityAuthority();
      
      // Show modal
      document.getElementById('identityModal').style.display = 'flex';
      
      // Try to load current identity info
      loadCurrentIdentityInfo();
    }

    function closeIdentityModal() {
      document.getElementById('identityModal').style.display = 'none';
    }

    function checkIdentityAuthority() {
      const identityPubkey = currentManageValidator.identityPubkey;
      
      if (identityPubkey && identityPubkey === walletPublicKey) {
        userHasIdentityAuthority = true;
        document.getElementById('identityAuthorityWarning').style.display = 'none';
        document.getElementById('identityConfirmBtn').disabled = false;
      } else {
        userHasIdentityAuthority = false;
        document.getElementById('identityAuthorityWarning').style.display = 'flex';
        document.getElementById('identityConfirmBtn').disabled = true;
      }
    }

    async function loadCurrentIdentityInfo() {
      if (!currentManageValidator.identityPubkey) return;
      
      try {
        // Try to fetch existing validator info
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAccountInfo',
            params: [currentManageValidator.identityPubkey, { encoding: 'jsonParsed' }]
          })
        });
        
        const data = await response.json();
        // The identity info is stored separately, this just confirms the account exists
      } catch (e) {
        console.log('Could not load current identity info:', e);
      }
    }

    function previewIcon() {
      const iconUrl = document.getElementById('identityIconInput').value.trim();
      const previewSection = document.getElementById('iconPreviewSection');
      const previewImg = document.getElementById('iconPreviewImg');
      
      if (iconUrl && iconUrl.startsWith('http')) {
        previewImg.src = iconUrl;
        previewSection.style.display = 'block';
      } else {
        previewSection.style.display = 'none';
      }
    }

    function hideIconPreview() {
      document.getElementById('iconPreviewSection').style.display = 'none';
    }

    async function confirmUpdateIdentity() {
      if (!userHasIdentityAuthority) {
        showIdentityMessage('You do not have authority to update this validator\'s identity.', 'error');
        return;
      }
      
      const validatorName = document.getElementById('identityNameInput').value.trim();
      const website = document.getElementById('identityWebsiteInput').value.trim();
      const iconUrl = document.getElementById('identityIconInput').value.trim();
      
      if (!validatorName) {
        showIdentityMessage('Please enter a validator name.', 'error');
        return;
      }
      
      try {
        const btn = document.getElementById('identityConfirmBtn');
        btn.disabled = true;
        btn.textContent = 'Preparing Transaction...';
        
        showIdentityMessage('Preparing validator info update...', 'info');
        
        const { Connection, PublicKey, Transaction, TransactionInstruction, SystemProgram } = solanaWeb3;
        
        const connection = new Connection(RPC_URL, 'confirmed');
        const identityPubkey = new PublicKey(walletPublicKey);
        
        // Config Program ID (used for validator info)
        const CONFIG_PROGRAM_ID = new PublicKey('Config1111111111111111111111111111111111111');
        
        // Derive the validator info account address
        // The validator info account is a PDA derived from the identity pubkey
        const validatorInfoSeed = 'validator-info';
        const [validatorInfoAccount] = await PublicKey.findProgramAddress(
          [new TextEncoder().encode(validatorInfoSeed), identityPubkey.toBytes()],
          CONFIG_PROGRAM_ID
        );
        
        // Build the validator info JSON
        const validatorInfo = {
          name: validatorName
        };
        if (website) validatorInfo.website = website;
        if (iconUrl) validatorInfo.iconUrl = iconUrl;
        
        const infoString = JSON.stringify(validatorInfo);
        const infoBytes = new TextEncoder().encode(infoString);
        
        // Check if account exists
        const accountInfo = await connection.getAccountInfo(validatorInfoAccount);
        
        let transaction;
        
        if (!accountInfo) {
          // Account doesn't exist, need to create it
          // This is more complex - for now we'll show a message
          showIdentityMessage('Validator info account not found. Please use CLI: solana validator-info publish "' + validatorName + '"', 'info');
          btn.disabled = false;
          btn.textContent = 'Update Identity';
          return;
        }
        
        // Build the config data instruction
        // Config instruction: write data starting at offset
        const configKeys = [
          { pubkey: validatorInfoAccount, isSigner: false, isWritable: true },
          { pubkey: identityPubkey, isSigner: true, isWritable: false }
        ];
        
        // The config program expects specific data format
        // For validator-info, we need to use the proper serialization
        
        // Create instruction data for config program
        // This is a simplified version - actual validator-info uses borsh serialization
        const instructionData = new Uint8Array(4 + infoBytes.length);
        const dataView = new DataView(instructionData.buffer);
        dataView.setUint32(0, infoBytes.length, true); // Length prefix
        instructionData.set(infoBytes, 4);
        
        const updateInstruction = new TransactionInstruction({
          keys: configKeys,
          programId: CONFIG_PROGRAM_ID,
          data: instructionData
        });
        
        transaction = new Transaction().add(updateInstruction);
        
        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = identityPubkey;
        
        btn.textContent = 'Awaiting Wallet Approval...';
        showIdentityMessage('Please approve the transaction in your wallet...', 'info');
        
        // Sign and send
        if (connectedWallet && connectedWallet.provider) {
          let signature;
          
          try {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } catch (signError) {
            console.log('signAndSendTransaction failed:', signError);
            
            if (connectedWallet.provider.signTransaction) {
              const signedTransaction = await connectedWallet.provider.signTransaction(transaction);
              const rawTransaction = signedTransaction.serialize();
              signature = await connection.sendRawTransaction(rawTransaction, {
                skipPreflight: false,
                preflightCommitment: 'confirmed'
              });
            } else {
              throw signError;
            }
          }
          
          btn.textContent = 'Confirming...';
          showIdentityMessage('Transaction sent! Waiting for confirmation...', 'info');
          
          // Wait for confirmation
          const confirmation = await connection.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight
          }, 'confirmed');
          
          if (confirmation.value.err) {
            throw new Error('Transaction failed to confirm');
          }
          
          btn.textContent = 'Success!';
          btn.onclick = closeIdentityModal;
          btn.disabled = false;
          document.getElementById('identityCancelBtn').textContent = 'Close';
          showIdentityMessage(`Identity updated! Signature: ${signature.slice(0, 16)}...`, 'success');
          
          // Update local state
          currentManageValidator.name = validatorName;
          if (iconUrl) currentManageValidator.iconUrl = iconUrl;
          document.getElementById('manageValidatorName').textContent = validatorName;
          
        } else {
          throw new Error('Wallet not connected properly');
        }
        
      } catch (e) {
        console.error('Identity update error:', e);
        
        const btn = document.getElementById('identityConfirmBtn');
        btn.disabled = false;
        btn.textContent = 'Update Identity';
        
        if (e.message && (e.message.includes('User rejected') || e.message.includes('rejected'))) {
          showIdentityMessage('Transaction cancelled by user.', 'error');
        } else if (e.message && e.message.includes('invalid account data')) {
          showIdentityMessage('Unable to update via web interface. Please use CLI: solana validator-info publish "' + document.getElementById('identityNameInput').value + '"', 'error');
        } else {
          showIdentityMessage(`Transaction failed: ${e.message || 'Unknown error'}. Try using CLI: solana validator-info publish`, 'error');
        }
      }
    }

    function showIdentityMessage(message, type) {
      const el = document.getElementById('identityMessage');
      el.textContent = message;
      el.className = 'send-message ' + type;
      el.style.display = 'block';
    }

    // Change Vote Account Authority state
    let voteAuthorityType = 'vote'; // 'vote' or 'withdraw'
    let voteAccountAuthorities = { vote: null, withdraw: null };

    function initiateChangeAuthority() {
      if (!currentManageValidator) return;
      if (!walletPublicKey) {
        showWalletRequired('change authority');
        return;
      }
      
      // Reset state
      voteAuthorityType = 'vote';
      voteAccountAuthorities = { vote: null, withdraw: null };
      
      // Populate modal
      document.getElementById('changeVoteValidatorName').textContent = currentManageValidator.name;
      document.getElementById('changeVoteAccountAddress').textContent = shortenAddress(currentManageValidator.voteAccount);
      document.getElementById('changeVoteAccountCopyBtn').innerHTML = getCopyButtonHtml(currentManageValidator.voteAccount);
      
      // Reset form
      document.getElementById('newVoteAuthorityInput').value = '';
      document.getElementById('changeVoteAuthorityMessage').style.display = 'none';
      document.getElementById('changeVoteAuthorityBtn').disabled = true;
      document.getElementById('changeVoteAuthorityBtn').textContent = 'Change Authority';
      document.getElementById('changeVoteAuthorityBtn').onclick = confirmChangeVoteAuthority;
      document.getElementById('changeVoteAuthorityCancelBtn').textContent = 'Cancel';
      
      // Reset authority type buttons
      document.getElementById('voteAuthorityTypeBtn').classList.add('active');
      document.getElementById('withdrawAuthorityTypeBtn').classList.remove('active');
      
      // Fetch vote account authorities
      fetchVoteAccountAuthorities();
      
      // Show modal
      document.getElementById('changeVoteAuthorityModal').style.display = 'flex';
    }

    function closeChangeVoteAuthorityModal() {
      document.getElementById('changeVoteAuthorityModal').style.display = 'none';
    }

    async function fetchVoteAccountAuthorities() {
      try {
        document.getElementById('currentVoteAuthority').textContent = 'Loading...';
        
        const response = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getAccountInfo',
            params: [currentManageValidator.voteAccount, { encoding: 'jsonParsed' }]
          })
        });
        
        const data = await response.json();
        
        if (data.result && data.result.value) {
          const voteData = data.result.value.data.parsed.info;
          voteAccountAuthorities.vote = voteData.authorizedVoters?.[0]?.authorizedVoter || voteData.authorizedVoter;
          voteAccountAuthorities.withdraw = voteData.authorizedWithdrawer;
          
          // Update display based on selected type
          updateVoteAuthorityDisplay();
        } else {
          document.getElementById('currentVoteAuthority').textContent = 'Unable to fetch';
        }
      } catch (e) {
        console.error('Error fetching vote account authorities:', e);
        document.getElementById('currentVoteAuthority').textContent = 'Error loading';
      }
    }

    function selectVoteAuthorityType(type) {
      voteAuthorityType = type;
      
      // Update button states
      document.getElementById('voteAuthorityTypeBtn').classList.toggle('active', type === 'vote');
      document.getElementById('withdrawAuthorityTypeBtn').classList.toggle('active', type === 'withdraw');
      
      // Update labels
      updateVoteAuthorityDisplay();
      
      // Re-validate input
      validateVoteAuthorityInput();
    }

    function updateVoteAuthorityDisplay() {
      const currentAuthority = voteAuthorityType === 'vote' ? voteAccountAuthorities.vote : voteAccountAuthorities.withdraw;
      const typeLabel = voteAuthorityType === 'vote' ? 'Vote' : 'Withdraw';
      
      document.getElementById('currentVoteAuthorityLabel').textContent = `Current ${typeLabel} Authority:`;
      document.getElementById('newVoteAuthorityLabel').textContent = `New ${typeLabel} Authority:`;
      
      if (currentAuthority) {
        document.getElementById('currentVoteAuthority').textContent = shortenAddress(currentAuthority);
        document.getElementById('currentVoteAuthorityCopyBtn').innerHTML = getCopyButtonHtml(currentAuthority);
        
        // Check if wallet has authority
        const hasAuthority = currentAuthority === walletPublicKey;
        const warning = document.getElementById('voteAuthorityWarning');
        
        if (!hasAuthority) {
          warning.style.display = 'flex';
          document.getElementById('voteAuthorityWarningText').textContent = 
            `Your connected wallet is not the current ${typeLabel.toLowerCase()} authority for this vote account.`;
        } else {
          warning.style.display = 'none';
        }
      } else {
        document.getElementById('currentVoteAuthority').textContent = 'Loading...';
        document.getElementById('currentVoteAuthorityCopyBtn').innerHTML = '';
      }
    }

    function useWalletForVoteAuthority() {
      if (walletPublicKey) {
        document.getElementById('newVoteAuthorityInput').value = walletPublicKey;
        validateVoteAuthorityInput();
      }
    }

    function validateVoteAuthorityInput() {
      const input = document.getElementById('newVoteAuthorityInput').value.trim();
      const btn = document.getElementById('changeVoteAuthorityBtn');
      const currentAuthority = voteAuthorityType === 'vote' ? voteAccountAuthorities.vote : voteAccountAuthorities.withdraw;
      const hasAuthority = currentAuthority === walletPublicKey;
      
      // Validate: must have authority, input must be valid pubkey length, and different from current
      const isValidInput = input.length >= 32 && input.length <= 44;
      const isDifferent = input !== currentAuthority;
      
      btn.disabled = !(hasAuthority && isValidInput && isDifferent);
    }

    function showChangeVoteAuthorityMessage(message, type) {
      const msgEl = document.getElementById('changeVoteAuthorityMessage');
      msgEl.textContent = message;
      msgEl.className = 'send-message ' + type;
      msgEl.style.display = 'block';
    }

    async function confirmChangeVoteAuthority() {
      const newAuthority = document.getElementById('newVoteAuthorityInput').value.trim();
      
      if (!newAuthority || !walletPublicKey || !currentManageValidator) return;
      
      // If changing vote authority, show scary confirmation first
      if (voteAuthorityType === 'vote') {
        showVoteAuthorityDangerModal();
        return;
      }
      
      // For withdraw authority, proceed directly
      await executeVoteAuthorityChange(newAuthority);
    }

    function showVoteAuthorityDangerModal() {
      document.getElementById('voteAuthorityConfirmInput').value = '';
      document.getElementById('voteAuthorityDangerBtn').disabled = true;
      document.getElementById('voteAuthorityDangerModal').style.display = 'flex';
    }

    function closeVoteAuthorityDangerModal() {
      document.getElementById('voteAuthorityDangerModal').style.display = 'none';
    }

    function validateVoteAuthorityConfirm() {
      const input = document.getElementById('voteAuthorityConfirmInput').value.trim();
      const btn = document.getElementById('voteAuthorityDangerBtn');
      btn.disabled = input !== 'CHANGE VOTE AUTHORITY';
    }

    async function proceedWithVoteAuthorityChange() {
      closeVoteAuthorityDangerModal();
      const newAuthority = document.getElementById('newVoteAuthorityInput').value.trim();
      await executeVoteAuthorityChange(newAuthority);
    }

    async function executeVoteAuthorityChange(newAuthority) {
      const btn = document.getElementById('changeVoteAuthorityBtn');
      btn.disabled = true;
      btn.textContent = 'Processing...';
      
      try {
        const { PublicKey, VoteProgram, Transaction, Connection } = solanaWeb3;
        const connection = new Connection(RPC_URL, 'confirmed');
        
        const votePubkey = new PublicKey(currentManageValidator.voteAccount);
        const authorizedPubkey = new PublicKey(walletPublicKey);
        const newAuthorizedPubkey = new PublicKey(newAuthority);
        
        let instruction;
        
        if (voteAuthorityType === 'vote') {
          // Change vote authority
          instruction = VoteProgram.authorize({
            votePubkey: votePubkey,
            authorizedPubkey: authorizedPubkey,
            newAuthorizedPubkey: newAuthorizedPubkey,
            voteAuthorizationType: { index: 0 } // 0 = Voter
          });
        } else {
          // Change withdraw authority
          instruction = VoteProgram.authorize({
            votePubkey: votePubkey,
            authorizedPubkey: authorizedPubkey,
            newAuthorizedPubkey: newAuthorizedPubkey,
            voteAuthorizationType: { index: 1 } // 1 = Withdrawer
          });
        }
        
        const transaction = new Transaction().add(instruction);
        
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = authorizedPubkey;
        
        btn.textContent = 'Sign Transaction...';
        showChangeVoteAuthorityMessage('Please approve the transaction in your wallet...', 'info');
        
        let signature;
        try {
          const signed = await connectedWallet.provider.signTransaction(transaction);
          signature = await connection.sendRawTransaction(signed.serialize(), {
            skipPreflight: false,
            preflightCommitment: 'confirmed'
          });
        } catch (signError) {
          if (signError.message?.includes('User rejected')) {
            throw new Error('Transaction cancelled by user.');
          }
          if (connectedWallet.provider.signAndSendTransaction) {
            const result = await connectedWallet.provider.signAndSendTransaction(transaction);
            signature = result.signature;
          } else {
            throw signError;
          }
        }
        
        btn.textContent = 'Confirming...';
        showChangeVoteAuthorityMessage('Transaction sent! Waiting for confirmation...', 'info');
        
        const confirmation = await connection.confirmTransaction({
          signature,
          blockhash,
          lastValidBlockHeight
        }, 'confirmed');
        
        if (confirmation.value.err) {
          throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
        }
        
        const typeLabel = voteAuthorityType === 'vote' ? 'Vote' : 'Withdraw';
        btn.textContent = 'Success!';
        btn.onclick = closeChangeVoteAuthorityModal;
        btn.disabled = false;
        document.getElementById('changeVoteAuthorityCancelBtn').textContent = 'Close';
        showChangeVoteAuthorityMessage(`${typeLabel} authority changed successfully! Signature: ${signature.slice(0, 20)}...`, 'success');
        
        // Refresh authorities display after a delay
        setTimeout(() => {
          fetchVoteAccountAuthorities();
        }, 2000);
        
      } catch (e) {
        console.error('Change vote authority error:', e);
        
        if (e.message?.includes('User rejected') || e.message?.includes('cancelled')) {
          showChangeVoteAuthorityMessage('Transaction cancelled by user.', 'error');
        } else {
          showChangeVoteAuthorityMessage(`Error: ${e.message || 'Transaction failed'}`, 'error');
        }
        
        btn.disabled = false;
        btn.textContent = 'Change Authority';
      }
    }

    // Event listeners
    document.getElementById('validatorModal').addEventListener('click', function(e) {
      if (e.target === this) closeValidatorList();
    });

    document.getElementById('manageValidatorModal').addEventListener('click', function(e) {
      if (e.target === this) closeManageValidator();
    });

    document.getElementById('searchInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') performSearch();
    });

    // Chart instances storage
    const chartInstances = {};
    
    // Color palette for multiple validators
    const chartColors = [
      { border: '#4da6ff', bg: 'rgba(77, 166, 255, 0.15)' },   // Blue
      { border: '#00e676', bg: 'rgba(0, 230, 118, 0.15)' },    // Green
      { border: '#ffab00', bg: 'rgba(255, 171, 0, 0.15)' },    // Orange
      { border: '#ff6b9d', bg: 'rgba(255, 107, 157, 0.15)' },  // Pink (more visible than red)
      { border: '#b388ff', bg: 'rgba(179, 136, 255, 0.15)' },  // Purple
      { border: '#00d4ff', bg: 'rgba(0, 212, 255, 0.15)' },    // Cyan
      { border: '#76ff03', bg: 'rgba(118, 255, 3, 0.15)' },    // Lime
      { border: '#ff6e40', bg: 'rgba(255, 110, 64, 0.15)' },   // Coral
    ];

    // Toggle stake details visibility and fetch data
    async function toggleStakeDetails(voteAccount, validatorName, totalStake, commission, button) {
      const section = document.getElementById('stake-' + voteAccount + '-section');
      const isExpanded = section.classList.contains('expanded');
      
      if (isExpanded) {
        section.classList.remove('expanded');
        button.classList.remove('expanded');
      } else {
        // Close the chart section if it's open (mutually exclusive)
        const chartId = 'chart-' + voteAccount.slice(0, 8);
        const chartSection = document.getElementById(chartId + '-section');
        if (chartSection && chartSection.classList.contains('expanded')) {
          chartSection.classList.remove('expanded');
          // Find and update the chart button
          const chartBtn = button.parentElement.querySelector('.validator-expand-btn:not(.stake-details-btn)');
          if (chartBtn) chartBtn.classList.remove('expanded');
        }
        
        section.classList.add('expanded');
        button.classList.add('expanded');
        
        // Check if already loaded
        if (section.dataset.loaded === 'true') {
          return;
        }
        
        // Show loading
        section.innerHTML = `
          <div class="stake-section-loading">
            <div class="loading-spinner-small"></div>
            <span>Analyzing stake accounts...</span>
          </div>
        `;
        
        // Check cache first
        const cached = stakeBreakdownCache[voteAccount];
        if (cached && cached.timestamp > Date.now() - 300000) {
          renderInlineStakeBreakdown(section, cached.data, validatorName, totalStake, commission, voteAccount);
          section.dataset.loaded = 'true';
          return;
        }
        
        // Add timeout for slow loading message
        const slowLoadingTimeout = setTimeout(() => {
          if (section.querySelector('.stake-section-loading')) {
            section.innerHTML = `
              <div class="stake-section-loading">
                <div class="loading-spinner-small"></div>
                <span>Still loading... RPC may be slow</span>
                <button onclick="cancelStakeLoad('${voteAccount}')" style="margin-top: 0.5rem; padding: 0.25rem 0.75rem; background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; color: var(--text-secondary); cursor: pointer; font-size: 0.75rem;">Cancel</button>
              </div>
            `;
          }
        }, 5000);
        
        try {
          // Helper function with timeout
          const fetchWithTimeout = async (url, options, timeout = 15000) => {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            try {
              const response = await fetch(url, { ...options, signal: controller.signal });
              clearTimeout(timeoutId);
              return response;
            } catch (err) {
              clearTimeout(timeoutId);
              throw err;
            }
          };
          
          // Fetch stake accounts
          const response = await fetchWithTimeout(RPC_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 1,
              method: 'getProgramAccounts',
              params: [
                'Stake11111111111111111111111111111111111111',
                {
                  encoding: 'jsonParsed',
                  filters: [
                    { memcmp: { offset: 124, bytes: voteAccount } }
                  ]
                }
              ]
            })
          });
          
          clearTimeout(slowLoadingTimeout);
          
          const data = await response.json();
          
          if (!data.result || data.result.length === 0) {
            section.innerHTML = `
              <div class="stake-section-loading">
                <span>No stake accounts found</span>
              </div>
            `;
            section.dataset.loaded = 'true';
            return;
          }
          
          // Update loading message
          section.innerHTML = `
            <div class="stake-section-loading">
              <div class="loading-spinner-small"></div>
              <span>Found ${data.result.length} accounts, analyzing rewards...</span>
            </div>
          `;
          
          // Always get fresh epoch info to ensure we use the last COMPLETED epoch
          const epochInfo = await rpcCall('getEpochInfo');
          currentEpochNumber = epochInfo.epoch;
          
          // Fetch rewards from last COMPLETED epoch (currentEpoch - 1)
          let rewards = [];
          try {
            const stakeAccountPubkeys = data.result.map(acc => acc.pubkey);
            const rewardsResponse = await fetchWithTimeout(RPC_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: '2.0',
                id: 1,
                method: 'getInflationReward',
                params: [stakeAccountPubkeys, { epoch: currentEpochNumber - 1 }]
              })
            }, 10000);
            
            const rewardsData = await rewardsResponse.json();
            rewards = rewardsData.result || [];
          } catch (rewardErr) {
            console.warn('Could not fetch rewards, using fallback:', rewardErr);
            // Continue without rewards - will use heuristic fallback
          }
          
          // If no rewards from epoch-1, try epoch-2
          const hasRewards = rewards.some(r => r && r.amount > 0);
          console.log('Epoch-1 rewards check:', { 
            epoch: currentEpochNumber - 1, 
            hasRewards, 
            rewardsCount: rewards.filter(r => r && r.amount > 0).length 
          });
          
          if (!hasRewards && currentEpochNumber > 2) {
            try {
              const stakeAccountPubkeys = data.result.map(acc => acc.pubkey);
              const rewards2Response = await fetchWithTimeout(RPC_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 1,
                  method: 'getInflationReward',
                  params: [stakeAccountPubkeys, { epoch: currentEpochNumber - 2 }]
                })
              }, 10000);
              
              const rewards2Data = await rewards2Response.json();
              if (rewards2Data.result) {
                rewards = rewards2Data.result;
                console.log('Using epoch-2 rewards for stake detection, epoch:', currentEpochNumber - 2);
              }
            } catch (e) {
              console.warn('Could not fetch epoch-2 rewards:', e);
            }
          }
          
          // Calculate rates and gather authority info
          const accountsWithRates = [];
          for (let i = 0; i < data.result.length; i++) {
            const acc = data.result[i];
            const stakeInfo = acc.account.data.parsed?.info;
            const stakeLamports = acc.account.lamports;
            const stakeXNT = stakeLamports / 1e9;
            const reward = rewards[i];
            const meta = stakeInfo?.meta;
            const staker = meta?.authorized?.staker || acc.pubkey;
            const withdrawer = meta?.authorized?.withdrawer || null;
            
            let rewardRate = 0;
            if (reward && reward.amount > 0 && stakeXNT > 0) {
              rewardRate = (reward.amount / 1e9) / stakeXNT;
            }
            
            accountsWithRates.push({
              pubkey: acc.pubkey,
              stakeXNT,
              rewardRate,
              staker,
              withdrawer,
              hasReward: reward && reward.amount > 0
            });
          }
          
          // Debug: Log all accounts and their rates
          console.log('Stake accounts analysis:', accountsWithRates.map(a => ({
            pubkey: a.pubkey.slice(0, 8) + '...',
            stakeXNT: a.stakeXNT.toFixed(2),
            rewardRate: (a.rewardRate * 100).toFixed(6) + '%',
            hasReward: a.hasReward
          })));
          
          // Classify accounts - prioritize user selections, then withdrawer matching
          let selfStake = 0;
          let delegatedStake = 0;
          const delegators = [];
          const selfStakeAccounts = [];
          let detectionMethod = 'withdrawer-match';
          
          // Check for user selections first (from Stake Selection modal)
          const userSelections = getSelfStakeSelections(voteAccount);
          
          if (userSelections && userSelections.pubkeys && userSelections.pubkeys.length > 0) {
            // Use user-selected self-stake accounts
            detectionMethod = 'user-selected';
            const selectedPubkeys = new Set(userSelections.pubkeys);
            
            for (const acc of accountsWithRates) {
              if (selectedPubkeys.has(acc.pubkey)) {
                selfStake += acc.stakeXNT;
                selfStakeAccounts.push({ pubkey: acc.pubkey, amount: acc.stakeXNT });
              } else {
                delegatedStake += acc.stakeXNT;
                delegators.push({ address: acc.staker, amount: acc.stakeXNT, pubkey: acc.pubkey });
              }
            }
          } else {
            // Auto-detect using withdrawer matching
            // Get vote account's authorized withdrawer
            let voteAccountWithdrawer = null;
            
            try {
              const voteAcctResponse = await fetchWithTimeout(RPC_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 1,
                  method: 'getAccountInfo',
                  params: [voteAccount, { encoding: 'jsonParsed' }]
                })
              }, 5000);
              
              const voteAcctData = await voteAcctResponse.json();
              if (voteAcctData.result?.value?.data?.parsed?.info) {
                voteAccountWithdrawer = voteAcctData.result.value.data.parsed.info.authorizedWithdrawer;
              }
            } catch (e) {
              console.warn('Could not fetch vote account withdrawer:', e);
            }
            
            if (voteAccountWithdrawer) {
              // Match stake account withdrawers against vote account withdrawer
              for (const acc of accountsWithRates) {
                if (acc.withdrawer === voteAccountWithdrawer) {
                  selfStake += acc.stakeXNT;
                  selfStakeAccounts.push({ pubkey: acc.pubkey, amount: acc.stakeXNT });
                } else {
                  delegatedStake += acc.stakeXNT;
                  delegators.push({ address: acc.staker, amount: acc.stakeXNT, pubkey: acc.pubkey });
                }
              }
            } else {
              // Fallback: treat all as delegated until configured
              detectionMethod = 'not-configured';
              for (const acc of accountsWithRates) {
                delegatedStake += acc.stakeXNT;
                delegators.push({ address: acc.staker, amount: acc.stakeXNT, pubkey: acc.pubkey });
              }
            }
          }
          
          // Debug: Log classification results
          console.log('Classification result:', {
            method: detectionMethod,
            selfStake: selfStake.toFixed(2) + ' XNT',
            delegatedStake: delegatedStake.toFixed(2) + ' XNT',
            selfStakeAccounts: selfStakeAccounts.length,
            delegatorAccounts: delegators.length
          });
          
          delegators.sort((a, b) => b.amount - a.amount);
          
          // Fetch validator's inflation rewards for multiple time periods
          let derivedBaseAPY = 8; // Default fallback
          let historicalAPY = {
            days7: null,
            days30: null,
            days90: null,
            days365: null
          };
          
          try {
            // Fetch up to 365 epochs (days) of rewards (vote account + self-stake)
            const validatorRewards = await fetchTotalValidatorRewards(voteAccount, commission, 365);
            
            if (validatorRewards && validatorRewards.length > 0) {
              // Calculate APY for different time periods
              const divisor = selfStake + (delegatedStake * commission / 100);
              
              const calcPeriodAPY = (days) => {
                const periodRewards = validatorRewards.slice(0, Math.min(days, validatorRewards.length));
                if (periodRewards.length < days * 0.8) return null; // Need at least 80% of expected data
                
                const totalRewardsXNT = periodRewards.reduce((sum, r) => sum + r.amount, 0) / 1e9;
                const avgDailyRewardsXNT = totalRewardsXNT / periodRewards.length;
                const annualizedRewards = avgDailyRewardsXNT * 365;
                
                // Derive baseAPY: annualRewards = baseAPY * (selfStake + delegatedStake * commission%)
                const baseAPY = divisor > 0 ? (annualizedRewards / divisor) * 100 : 8;
                
                // Calculate validator earnings using baseAPY (same as Staking Calculator)
                const selfEarnings = selfStake * (baseAPY / 100);
                const commEarnings = delegatedStake * (baseAPY / 100) * (commission / 100);
                const totalEarnings = selfEarnings + commEarnings;
                
                // Validator APY = total earnings / self-stake * 100
                const validatorAPY = selfStake > 0 ? (totalEarnings / selfStake) * 100 : baseAPY;
                
                return {
                  earnings: totalRewardsXNT,
                  epochCount: periodRewards.length,
                  avgDaily: avgDailyRewardsXNT,
                  validatorAPY: validatorAPY,
                  baseAPY: baseAPY
                };
              };
              
              historicalAPY.days7 = calcPeriodAPY(7);
              historicalAPY.days30 = calcPeriodAPY(30);
              historicalAPY.days90 = calcPeriodAPY(90);
              historicalAPY.days365 = calcPeriodAPY(365);
              
              // Use 7-day APY as the primary derived APY
              if (historicalAPY.days7) {
                derivedBaseAPY = historicalAPY.days7.baseAPY;
              }
            }
          } catch (e) {
            console.warn('Could not fetch validator rewards for APY calculation:', e);
          }
          
          const breakdownData = {
            selfStake,
            delegatedStake,
            totalStake: selfStake + delegatedStake,
            delegators,
            selfStakeAccounts,
            accountCount: data.result.length,
            detectionMethod: detectionMethod,
            derivedBaseAPY: derivedBaseAPY,
            historicalAPY: historicalAPY
          };
          
          // Cache
          stakeBreakdownCache[voteAccount] = { timestamp: Date.now(), data: breakdownData };
          
          // Store for calculator
          if (!window.stakeBreakdownData) window.stakeBreakdownData = {};
          window.stakeBreakdownData[voteAccount] = {
            selfStake,
            delegatedStake,
            total: selfStake + delegatedStake,
            commission,
            delegatorCount: delegators.length
          };
          
          renderInlineStakeBreakdown(section, breakdownData, validatorName, totalStake, commission, voteAccount);
          section.dataset.loaded = 'true';
          
        } catch (err) {
          console.error('Error fetching stake breakdown:', err);
          const errorMsg = err.name === 'AbortError' ? 'Request timed out' : 'Error loading data';
          section.innerHTML = `
            <div class="stake-section-loading">
              <span style="color: var(--danger);">${errorMsg}</span>
              <button onclick="retryStakeLoad('${voteAccount}')" style="margin-top: 0.5rem; padding: 0.25rem 0.75rem; background: var(--accent-cyan); border: none; border-radius: 4px; color: var(--bg-primary); cursor: pointer; font-size: 0.75rem; font-weight: 500;">Retry</button>
            </div>
          `;
        }
      }
    }
    
    function renderInlineStakeBreakdown(section, data, validatorName, totalStake, commission, voteAccount) {
      // Safely destructure with defaults
      if (!data) data = {};
      const selfStake = data.selfStake || 0;
      const delegatedStake = data.delegatedStake || 0;
      const delegators = Array.isArray(data.delegators) ? data.delegators : [];
      const selfStakeAccounts = Array.isArray(data.selfStakeAccounts) ? data.selfStakeAccounts : [];
      const accountCount = data.accountCount || 0;
      const detectionMethod = data.detectionMethod || 'unknown';
      const historicalAPY = data.historicalAPY || {};
      
      // Store historicalAPY globally for period selector
      if (!window.historicalAPYData) window.historicalAPYData = {};
      window.historicalAPYData[voteAccount] = historicalAPY;
      
      const total = selfStake + delegatedStake;
      const selfPercent = total > 0 ? (selfStake / total) * 100 : 0;
      const delegatedPercent = total > 0 ? (delegatedStake / total) * 100 : 0;
      
      // Pie chart calculations with minimum visual threshold
      const circumference = 2 * Math.PI * 35;
      const MIN_VISUAL_PERCENT = 12; // Minimum 12% visual display for visibility
      
      // Calculate visual percentages (for display only - labels show real values)
      let selfVisual = selfPercent;
      let delegatedVisual = delegatedPercent;
      
      // If both have values, ensure minimum visibility
      if (selfPercent > 0 && delegatedPercent > 0) {
        if (selfPercent < MIN_VISUAL_PERCENT) {
          selfVisual = MIN_VISUAL_PERCENT;
          delegatedVisual = 100 - MIN_VISUAL_PERCENT;
        } else if (delegatedPercent < MIN_VISUAL_PERCENT) {
          delegatedVisual = MIN_VISUAL_PERCENT;
          selfVisual = 100 - MIN_VISUAL_PERCENT;
        }
      }
      
      const selfDash = (selfVisual / 100) * circumference;
      const delegatedDash = (delegatedVisual / 100) * circumference;
      
      // Earnings calculations - use derived baseAPY if available
      const baseAPY = data.derivedBaseAPY || 8;
      const selfStakeEarnings = selfStake * (baseAPY / 100);
      const commissionEarnings = delegatedStake * (baseAPY / 100) * (commission / 100);
      const totalValidatorEarnings = selfStakeEarnings + commissionEarnings;
      
      // Calculate validator's effective APY (return on their self-stake investment)
      // APY = total earnings / self-stake (since they only invested their self-stake)
      const validatorAPY = selfStake > 0 ? (totalValidatorEarnings / selfStake) * 100 : baseAPY;
      
      const detectionNote = 
        detectionMethod === 'user-selected' ? 'Based on your selections' :
        detectionMethod === 'withdrawer-match' ? 'Auto-detected by withdrawer' :
        detectionMethod === 'not-configured' ? 'Click Active Stake to configure' :
        detectionMethod === 'reward-analysis' ? 'Detected by reward analysis' :
        detectionMethod === 'cached' ? 'Using cached detection' :
        detectionMethod === 'heuristic-0pct' ? 'Estimated (0% commission)' :
        'Estimated by stake size';
      
      // Build all accounts list (self-stake first, then delegated)
      const allAccounts = [];
      selfStakeAccounts.forEach(acc => {
        allAccounts.push({ ...acc, type: 'self', address: acc.pubkey });
      });
      delegators.forEach(acc => {
        allAccounts.push({ ...acc, type: 'delegated', address: acc.pubkey });
      });
      // Sort by amount descending
      allAccounts.sort((a, b) => b.amount - a.amount);
      
      const accountsListId = 'accounts-list-' + voteAccount.slice(0, 8);
      
      section.innerHTML = `
        <div class="stake-inline-content">
          ${commission === 0 ? `
          <div class="stake-inline-warning">
            <span></span>
            <div class="stake-inline-warning-text">
              <strong>0% Commission:</strong> Cannot distinguish self-stake from delegations. Values are estimates.
            </div>
          </div>
          ` : ''}
          
          <div class="stake-inline-pie-row">
            <div class="stake-inline-pie">
              <svg width="90" height="90" viewBox="0 0 90 90" style="transform: rotate(-90deg);">
                <circle cx="45" cy="45" r="35" fill="none" stroke="var(--bg-card)" stroke-width="10"/>
                <circle cx="45" cy="45" r="35" fill="none" stroke="var(--accent-cyan)" stroke-width="10"
                  stroke-dasharray="${selfDash} ${circumference}" stroke-linecap="round"/>
                <circle cx="45" cy="45" r="35" fill="none" stroke="var(--accent-gold)" stroke-width="10"
                  stroke-dasharray="${delegatedDash} ${circumference}" stroke-dashoffset="-${selfDash}" stroke-linecap="round"/>
              </svg>
            </div>
            <div class="stake-inline-stats">
              <div class="stake-inline-stat">
                <span class="stake-inline-stat-label"><span style="color: var(--accent-cyan);"></span> Self-Stake</span>
                <span class="stake-inline-stat-value">${formatNumber(selfStake, 0)} XNT <span style="color: var(--text-dim); font-size: 0.75rem;">(${formatNumber(selfPercent, 1)}%)</span></span>
              </div>
              <div class="stake-inline-stat">
                <span class="stake-inline-stat-label"><span style="color: var(--accent-gold);"></span> Delegated</span>
                <span class="stake-inline-stat-value">${formatNumber(delegatedStake, 0)} XNT <span style="color: var(--text-dim); font-size: 0.75rem;">(${formatNumber(delegatedPercent, 1)}%)</span></span>
              </div>
              <div class="stake-inline-stat stake-accounts-toggle" onclick="toggleAccountsList('${accountsListId}', this)">
                <span class="stake-inline-stat-label">Stake Accounts <span class="accounts-arrow"></span></span>
                <span class="stake-inline-stat-value">${accountCount} total</span>
              </div>
            </div>
          </div>
          
          <div class="stake-accounts-list" id="${accountsListId}">
            <div class="stake-accounts-list-inner">
              ${allAccounts.map(acc => `
                <div class="stake-account-item ${acc.type}">
                  <div class="stake-account-left">
                    <span class="stake-account-type-badge ${acc.type}">${acc.type === 'self' ? 'SELF' : 'DELEGATED'}</span>
                    <span class="stake-account-address">${acc.address.slice(0, 6)}...${acc.address.slice(-4)}</span>
                  </div>
                  <span class="stake-account-amount">${formatNumber(acc.amount, 0)} XNT</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="stake-inline-earnings">
            <div class="stake-inline-apy-display">
              <div class="stake-inline-apy-header">
                <div class="stake-inline-apy-label">Validator APY</div>
                <select class="stake-apy-period-select" onchange="updateAPYDisplay(this, '${voteAccount}')">
                  ${historicalAPY.days7 ? `<option value="7" selected>7-day avg</option>` : ''}
                  ${historicalAPY.days30 ? `<option value="30">30-day avg</option>` : ''}
                  ${historicalAPY.days90 ? `<option value="90">90-day avg</option>` : ''}
                  ${historicalAPY.days365 ? `<option value="365">1-year avg</option>` : ''}
                </select>
              </div>
              <div class="stake-inline-apy-value" id="apy-value-${voteAccount.slice(0,8)}">${historicalAPY.days7 ? formatNumber(historicalAPY.days7.validatorAPY, 2) : ''}%</div>
              <div class="stake-inline-apy-note">
                <span id="apy-earnings-${voteAccount.slice(0,8)}">${historicalAPY.days7 ? formatNumber(historicalAPY.days7.earnings, 2) + ' XNT earned' : ''}</span>
              </div>
            </div>
            
            <div class="stake-inline-earnings-title" style="margin-top: 1rem;">
               Est. Annual Validator Earnings (based on 7-day avg)
            </div>
            <div class="stake-inline-earnings-grid">
              <div class="stake-inline-earning">
                <div class="stake-inline-earning-value">${formatNumber(selfStakeEarnings, 0)} XNT</div>
                <div class="stake-inline-earning-label">From Self-Stake (${formatNumber(baseAPY, 1)}% base)</div>
              </div>
              <div class="stake-inline-earning">
                <div class="stake-inline-earning-value">${formatNumber(commissionEarnings, 0)} XNT</div>
                <div class="stake-inline-earning-label">From ${commission}% Commission</div>
              </div>
            </div>
            <div class="stake-inline-total">
              <span style="color: var(--text-secondary); font-size: 0.8rem;">Total: </span>
              <span style="color: var(--success); font-weight: 600; font-size: 1rem;">${formatNumber(totalValidatorEarnings, 0)} XNT/year</span>
            </div>
          </div>
          
          <div class="stake-inline-footer">
            <div class="stake-inline-note">${detectionNote}  Cached 5 min</div>
            <button class="stake-manage-btn" onclick="event.stopPropagation(); openStakeSelection('${voteAccount}', '${validatorName.replace(/'/g, "\\'")}')">
               Manage Classification
            </button>
          </div>
        </div>
      `;
    }
    
    function updateAPYDisplay(selectEl, voteAccount) {
      const period = selectEl.value;
      const historicalAPY = window.historicalAPYData && window.historicalAPYData[voteAccount];
      
      if (!historicalAPY) return;
      
      const periodKey = 'days' + period;
      const data = historicalAPY[periodKey];
      
      const apyValueEl = document.getElementById('apy-value-' + voteAccount.slice(0, 8));
      const earningsEl = document.getElementById('apy-earnings-' + voteAccount.slice(0, 8));
      
      if (data && apyValueEl && earningsEl) {
        apyValueEl.textContent = formatNumber(data.validatorAPY, 2) + '%';
        earningsEl.textContent = formatNumber(data.earnings, 2) + ' XNT earned';
      }
    }
    
    function cancelStakeLoad(voteAccount) {
      const section = document.getElementById('stake-' + voteAccount + '-section');
      if (section) {
        section.innerHTML = `
          <div class="stake-section-loading">
            <span>Loading cancelled</span>
            <button onclick="retryStakeLoad('${voteAccount}')" style="margin-top: 0.5rem; padding: 0.25rem 0.75rem; background: var(--accent-cyan); border: none; border-radius: 4px; color: var(--bg-primary); cursor: pointer; font-size: 0.75rem; font-weight: 500;">Retry</button>
          </div>
        `;
        section.dataset.loaded = 'cancelled';
      }
    }
    
    function retryStakeLoad(voteAccount) {
      const section = document.getElementById('stake-' + voteAccount + '-section');
      if (section) {
        section.dataset.loaded = '';
        // Find the button and trigger click
        const card = section.closest('.validator-card');
        if (card) {
          const btn = card.querySelector('.stake-details-btn');
          if (btn) {
            btn.classList.remove('expanded');
            section.classList.remove('expanded');
            btn.click();
          }
        }
      }
    }

    function toggleAccountsList(listId, toggleEl) {
      const list = document.getElementById(listId);
      const isExpanded = list.classList.contains('expanded');
      
      if (isExpanded) {
        list.classList.remove('expanded');
        toggleEl.classList.remove('expanded');
      } else {
        list.classList.add('expanded');
        toggleEl.classList.add('expanded');
      }
    }

    // Toggle chart visibility and initialize
    async function toggleChart(chartId, button) {
      const section = document.getElementById(chartId + '-section');
      const isExpanded = section.classList.contains('expanded');
      
      if (isExpanded) {
        section.classList.remove('expanded');
        button.classList.remove('expanded');
      } else {
        // Close the stake details section if it's open (mutually exclusive)
        const stakeSection = section.previousElementSibling;
        if (stakeSection && stakeSection.classList.contains('validator-stake-section') && stakeSection.classList.contains('expanded')) {
          stakeSection.classList.remove('expanded');
          // Find and update the stake details button
          const stakeBtn = button.parentElement.querySelector('.stake-details-btn');
          if (stakeBtn) stakeBtn.classList.remove('expanded');
        }
        
        section.classList.add('expanded');
        button.classList.add('expanded');
        
        // Initialize chart if not already done
        if (!chartInstances[chartId] && window.chartDataStore && window.chartDataStore[chartId]) {
          const data = window.chartDataStore[chartId];
          const loadingEl = document.getElementById(chartId + '-loading');
          
          // Store original credits data before fetching XNT
          data.creditsLabels = data.labels;
          data.creditsData = data.data;
          
          // Show loading while fetching XNT data
          if (loadingEl) loadingEl.style.display = 'flex';
          
          // Fetch XNT rewards data (vote account + self-stake rewards)
          const rewards = await fetchTotalValidatorRewards(data.voteAccount, data.commission, 30);
          
          if (rewards && rewards.length > 0) {
            // Sort by epoch (fetchInflationRewards already excludes current epoch)
            const sortedRewards = rewards.sort((a, b) => a.epoch - b.epoch);
            
            const xntLabels = [];
            const xntData = [];
            
            sortedRewards.slice(-30).forEach(r => {
              xntLabels.push(r.epoch);
              xntData.push(r.amount / 1e9);
            });
            
            if (xntData.length > 0) {
              // Store XNT data separately
              data.xntLabels = xntLabels;
              data.xntData = xntData;
              
              // Set current display to XNT
              data.labels = xntLabels;
              data.data = xntData;
              data.type = 'xnt';
              
              // Update title and subtitle
              const titleEl = document.getElementById(chartId + '-title');
              const subtitleEl = document.getElementById(chartId + '-subtitle');
              const lastEl = document.getElementById(chartId + '-last');
              const avgEl = document.getElementById(chartId + '-avg');
              const peakEl = document.getElementById(chartId + '-peak');
              
              if (titleEl) titleEl.textContent = 'XNT Rewards Trend';
              if (subtitleEl) subtitleEl.textContent = `XNT earned per epoch (last ${xntLabels.length} epochs)`;
              if (lastEl) lastEl.textContent = formatNumber(xntData[xntData.length - 1], 2) + ' XNT';
              if (avgEl) avgEl.textContent = formatNumber(xntData.reduce((a, b) => a + b, 0) / xntData.length, 2) + ' XNT';
              if (peakEl) peakEl.textContent = formatNumber(Math.max(...xntData), 2) + ' XNT';
            }
          }
          
          // Hide loading
          if (loadingEl) loadingEl.style.display = 'none';
          
          // Now initialize the chart with the data we have
          initializeChart(chartId);
        }
      }
    }

    // Switch chart between Epoch Credits and XNT Rewards
    async function switchChartType(chartId, type, button) {
      const data = window.chartDataStore[chartId];
      if (!data) return;
      
      // Update button states
      const container = button.parentElement;
      container.querySelectorAll('.chart-toggle-btn').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      
      // Get elements
      const titleEl = document.getElementById(chartId + '-title');
      const subtitleEl = document.getElementById(chartId + '-subtitle');
      const lastEl = document.getElementById(chartId + '-last');
      const avgEl = document.getElementById(chartId + '-avg');
      const peakEl = document.getElementById(chartId + '-peak');
      const loadingEl = document.getElementById(chartId + '-loading');
      const statsEl = document.getElementById(chartId + '-stats');
      
      if (type === 'xnt') {
        // Check if we already have XNT data stored
        if (data.xntLabels && data.xntData && data.xntData.length > 0) {
          // Use stored XNT data
          const labels = data.xntLabels;
          const xntData = data.xntData;
          
          if (chartInstances[chartId]) {
            chartInstances[chartId].data.labels = labels;
            chartInstances[chartId].data.datasets[0].data = xntData;
            chartInstances[chartId].options.scales.y.ticks.callback = (value) => value.toFixed(2) + ' XNT';
            chartInstances[chartId].update();
          }
          
          if (titleEl) titleEl.textContent = 'XNT Rewards Trend';
          if (subtitleEl) subtitleEl.textContent = `XNT earned per epoch (last ${labels.length} epochs)`;
          if (lastEl) lastEl.textContent = formatNumber(xntData[xntData.length - 1], 2) + ' XNT';
          if (avgEl) avgEl.textContent = formatNumber(xntData.reduce((a, b) => a + b, 0) / xntData.length, 2) + ' XNT';
          if (peakEl) peakEl.textContent = formatNumber(Math.max(...xntData), 2) + ' XNT';
        } else {
          // Show loading and fetch
          if (loadingEl) loadingEl.style.display = 'flex';
          if (statsEl) statsEl.style.opacity = '0.5';
          
          // Fetch XNT rewards data (vote account + self-stake rewards)
          const rewards = await fetchTotalValidatorRewards(data.voteAccount, data.commission, 30);
          
          if (rewards.length > 0) {
            const labels = rewards.map(r => r.epoch);
            const xntData = rewards.map(r => r.amount / 1e9);
            
            // Store for later use
            data.xntLabels = labels;
            data.xntData = xntData;
            
            if (chartInstances[chartId]) {
              chartInstances[chartId].data.labels = labels;
              chartInstances[chartId].data.datasets[0].data = xntData;
              chartInstances[chartId].options.scales.y.ticks.callback = (value) => value.toFixed(2) + ' XNT';
              chartInstances[chartId].update();
            }
            
            if (titleEl) titleEl.textContent = 'XNT Rewards Trend';
            if (subtitleEl) subtitleEl.textContent = `XNT earned per epoch (last ${labels.length} epochs)`;
            if (lastEl) lastEl.textContent = formatNumber(xntData[xntData.length - 1], 2) + ' XNT';
            if (avgEl) avgEl.textContent = formatNumber(xntData.reduce((a, b) => a + b, 0) / xntData.length, 2) + ' XNT';
            if (peakEl) peakEl.textContent = formatNumber(Math.max(...xntData), 2) + ' XNT';
          } else {
            if (titleEl) titleEl.textContent = 'XNT Rewards Trend';
            if (subtitleEl) subtitleEl.textContent = 'No rewards data available';
            if (lastEl) lastEl.textContent = '--';
            if (avgEl) avgEl.textContent = '--';
            if (peakEl) peakEl.textContent = '--';
          }
          
          if (loadingEl) loadingEl.style.display = 'none';
          if (statsEl) statsEl.style.opacity = '1';
        }
        
      } else {
        // Switch to epoch credits - use stored credits data
        const labels = data.creditsLabels || data.labels;
        const creditsData = data.creditsData || data.data;
        
        // Update chart
        if (chartInstances[chartId]) {
          chartInstances[chartId].data.labels = labels;
          chartInstances[chartId].data.datasets[0].data = creditsData;
          chartInstances[chartId].options.scales.y.ticks.callback = (value) => {
            if (value >= 1e6) return (value / 1e6).toFixed(1) + 'M';
            if (value >= 1e3) return (value / 1e3).toFixed(0) + 'K';
            return value;
          };
          chartInstances[chartId].update();
        }
        
        // Update UI
        if (titleEl) titleEl.textContent = 'Epoch Credits Trend';
        if (subtitleEl) subtitleEl.textContent = `Credits earned per epoch (last ${labels.length} epochs)`;
        if (lastEl) lastEl.textContent = creditsData.length > 0 ? formatNumber(creditsData[creditsData.length - 1], 0) : '--';
        if (avgEl) avgEl.textContent = creditsData.length > 0 ? formatNumber(creditsData.reduce((a, b) => a + b, 0) / creditsData.length, 0) : '--';
        if (peakEl) peakEl.textContent = creditsData.length > 0 ? formatNumber(Math.max(...creditsData), 0) : '--';
      }
    }

    // Switch combined chart between Epoch Credits and XNT Rewards
    async function switchCombinedChartType(type, button) {
      const validators = window.combinedChartValidators;
      if (!validators || validators.length === 0) return;
      
      // Update button states
      const container = button.parentElement;
      container.querySelectorAll('.chart-toggle-btn').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      
      // Get elements
      const titleEl = document.getElementById('combinedChart-title');
      const subtitleEl = document.getElementById('combinedChart-subtitle');
      const loadingEl = document.getElementById('combinedChart-loading');
      const legendEl = document.getElementById('combinedChartLegend');
      
      if (type === 'xnt') {
        // Show loading
        if (loadingEl) loadingEl.style.display = 'flex';
        
        // Fetch XNT rewards for all validators (vote account + self-stake) in parallel
        const allRewards = {};
        const allEpochs = new Set();
        
        const fetchValidatorRewards = async (validator) => {
          try {
            const rewards = await fetchTotalValidatorRewards(validator.voteAccount, validator.commission, 30);
            return { voteAccount: validator.voteAccount, name: validator.name, rewards: rewards || [] };
          } catch (e) {
            console.error(`Error fetching rewards for ${validator.name}:`, e);
            return { voteAccount: validator.voteAccount, name: validator.name, rewards: [] };
          }
        };
        
        let rewardResults = await Promise.all(validators.map(fetchValidatorRewards));
        
        // Check for validators that didn't return data and retry them
        const missingValidators = rewardResults.filter(r => !r.rewards || r.rewards.length === 0);
        if (missingValidators.length > 0 && missingValidators.length < validators.length) {
          console.log(`Retrying ${missingValidators.length} validators that didn't return data...`);
          await new Promise(resolve => setTimeout(resolve, 500));
          
          const retryResults = await Promise.all(
            missingValidators.map(m => {
              const validator = validators.find(v => v.voteAccount === m.voteAccount);
              return fetchValidatorRewards(validator);
            })
          );
          
          retryResults.forEach(retryResult => {
            const idx = rewardResults.findIndex(r => r.voteAccount === retryResult.voteAccount);
            if (idx !== -1 && retryResult.rewards && retryResult.rewards.length > 0) {
              rewardResults[idx] = retryResult;
            }
          });
        }
        
        // Process results
        rewardResults.forEach(result => {
          if (result.rewards && result.rewards.length > 0) {
            allRewards[result.voteAccount] = {};
            result.rewards.forEach(r => {
              allRewards[result.voteAccount][r.epoch] = r.amount / 1e9;
              allEpochs.add(r.epoch);
            });
          }
        });
        
        // Sort epochs (fetchInflationRewards already excludes current epoch)
        let sortedEpochs = Array.from(allEpochs).sort((a, b) => a - b);
        sortedEpochs = sortedEpochs.slice(-30);
        
        // Build datasets
        const datasets = [];
        const legendHtml = [];
        let maxValue = 0;
        
        validators.forEach((validator, index) => {
          const color = chartColors[index % chartColors.length];
          const dataMap = allRewards[validator.voteAccount] || {};
          const data = sortedEpochs.map(epoch => dataMap[epoch] !== undefined ? dataMap[epoch] : null);
          
          // Track max value for dynamic stepSize
          data.forEach(v => { if (v !== null && v > maxValue) maxValue = v; });
          
          datasets.push({
            label: validator.name,
            data: data,
            borderColor: color.border,
            backgroundColor: color.bg,
            borderWidth: 2,
            fill: false,
            tension: 0.4,
            pointBackgroundColor: color.border,
            pointBorderColor: color.border,
            pointRadius: 2,
            pointHoverRadius: 5,
            spanGaps: true
          });
          
          legendHtml.push(`
            <div class="chart-legend-item">
              <div class="chart-legend-color" style="background: ${color.border}"></div>
              <span>${validator.name}</span>
            </div>
          `);
        });
        
        // Calculate appropriate stepSize based on data range
        let stepSize = 2;
        if (maxValue > 100) stepSize = 20;
        else if (maxValue > 50) stepSize = 10;
        else if (maxValue > 20) stepSize = 5;
        
        // Update chart
        if (chartInstances['combinedChart']) {
          chartInstances['combinedChart'].data.labels = sortedEpochs;
          chartInstances['combinedChart'].data.datasets = datasets;
          chartInstances['combinedChart'].options.scales.y.ticks.stepSize = stepSize;
          chartInstances['combinedChart'].options.scales.y.ticks.callback = (value) => value.toFixed(2) + ' XNT';
          chartInstances['combinedChart'].update();
        }
        
        // Update UI
        if (titleEl) titleEl.textContent = 'Combined XNT Rewards Trend';
        if (subtitleEl) subtitleEl.textContent = `XNT earned per epoch for all validators`;
        if (legendEl) legendEl.innerHTML = legendHtml.join('');
        
        // Hide loading
        if (loadingEl) loadingEl.style.display = 'none';
        
      } else {
        // Switch back to epoch credits - reinitialize the combined chart
        if (chartInstances['combinedChart']) {
          chartInstances['combinedChart'].destroy();
          delete chartInstances['combinedChart'];
        }
        initializeCombinedChart();
        
        // Update UI
        if (titleEl) titleEl.textContent = 'Combined Epoch Credits Trend';
        if (subtitleEl) subtitleEl.textContent = 'Credits earned per completed epoch for all validators';
      }
    }

    // Toggle combined stake details for all portfolio validators
    async function toggleCombinedStakeDetails(button) {
      const section = document.getElementById('combinedStakeContainer');
      const isExpanded = section.classList.contains('expanded');
      
      if (isExpanded) {
        section.classList.remove('expanded');
        button.classList.remove('expanded');
      } else {
        // Close the combined chart if it's open (mutually exclusive)
        const chartSection = document.getElementById('combinedChartContainer');
        if (chartSection && chartSection.classList.contains('expanded')) {
          chartSection.classList.remove('expanded');
          const chartBtn = button.parentElement.querySelector('.validator-expand-btn:not(.stake-details-btn)');
          if (chartBtn) chartBtn.classList.remove('expanded');
        }
        
        section.classList.add('expanded');
        button.classList.add('expanded');
        
        // Check if already loaded
        if (section.dataset.loaded === 'true') {
          return;
        }
        
        // Show loading
        section.innerHTML = `
          <div class="stake-section-loading">
            <div class="loading-spinner-small"></div>
            <span>Loading stake breakdown for all validators...</span>
          </div>
        `;
        
        try {
          // Get all portfolio validators
          const portfolioValidators = myPortfolio;
          if (!portfolioValidators || portfolioValidators.length === 0) {
            section.innerHTML = `
              <div class="stake-section-loading">
                <span>No validators in portfolio</span>
              </div>
            `;
            return;
          }
          
          // Aggregate data from all validators
          let totalSelfStake = 0;
          let totalDelegatedStake = 0;
          let totalSelfStakeEarnings = 0;
          let totalCommissionEarnings = 0;
          let totalAccounts = 0;
          const validatorBreakdowns = [];
          
          // Always get fresh epoch info to ensure we use the last COMPLETED epoch
          const epochInfo = await rpcCall('getEpochInfo');
          currentEpochNumber = epochInfo.epoch;
          
          for (const voteAccount of portfolioValidators) {
            // Check cache first
            let breakdownData = stakeBreakdownCache[voteAccount]?.data;
            
            if (!breakdownData || stakeBreakdownCache[voteAccount].timestamp < Date.now() - 300000) {
              // Fetch fresh data
              try {
                const response = await fetch(RPC_URL, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getProgramAccounts',
                    params: [
                      'Stake11111111111111111111111111111111111111',
                      { encoding: 'jsonParsed', filters: [{ memcmp: { offset: 124, bytes: voteAccount } }] }
                    ]
                  })
                });
                
                const data = await response.json();
                if (!data.result || data.result.length === 0) continue;
                
                // Get commission
                let commission = 0;
                if (validatorInfoCache[voteAccount]) {
                  commission = validatorInfoCache[voteAccount].commission || 0;
                }
                
                // Fetch rewards from epoch-1
                const stakeAccountPubkeys = data.result.map(acc => acc.pubkey);
                let rewards = [];
                
                try {
                  const rewardsResponse = await fetch(RPC_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      jsonrpc: '2.0',
                      id: 1,
                      method: 'getInflationReward',
                      params: [stakeAccountPubkeys, { epoch: currentEpochNumber - 1 }]
                    })
                  });
                  
                  const rewardsData = await rewardsResponse.json();
                  rewards = rewardsData.result || [];
                } catch (e) {
                  console.warn('Could not fetch epoch-1 rewards:', e);
                }
                
                // If no rewards from epoch-1, try epoch-2
                const hasRewards = rewards.some(r => r && r.amount > 0);
                if (!hasRewards && currentEpochNumber > 2) {
                  try {
                    const rewards2Response = await fetch(RPC_URL, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getInflationReward',
                        params: [stakeAccountPubkeys, { epoch: currentEpochNumber - 2 }]
                      })
                    });
                    
                    const rewards2Data = await rewards2Response.json();
                    if (rewards2Data.result) {
                      rewards = rewards2Data.result;
                    }
                  } catch (e) {
                    // Continue without epoch-2 rewards
                  }
                }
                
                // Build account list with withdrawer info
                const accountsWithRates = [];
                for (let i = 0; i < data.result.length; i++) {
                  const acc = data.result[i];
                  const stakeInfo = acc.account.data.parsed?.info;
                  const stakeLamports = acc.account.lamports;
                  const stakeXNT = stakeLamports / 1e9;
                  const meta = stakeInfo?.meta;
                  const withdrawer = meta?.authorized?.withdrawer || null;
                  accountsWithRates.push({ pubkey: acc.pubkey, stakeXNT, withdrawer });
                }
                
                // Classify using user selections first, then withdrawer matching
                let selfStake = 0, delegatedStake = 0;
                const userSelections = getSelfStakeSelections(voteAccount);
                
                if (userSelections && userSelections.pubkeys && userSelections.pubkeys.length > 0) {
                  const selectedPubkeys = new Set(userSelections.pubkeys);
                  accountsWithRates.forEach(acc => {
                    if (selectedPubkeys.has(acc.pubkey)) {
                      selfStake += acc.stakeXNT;
                    } else {
                      delegatedStake += acc.stakeXNT;
                    }
                  });
                } else {
                  // Auto-detect using withdrawer matching
                  let voteAccountWithdrawer = null;
                  
                  try {
                    const voteAcctResponse = await fetch(RPC_URL, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getAccountInfo',
                        params: [voteAccount, { encoding: 'jsonParsed' }]
                      })
                    });
                    
                    const voteAcctData = await voteAcctResponse.json();
                    if (voteAcctData.result?.value?.data?.parsed?.info) {
                      voteAccountWithdrawer = voteAcctData.result.value.data.parsed.info.authorizedWithdrawer;
                    }
                  } catch (e) {
                    // Continue without vote account info
                  }
                  
                  if (voteAccountWithdrawer) {
                    accountsWithRates.forEach(acc => {
                      if (acc.withdrawer === voteAccountWithdrawer) {
                        selfStake += acc.stakeXNT;
                      } else {
                        delegatedStake += acc.stakeXNT;
                      }
                    });
                  } else {
                    // Fallback: treat all as delegated
                    accountsWithRates.forEach(acc => {
                      delegatedStake += acc.stakeXNT;
                    });
                  }
                }
                
                breakdownData = { selfStake, delegatedStake, accountCount: data.result.length, commission };
                stakeBreakdownCache[voteAccount] = { timestamp: Date.now(), data: breakdownData };
              } catch (e) {
                console.error('Error fetching breakdown for', voteAccount, e);
                continue;
              }
            }
            
            if (breakdownData) {
              const commission = breakdownData.commission || validatorInfoCache[voteAccount]?.commission || 0;
              const baseAPY = breakdownData.derivedBaseAPY || 0.08 * 100; // Use derived if available, else 8%
              const baseRate = baseAPY / 100;
              
              totalSelfStake += breakdownData.selfStake || 0;
              totalDelegatedStake += breakdownData.delegatedStake || 0;
              totalAccounts += breakdownData.accountCount || 0;
              totalSelfStakeEarnings += (breakdownData.selfStake || 0) * baseRate;
              totalCommissionEarnings += (breakdownData.delegatedStake || 0) * baseRate * (commission / 100);
              
              // Get validator name
              let name = voteAccount.slice(0, 8) + '...';
              if (validatorInfoCache[voteAccount]) {
                name = validatorInfoCache[voteAccount].name || name;
              }
              
              validatorBreakdowns.push({
                voteAccount,
                name,
                selfStake: breakdownData.selfStake || 0,
                delegatedStake: breakdownData.delegatedStake || 0,
                commission,
                baseAPY: breakdownData.derivedBaseAPY || 8
              });
            }
          }
          
          // Render combined breakdown
          renderCombinedStakeBreakdown(section, {
            totalSelfStake,
            totalDelegatedStake,
            totalSelfStakeEarnings,
            totalCommissionEarnings,
            totalAccounts,
            validatorBreakdowns,
            validatorCount: portfolioValidators.length
          });
          
          section.dataset.loaded = 'true';
          
        } catch (err) {
          console.error('Error loading combined stake breakdown:', err);
          section.innerHTML = `
            <div class="stake-section-loading">
              <span style="color: var(--danger);">Error loading stake details</span>
            </div>
          `;
        }
      }
    }
    
    function renderCombinedStakeBreakdown(section, data) {
      const { totalSelfStake, totalDelegatedStake, totalSelfStakeEarnings, totalCommissionEarnings, totalAccounts, validatorBreakdowns, validatorCount } = data;
      const total = totalSelfStake + totalDelegatedStake;
      const selfPercent = total > 0 ? (totalSelfStake / total) * 100 : 0;
      const delegatedPercent = total > 0 ? (totalDelegatedStake / total) * 100 : 0;
      const totalEarnings = totalSelfStakeEarnings + totalCommissionEarnings;
      
      // Calculate portfolio APY (return on self-stake investment)
      const portfolioAPY = totalSelfStake > 0 ? (totalEarnings / totalSelfStake) * 100 : 8;
      
      // Pie chart with minimum visual threshold
      const circumference = 2 * Math.PI * 35;
      const MIN_VISUAL_PERCENT = 12;
      let selfVisual = selfPercent, delegatedVisual = delegatedPercent;
      if (selfPercent > 0 && delegatedPercent > 0) {
        if (selfPercent < MIN_VISUAL_PERCENT) {
          selfVisual = MIN_VISUAL_PERCENT;
          delegatedVisual = 100 - MIN_VISUAL_PERCENT;
        } else if (delegatedPercent < MIN_VISUAL_PERCENT) {
          delegatedVisual = MIN_VISUAL_PERCENT;
          selfVisual = 100 - MIN_VISUAL_PERCENT;
        }
      }
      const selfDash = (selfVisual / 100) * circumference;
      const delegatedDash = (delegatedVisual / 100) * circumference;
      
      section.innerHTML = `
        <div class="stake-inline-content">
          <div class="stake-inline-pie-row">
            <div class="stake-inline-pie">
              <svg width="90" height="90" viewBox="0 0 90 90" style="transform: rotate(-90deg);">
                <circle cx="45" cy="45" r="35" fill="none" stroke="var(--bg-card)" stroke-width="10"/>
                <circle cx="45" cy="45" r="35" fill="none" stroke="var(--accent-cyan)" stroke-width="10"
                  stroke-dasharray="${selfDash} ${circumference}" stroke-linecap="round"/>
                <circle cx="45" cy="45" r="35" fill="none" stroke="var(--accent-gold)" stroke-width="10"
                  stroke-dasharray="${delegatedDash} ${circumference}" stroke-dashoffset="-${selfDash}" stroke-linecap="round"/>
              </svg>
            </div>
            <div class="stake-inline-stats">
              <div class="stake-inline-stat">
                <span class="stake-inline-stat-label"><span style="color: var(--accent-cyan);"></span> Total Self-Stake</span>
                <span class="stake-inline-stat-value">${formatNumber(totalSelfStake, 0)} XNT <span style="color: var(--text-dim); font-size: 0.75rem;">(${formatNumber(selfPercent, 1)}%)</span></span>
              </div>
              <div class="stake-inline-stat">
                <span class="stake-inline-stat-label"><span style="color: var(--accent-gold);"></span> Total Delegated</span>
                <span class="stake-inline-stat-value">${formatNumber(totalDelegatedStake, 0)} XNT <span style="color: var(--text-dim); font-size: 0.75rem;">(${formatNumber(delegatedPercent, 1)}%)</span></span>
              </div>
              <div class="stake-inline-stat">
                <span class="stake-inline-stat-label">Validators / Accounts</span>
                <span class="stake-inline-stat-value">${validatorCount} / ${totalAccounts}</span>
              </div>
            </div>
          </div>
          
          <div class="stake-inline-earnings">
            <div class="stake-inline-apy-display">
              <div class="stake-inline-apy-label">Portfolio APY (7-day avg)</div>
              <div class="stake-inline-apy-value">${formatNumber(portfolioAPY, 2)}%</div>
              <div class="stake-inline-apy-note">Effective return on total self-stake</div>
            </div>
            <div class="stake-inline-earnings-title">
               Est. Annual Combined Earnings
            </div>
            <div class="stake-inline-earnings-grid">
              <div class="stake-inline-earning">
                <div class="stake-inline-earning-value">${formatNumber(totalSelfStakeEarnings, 0)} XNT</div>
                <div class="stake-inline-earning-label">From Self-Stake (8% base)</div>
              </div>
              <div class="stake-inline-earning">
                <div class="stake-inline-earning-value">${formatNumber(totalCommissionEarnings, 0)} XNT</div>
                <div class="stake-inline-earning-label">From Commission</div>
              </div>
            </div>
            <div class="stake-inline-total">
              <span style="color: var(--text-secondary); font-size: 0.8rem;">Total: </span>
              <span style="color: var(--success); font-weight: 600; font-size: 1rem;">${formatNumber(totalEarnings, 0)} XNT/year</span>
            </div>
          </div>
          
          ${validatorBreakdowns.length > 0 ? `
          <div class="stake-inline-delegators">
            <div class="stake-inline-delegators-header">
              <span class="stake-inline-delegators-title"> Per Validator Breakdown</span>
            </div>
            ${validatorBreakdowns.map(v => {
              const baseRate = (v.baseAPY || 8) / 100;
              const vSelfEarnings = v.selfStake * baseRate;
              const vCommEarnings = v.delegatedStake * baseRate * (v.commission / 100);
              const vTotalEarnings = vSelfEarnings + vCommEarnings;
              const vAPY = v.selfStake > 0 ? (vTotalEarnings / v.selfStake) * 100 : (v.baseAPY || 8);
              return `
              <div class="stake-inline-delegator" style="flex-direction: column; align-items: flex-start; gap: 0.25rem;">
                <div style="display: flex; justify-content: space-between; width: 100%;">
                  <span style="font-weight: 500; color: var(--text-primary);">${v.name}</span>
                  <span style="font-weight: 600; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">${formatNumber(vAPY, 1)}%</span>
                </div>
                <div style="display: flex; gap: 1rem; font-size: 0.7rem;">
                  <span><span style="color: var(--accent-cyan);"></span> Self: ${formatNumber(v.selfStake, 0)}</span>
                  <span><span style="color: var(--accent-gold);"></span> Del: ${formatNumber(v.delegatedStake, 0)}</span>
                  <span style="color: var(--text-dim);">${v.commission}% comm</span>
                </div>
              </div>
            `}).join('')}
          </div>
          ` : ''}
          
          <div class="stake-inline-note">Aggregated from ${validatorCount} validators  Cached 5 min</div>
        </div>
      `;
    }

    // Toggle combined chart
    async function toggleCombinedChart(button) {
      const section = document.getElementById('combinedChartContainer');
      const isExpanded = section.classList.contains('expanded');
      
      if (isExpanded) {
        section.classList.remove('expanded');
        button.classList.remove('expanded');
      } else {
        // Close the combined stake details if it's open (mutually exclusive)
        const stakeSection = document.getElementById('combinedStakeContainer');
        if (stakeSection && stakeSection.classList.contains('expanded')) {
          stakeSection.classList.remove('expanded');
          const stakeBtn = button.parentElement.querySelector('.stake-details-btn');
          if (stakeBtn) stakeBtn.classList.remove('expanded');
        }
        
        section.classList.add('expanded');
        button.classList.add('expanded');
        
        // Initialize combined chart if not already done
        if (!chartInstances['combinedChart'] && window.combinedChartValidators) {
          const loadingEl = document.getElementById('combinedChart-loading');
          const titleEl = document.getElementById('combinedChart-title');
          const subtitleEl = document.getElementById('combinedChart-subtitle');
          
          // Show loading
          if (loadingEl) loadingEl.style.display = 'flex';
          
          // Fetch XNT rewards for all validators (vote account + self-stake) in parallel
          const validators = window.combinedChartValidators;
          const allRewards = {};
          const allEpochs = new Set();
          
          // Fetch all validators in parallel for better reliability
          const fetchValidatorRewards = async (validator) => {
            try {
              const rewards = await fetchTotalValidatorRewards(validator.voteAccount, validator.commission, 30);
              return { voteAccount: validator.voteAccount, name: validator.name, rewards: rewards || [] };
            } catch (e) {
              console.error(`Error fetching rewards for ${validator.name}:`, e);
              return { voteAccount: validator.voteAccount, name: validator.name, rewards: [] };
            }
          };
          
          let rewardResults = await Promise.all(validators.map(fetchValidatorRewards));
          
          // Check for validators that didn't return data and retry them
          const missingValidators = rewardResults.filter(r => !r.rewards || r.rewards.length === 0);
          if (missingValidators.length > 0 && missingValidators.length < validators.length) {
            console.log(`Retrying ${missingValidators.length} validators that didn't return data...`);
            // Small delay before retry
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const retryResults = await Promise.all(
              missingValidators.map(m => {
                const validator = validators.find(v => v.voteAccount === m.voteAccount);
                return fetchValidatorRewards(validator);
              })
            );
            
            // Merge retry results
            retryResults.forEach(retryResult => {
              const idx = rewardResults.findIndex(r => r.voteAccount === retryResult.voteAccount);
              if (idx !== -1 && retryResult.rewards && retryResult.rewards.length > 0) {
                rewardResults[idx] = retryResult;
              }
            });
          }
          
          // Process results
          rewardResults.forEach(result => {
            if (result.rewards && result.rewards.length > 0) {
              allRewards[result.voteAccount] = {};
              result.rewards.forEach(r => {
                allRewards[result.voteAccount][r.epoch] = r.amount / 1e9;
                allEpochs.add(r.epoch);
              });
            }
          });
          
          // Sort epochs (fetchInflationRewards already excludes current epoch)
          let sortedEpochs = Array.from(allEpochs).sort((a, b) => a - b);
          sortedEpochs = sortedEpochs.slice(-30);
          
          // Store for chart initialization
          window.combinedChartXNTData = {
            epochs: sortedEpochs,
            rewards: allRewards,
            hasData: Object.keys(allRewards).length > 0
          };
          
          // Update title
          if (titleEl) titleEl.textContent = 'Combined XNT Rewards Trend';
          if (subtitleEl) subtitleEl.textContent = 'XNT earned per completed epoch for all validators';
          
          // Hide loading
          if (loadingEl) loadingEl.style.display = 'none';
          
          // Now initialize with XNT data
          initializeCombinedChartWithXNT();
        }
      }
    }

    function initializeChart(chartId) {
      const data = window.chartDataStore[chartId];
      if (!data || data.labels.length === 0) return;

      const ctx = document.getElementById(chartId);
      if (!ctx) return;

      // Destroy existing chart if any
      if (chartInstances[chartId]) {
        chartInstances[chartId].destroy();
      }

      const isXNT = data.type === 'xnt';
      
      // Get color from validatorColorMap if available (matches combined chart)
      let colorIndex = 0;
      if (window.validatorColorMap && data.voteAccount && window.validatorColorMap[data.voteAccount] !== undefined) {
        colorIndex = window.validatorColorMap[data.voteAccount];
      }
      const color = chartColors[colorIndex % chartColors.length];

      chartInstances[chartId] = new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.labels,
          datasets: [{
            label: isXNT ? 'XNT Rewards' : 'Epoch Credits',
            data: data.data,
            borderColor: color.border,
            backgroundColor: color.bg,
            borderWidth: 2,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: color.border,
            pointBorderColor: color.border,
            pointRadius: 3,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: '#1a1d24',
              titleColor: '#ffffff',
              bodyColor: '#8a8f98',
              borderColor: '#2a2d35',
              borderWidth: 1,
              padding: 12,
              displayColors: false,
              callbacks: {
                title: function(items) {
                  return 'Epoch ' + items[0].label;
                },
                label: function(item) {
                  if (isXNT) {
                    return 'Earned: ' + formatNumber(item.raw, 2) + ' XNT';
                  }
                  return 'Credits: ' + formatNumber(item.raw, 0);
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                color: 'rgba(42, 45, 53, 0.5)',
                drawBorder: false
              },
              ticks: {
                color: '#5a5f68',
                font: {
                  size: 10
                },
                maxTicksLimit: 10
              }
            },
            y: {
              grid: {
                color: 'rgba(42, 45, 53, 0.5)',
                drawBorder: false
              },
              ticks: {
                color: '#5a5f68',
                font: {
                  size: 10
                },
                stepSize: isXNT ? 2 : undefined,
                callback: function(value) {
                  if (isXNT) {
                    return formatNumber(value, 1) + ' XNT';
                  }
                  return formatCompact(value);
                }
              }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
    }

    // Initialize combined chart with multiple lines
    function initializeCombinedChartWithXNT() {
      const validators = window.combinedChartValidators;
      const xntData = window.combinedChartXNTData;
      if (!validators || validators.length === 0 || !xntData) return;

      const ctx = document.getElementById('combinedChart');
      if (!ctx) return;

      // Destroy existing chart if any
      if (chartInstances['combinedChart']) {
        chartInstances['combinedChart'].destroy();
      }

      const datasets = [];
      const legendHtml = [];
      let maxValue = 0;
      
      validators.forEach((validator, index) => {
        const color = chartColors[index % chartColors.length];
        const dataMap = xntData.rewards[validator.voteAccount] || {};
        const data = xntData.epochs.map(epoch => dataMap[epoch] !== undefined ? dataMap[epoch] : null);
        
        // Track max value for dynamic stepSize
        data.forEach(v => { if (v !== null && v > maxValue) maxValue = v; });
        
        datasets.push({
          label: validator.name,
          data: data,
          borderColor: color.border,
          backgroundColor: color.bg,
          borderWidth: 2,
          fill: false,
          tension: 0.4,
          pointBackgroundColor: color.border,
          pointBorderColor: color.border,
          pointRadius: 2,
          pointHoverRadius: 5,
          spanGaps: true
        });
        
        legendHtml.push(`
          <div class="chart-legend-item">
            <div class="chart-legend-color" style="background: ${color.border}"></div>
            <span>${validator.name}</span>
          </div>
        `);
      });

      // Update legend
      document.getElementById('combinedChartLegend').innerHTML = legendHtml.join('');
      
      // Calculate appropriate stepSize based on data range
      // For max < 20: stepSize 2, for max < 50: stepSize 5, for max < 100: stepSize 10
      let stepSize = 2;
      if (maxValue > 100) stepSize = 20;
      else if (maxValue > 50) stepSize = 10;
      else if (maxValue > 20) stepSize = 5;

      chartInstances['combinedChart'] = new Chart(ctx, {
        type: 'line',
        data: {
          labels: xntData.epochs,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: '#1a1d24',
              titleColor: '#ffffff',
              bodyColor: '#8a8f98',
              borderColor: '#2a2d35',
              borderWidth: 1,
              padding: 12,
              callbacks: {
                title: function(items) {
                  return 'Epoch ' + items[0].label;
                },
                label: function(context) {
                  return context.dataset.label + ': ' + formatNumber(context.raw, 2) + ' XNT';
                }
              }
            }
          },
          scales: {
            x: {
              grid: { color: 'rgba(255, 255, 255, 0.05)' },
              ticks: { color: '#8a8f98' }
            },
            y: {
              grid: { color: 'rgba(255, 255, 255, 0.05)' },
              ticks: { 
                color: '#8a8f98',
                stepSize: stepSize,
                callback: function(value) {
                  return formatNumber(value, 1) + ' XNT';
                }
              }
            }
          }
        }
      });
    }

    function initializeCombinedChart() {
      const validators = window.combinedChartValidators;
      if (!validators || validators.length === 0) return;

      const ctx = document.getElementById('combinedChart');
      if (!ctx) return;

      // Destroy existing chart if any
      if (chartInstances['combinedChart']) {
        chartInstances['combinedChart'].destroy();
      }

      // Check if we have XNT rewards data
      let hasXNTData = false;
      validators.forEach(v => {
        const xntHistory = getValidatorRewardsHistory(v.voteAccount);
        if (xntHistory && xntHistory.length > 1) {
          hasXNTData = true;
        }
      });

      // Build datasets for each validator
      const datasets = [];
      const legendHtml = [];
      
      // Find common epoch range
      let allEpochs = new Set();
      
      if (hasXNTData) {
        // Use XNT rewards data
        validators.forEach(v => {
          const xntHistory = getValidatorRewardsHistory(v.voteAccount);
          if (xntHistory) {
            xntHistory.forEach(entry => {
              if (entry && entry.epoch) allEpochs.add(entry.epoch);
            });
          }
        });
      } else {
        // Use epoch credits - skip the most recent (current incomplete) epoch
        validators.forEach(v => {
          if (v.epochCreditsHistory && v.epochCreditsHistory.length > 1) {
            // Skip the last entry (current epoch) by iterating only up to length-1
            for (let i = 0; i < v.epochCreditsHistory.length - 1; i++) {
              const entry = v.epochCreditsHistory[i];
              if (entry && entry[0]) allEpochs.add(entry[0]);
            }
          }
        });
      }
      
      // Sort epochs and take last 30
      let sortedEpochs = Array.from(allEpochs).sort((a, b) => a - b);
      sortedEpochs = sortedEpochs.slice(-30);
      
      validators.forEach((validator, index) => {
        const color = chartColors[index % chartColors.length];
        
        // Build data map for this validator
        const dataMap = {};
        
        if (hasXNTData) {
          // Use XNT rewards data
          const xntHistory = getValidatorRewardsHistory(validator.voteAccount);
          if (xntHistory) {
            xntHistory.forEach(entry => {
              dataMap[entry.epoch] = entry.earned;
            });
          }
        } else {
          // Use epoch credits - skip the last entry (current incomplete epoch)
          if (validator.epochCreditsHistory && validator.epochCreditsHistory.length > 1) {
            for (let i = 0; i < validator.epochCreditsHistory.length - 1; i++) {
              const entry = validator.epochCreditsHistory[i];
              if (entry && entry.length >= 3) {
                const creditsEarned = entry[1] - entry[2];
                dataMap[entry[0]] = creditsEarned;
              }
            }
          }
        }
        
        // Build data array aligned to sortedEpochs
        const data = sortedEpochs.map(epoch => dataMap[epoch] !== undefined ? dataMap[epoch] : null);
        
        datasets.push({
          label: validator.name,
          data: data,
          borderColor: color.border,
          backgroundColor: color.bg,
          borderWidth: 2,
          fill: false,
          tension: 0.4,
          pointBackgroundColor: color.border,
          pointBorderColor: color.border,
          pointRadius: 2,
          pointHoverRadius: 5,
          spanGaps: true
        });
        
        legendHtml.push(`
          <div class="chart-legend-item">
            <div class="chart-legend-color" style="background: ${color.border}"></div>
            <span>${validator.name}</span>
          </div>
        `);
      });

      // Update legend
      document.getElementById('combinedChartLegend').innerHTML = legendHtml.join('');

      // Update chart title
      const chartTitle = document.querySelector('#combinedChartContainer .chart-title');
      const chartSubtitle = document.querySelector('#combinedChartContainer .chart-subtitle');
      if (chartTitle) chartTitle.textContent = hasXNTData ? 'Combined XNT Rewards Trend' : 'Combined Epoch Credits Trend';
      if (chartSubtitle) chartSubtitle.textContent = hasXNTData ? 'XNT earned per completed epoch for all validators' : 'Credits earned per completed epoch for all validators';

      chartInstances['combinedChart'] = new Chart(ctx, {
        type: 'line',
        data: {
          labels: sortedEpochs,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: '#1a1d24',
              titleColor: '#ffffff',
              bodyColor: '#8a8f98',
              borderColor: '#2a2d35',
              borderWidth: 1,
              padding: 12,
              callbacks: {
                title: function(items) {
                  return 'Epoch ' + items[0].label;
                },
                label: function(item) {
                  if (hasXNTData) {
                    return item.dataset.label + ': ' + formatNumber(item.raw, 2) + ' XNT';
                  }
                  return item.dataset.label + ': ' + formatNumber(item.raw, 0);
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                color: 'rgba(42, 45, 53, 0.5)',
                drawBorder: false
              },
              ticks: {
                color: '#5a5f68',
                font: {
                  size: 10
                },
                maxTicksLimit: 15
              }
            },
            y: {
              grid: {
                color: 'rgba(42, 45, 53, 0.5)',
                drawBorder: false
              },
              ticks: {
                color: '#5a5f68',
                font: {
                  size: 10
                },
                stepSize: hasXNTData ? 2 : undefined,
                callback: function(value) {
                  if (hasXNTData) {
                    return formatNumber(value, 1) + ' XNT';
                  }
                  return formatCompact(value);
                }
              }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
    }

    // ==========================================
    // Network TPS Functions
    // ==========================================
    
    async function updateNetworkTps() {
      try {
        const samples = await rpcCall('getRecentPerformanceSamples', [1]);
        if (samples && samples.length > 0) {
          const sample = samples[0];
          // TPS = transactions / seconds
          const tps = sample.numTransactions / sample.samplePeriodSecs;
          document.getElementById('networkTps').textContent = formatCompact(Math.round(tps));
        }
      } catch (e) {
        console.error('Error fetching TPS:', e);
        document.getElementById('networkTps').textContent = '--';
      }
    }

    // ==========================================
    // Leader Schedule Functions
    // ==========================================
    
    let leaderScheduleCache = null;
    let leaderScheduleEpoch = null;
    
    async function loadLeaderSchedule() {
      try {
        // Get current epoch info
        const epochInfo = await rpcCall('getEpochInfo');
        
        // Only reload schedule if epoch changed
        if (leaderScheduleEpoch === epochInfo.epoch && leaderScheduleCache) {
          updateCurrentLeader();
          return;
        }
        
        // Fetch leader schedule for current epoch
        const schedule = await rpcCall('getLeaderSchedule');
        
        if (schedule) {
          leaderScheduleCache = schedule;
          leaderScheduleEpoch = epochInfo.epoch;
          updateCurrentLeader();
        }
      } catch (e) {
        console.error('Error loading leader schedule:', e);
        document.getElementById('currentLeaderName').textContent = 'Unable to load';
      }
    }
    
    async function updateCurrentLeader() {
      if (!leaderScheduleCache) {
        await loadLeaderSchedule();
        return;
      }
      
      try {
        const epochInfo = await rpcCall('getEpochInfo');
        const currentSlotInEpoch = epochInfo.slotIndex;
        
        // Reload schedule if epoch changed
        if (leaderScheduleEpoch !== epochInfo.epoch) {
          await loadLeaderSchedule();
          return;
        }
        
        // Build slot -> leader map
        const slotToLeader = {};
        for (const [leader, slots] of Object.entries(leaderScheduleCache)) {
          for (const slot of slots) {
            slotToLeader[slot] = leader;
          }
        }
        
        // Find current leader (the one for current slot in epoch)
        const currentLeader = slotToLeader[currentSlotInEpoch];
        
        // Find next unique leaders
        const nextLeaders = [];
        const seenLeaders = new Set();
        if (currentLeader) seenLeaders.add(currentLeader);
        
        for (let i = currentSlotInEpoch + 1; i < epochInfo.slotsInEpoch && nextLeaders.length < 10; i++) {
          const leader = slotToLeader[i];
          if (leader && !seenLeaders.has(leader)) {
            seenLeaders.add(leader);
            nextLeaders.push(leader);
          }
        }
        
        // Get validator info for leaders
        const currentLeaderInfo = currentLeader ? getValidatorByNodePubkey(currentLeader) : null;
        
        // Calculate which block of 4 the leader is producing
        let blockOfFour = 1;
        if (currentLeader && leaderScheduleCache[currentLeader]) {
          const leaderSlots = leaderScheduleCache[currentLeader].sort((a, b) => a - b);
          // Find current slot's position in leader's consecutive slots
          for (let i = 0; i < leaderSlots.length; i++) {
            if (leaderSlots[i] === currentSlotInEpoch) {
              // Check if this is part of a consecutive group
              let groupStart = i;
              while (groupStart > 0 && leaderSlots[groupStart - 1] === leaderSlots[groupStart] - 1) {
                groupStart--;
              }
              blockOfFour = (i - groupStart) + 1;
              break;
            }
          }
        }
        
        // Update current leader display
        const currentSlot = epochInfo.absoluteSlot || (epochInfo.epoch * epochInfo.slotsInEpoch + currentSlotInEpoch);
        document.getElementById('currentLeaderSlot').textContent = formatCompact(currentSlot);
        document.getElementById('currentLeaderBlock').textContent = `Block ${blockOfFour} of 4`;
        
        if (currentLeaderInfo) {
          document.getElementById('currentLeaderName').textContent = currentLeaderInfo.name;
          // Show vote account
          const voteAccount = currentLeaderInfo.votePubkey;
          if (voteAccount) {
            document.getElementById('currentLeaderVote').textContent = shortenAddress(voteAccount);
            document.getElementById('currentLeaderVote').title = voteAccount;
          }
          const logoEl = document.getElementById('currentLeaderLogo');
          if (currentLeaderInfo.iconUrl) {
            logoEl.innerHTML = `<img src="${currentLeaderInfo.iconUrl}" alt="${currentLeaderInfo.name.charAt(0)}" onerror="this.style.display='none';this.parentElement.textContent='${currentLeaderInfo.name.charAt(0).toUpperCase()}';">`;
          } else {
            logoEl.textContent = currentLeaderInfo.name.charAt(0).toUpperCase();
          }
        } else if (currentLeader) {
          document.getElementById('currentLeaderName').textContent = shortenAddress(currentLeader);
          document.getElementById('currentLeaderVote').textContent = '';
          document.getElementById('currentLeaderLogo').textContent = '?';
        } else {
          document.getElementById('currentLeaderName').textContent = 'Unknown';
          document.getElementById('currentLeaderVote').textContent = '';
          document.getElementById('currentLeaderLogo').textContent = '?';
        }
        
        // Update next leaders display
        const nextListEl = document.getElementById('nextLeadersList');
        if (nextLeaders.length > 0) {
          nextListEl.innerHTML = nextLeaders.map(leader => {
            const info = getValidatorByNodePubkey(leader);
            const fullName = info ? info.name : shortenAddress(leader);
            // Abbreviate name to max 8 chars
            const name = fullName.length > 8 ? fullName.slice(0, 7) + '' : fullName;
            const initial = fullName.charAt(0).toUpperCase();
            let logoHtml;
            if (info && info.iconUrl) {
              logoHtml = `<div class="leader-next-logo"><img src="${info.iconUrl}" alt="${initial}" onerror="this.style.display='none';this.parentElement.textContent='${initial}';"></div>`;
            } else {
              logoHtml = `<div class="leader-next-logo">${initial}</div>`;
            }
            return `
              <div class="leader-next-item" title="${fullName}">
                ${logoHtml}
                <span class="leader-next-name">${name}</span>
              </div>
            `;
          }).join('');
        } else {
          nextListEl.innerHTML = '<div class="leader-next-item">No upcoming leaders found</div>';
        }
        
      } catch (e) {
        console.error('Error updating current leader:', e);
      }
    }
    
    function getValidatorByNodePubkey(nodePubkey) {
      if (!allValidators || allValidators.length === 0) return null;
      return allValidators.find(v => v.nodePubkey === nodePubkey) || null;
    }

    // Disclaimer Modal Functions
    const DISCLAIMER_VERSION = '1.0';
    const DISCLAIMER_STORAGE_KEY = 'x1_validator_hq_disclaimer_accepted';

    function checkDisclaimerAccepted() {
      const accepted = localStorage.getItem(DISCLAIMER_STORAGE_KEY);
      if (accepted) {
        try {
          const data = JSON.parse(accepted);
          // Check if the accepted version matches current version
          if (data.version === DISCLAIMER_VERSION) {
            return true;
          }
        } catch (e) {
          // Invalid data, show disclaimer again
        }
      }
      return false;
    }

    function showDisclaimerModal() {
      document.getElementById('disclaimerModal').classList.add('show');
      document.body.style.overflow = 'hidden';
    }

    function hideDisclaimerModal() {
      document.getElementById('disclaimerModal').classList.remove('show');
      document.body.style.overflow = '';
    }

    function toggleDisclaimerCheckbox() {
      const checkbox = document.getElementById('disclaimerCheckbox');
      checkbox.checked = !checkbox.checked;
      updateDisclaimerButton();
    }

    function updateDisclaimerButton() {
      const checkbox = document.getElementById('disclaimerCheckbox');
      const btn = document.getElementById('disclaimerAcceptBtn');
      btn.disabled = !checkbox.checked;
    }

    function acceptDisclaimer() {
      const checkbox = document.getElementById('disclaimerCheckbox');
      if (!checkbox.checked) return;

      // Store acceptance with version and timestamp
      const acceptanceData = {
        version: DISCLAIMER_VERSION,
        acceptedAt: new Date().toISOString(),
        userAgent: navigator.userAgent
      };
      localStorage.setItem(DISCLAIMER_STORAGE_KEY, JSON.stringify(acceptanceData));
      
      hideDisclaimerModal();
    }

    // Check disclaimer on page load
    document.addEventListener('DOMContentLoaded', function() {
      if (!checkDisclaimerAccepted()) {
        showDisclaimerModal();
      }
    });

    // Network Toggle Functions
    let currentNetwork = 'x1';

    function toggleNetwork() {
      const toggle = document.getElementById('networkToggle');
      const x1Label = document.getElementById('x1Label');
      const solanaLabel = document.getElementById('solanaLabel');
      
      if (currentNetwork === 'x1') {
        // Switch to Solana (show coming soon)
        toggle.classList.add('solana-active');
        x1Label.classList.add('inactive');
        x1Label.classList.remove('x1');
        solanaLabel.classList.remove('inactive');
        solanaLabel.classList.add('solana');
        currentNetwork = 'solana';
        
        // Show coming soon modal
        document.getElementById('solanaModal').classList.add('show');
      } else {
        // Switch back to X1
        toggle.classList.remove('solana-active');
        x1Label.classList.remove('inactive');
        x1Label.classList.add('x1');
        solanaLabel.classList.add('inactive');
        solanaLabel.classList.remove('solana');
        currentNetwork = 'x1';
      }
    }

    function closeSolanaModal() {
      document.getElementById('solanaModal').classList.remove('show');
      
      // Reset toggle back to X1
      const toggle = document.getElementById('networkToggle');
      const x1Label = document.getElementById('x1Label');
      const solanaLabel = document.getElementById('solanaLabel');
      
      toggle.classList.remove('solana-active');
      x1Label.classList.remove('inactive');
      x1Label.classList.add('x1');
      solanaLabel.classList.add('inactive');
      solanaLabel.classList.remove('solana');
      currentNetwork = 'x1';
    }

    // Close modal on overlay click
    document.addEventListener('DOMContentLoaded', function() {
      const solanaModal = document.getElementById('solanaModal');
      if (solanaModal) {
        solanaModal.addEventListener('click', function(e) {
          if (e.target === this) {
            closeSolanaModal();
          }
        });
      }
    });

    // Initialize
    async function init() {
      // Fetch rewards history first if API is configured
      await fetchRewardsHistory();
      
      // Then load network stats
      await loadNetworkStats();
      updatePortfolioCount();
      
      // Initialize map in background (don't await - let it load independently)
      setTimeout(() => {
        initializeMap().catch(err => {
          console.error('Map init error:', err);
          document.getElementById('mapLoading').style.display = 'none';
          document.getElementById('countryList').innerHTML = '<div class="map-loading-text">Map unavailable</div>';
        });
      }, 500);
      
      // Load leader schedule and TPS
      loadLeaderSchedule();
      updateNetworkTps();
      
      // Refresh leader display and TPS every 2 seconds
      setInterval(() => {
        updateCurrentLeader();
        updateNetworkTps();
      }, 2000);
    }
    init();
  </script>

  <!-- Solana Coming Soon Modal -->
  <div class="solana-modal-overlay" id="solanaModal">
    <div class="solana-modal">
      <div class="solana-modal-logo">
        <svg viewBox="0 0 397.7 311.7" fill="white">
          <path d="M64.6 237.9c2.4-2.4 5.7-3.8 9.2-3.8h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1l62.7-62.7z"/>
          <path d="M64.6 3.8C67.1 1.4 70.4 0 73.8 0h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1L64.6 3.8z"/>
          <path d="M333.1 120.1c-2.4-2.4-5.7-3.8-9.2-3.8H6.5c-5.8 0-8.7 7-4.6 11.1l62.7 62.7c2.4 2.4 5.7 3.8 9.2 3.8h317.4c5.8 0 8.7-7 4.6-11.1l-62.7-62.7z"/>
        </svg>
      </div>
      <h2 class="solana-modal-title">Solana Integration</h2>
      <p class="solana-modal-subtitle">Coming Soon!</p>
      <div class="solana-modal-features">
        <div class="solana-modal-feature">
          <span class="solana-modal-feature-icon"></span>
          <span>Manage Solana validators</span>
        </div>
        <div class="solana-modal-feature">
          <span class="solana-modal-feature-icon"></span>
          <span>Stake & delegate SOL</span>
        </div>
        <div class="solana-modal-feature">
          <span class="solana-modal-feature-icon"></span>
          <span>Track performance & rewards</span>
        </div>
        <div class="solana-modal-feature">
          <span class="solana-modal-feature-icon"></span>
          <span>Same great interface you love</span>
        </div>
      </div>
      <button class="solana-modal-close" onclick="closeSolanaModal()">Got It!</button>
    </div>
  </div>
</body>
</html>
